import { Direction, Directionality } from '@angular/cdk/bidi';
import { BooleanInput } from '@angular/cdk/coercion';
import { CdkConnectedOverlay, ConnectionPositionPair } from '@angular/cdk/overlay';
import { ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnDestroy, OnInit, QueryList, Renderer2, TemplateRef } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { TDSSafeAny } from 'tds-ui/shared/utility';
import { TDSCascaderI18nInterface, TDSI18nService } from 'tds-ui/i18n';
import { TDSCascaderOptionComponent } from './cascader-li.component';
import { TDSCascaderService } from './cascader.service';
import { TDSCascaderComponentAsSource, TDSCascaderExpandTrigger, TDSCascaderOption, TDSCascaderSize, TDSCascaderTriggerType, TDSShowSearchOptions } from './typings';
import { NgClassType, NgStyleInterface, TDSConfigKey, TDSConfigService } from 'tds-ui/core/config';
import { TDSNoAnimationDirective } from 'tds-ui/core/no-animation';
import * as i0 from "@angular/core";
export declare class TDSCascaderComponent implements TDSCascaderComponentAsSource, OnInit, OnDestroy, ControlValueAccessor {
    cascaderService: TDSCascaderService;
    tdsConfigService: TDSConfigService;
    private ngZone;
    private cdr;
    private i18nService;
    private directionality;
    noAnimation?: TDSNoAnimationDirective | undefined;
    readonly _tdsModuleName: TDSConfigKey;
    static ngAcceptInputType_tdsShowInput: BooleanInput;
    static ngAcceptInputType_tdsShowArrow: BooleanInput;
    static ngAcceptInputType_tdsAllowClear: BooleanInput;
    static ngAcceptInputType_tdsAutoFocus: BooleanInput;
    static ngAcceptInputType_tdsChangeOnSelect: BooleanInput;
    static ngAcceptInputType_tdsDisabled: BooleanInput;
    selectContainer: ElementRef;
    input: ElementRef;
    menu: ElementRef;
    overlay: CdkConnectedOverlay;
    cascaderItems: QueryList<TDSCascaderOptionComponent>;
    tdsOptionRender: TemplateRef<{
        $implicit: TDSCascaderOption;
        index: number;
    }> | null;
    tdsShowInput: boolean;
    tdsShowArrow: boolean;
    tdsAllowClear: boolean;
    tdsAutoFocus: boolean;
    tdsChangeOnSelect: boolean;
    tdsDisabled: boolean;
    tdsColumnClassName?: string;
    tdsExpandTrigger: TDSCascaderExpandTrigger;
    tdsValueProperty: string;
    tdsLabelRender: TemplateRef<void> | null;
    tdsLabelProperty: string;
    tdsNotFoundContent?: string | TemplateRef<void>;
    tdsSize: TDSCascaderSize;
    tdsBackdrop: boolean;
    tdsShowSearch: boolean | TDSShowSearchOptions;
    tdsPlaceHolder: string;
    tdsMenuClassName?: string;
    tdsMenuStyle: NgStyleInterface | null;
    tdsMouseEnterDelay: number;
    tdsMouseLeaveDelay: number;
    tdsTriggerAction: TDSCascaderTriggerType | TDSCascaderTriggerType[];
    tdsChangeOn?: (option: TDSCascaderOption, level: number) => boolean;
    tdsLoadData?: (node: TDSCascaderOption, index: number) => PromiseLike<TDSSafeAny>;
    tdsSuffixIcon: string | TemplateRef<void>;
    tdsExpandIcon: string | TemplateRef<void>;
    get tdsOptions(): TDSCascaderOption[] | null;
    set tdsOptions(options: TDSCascaderOption[] | null);
    readonly tdsVisibleChange: EventEmitter<boolean>;
    readonly tdsSelectionChange: EventEmitter<TDSCascaderOption[]>;
    readonly tdsSelect: EventEmitter<{
        option: TDSCascaderOption;
        index: number;
    } | null>;
    readonly tdsClear: EventEmitter<void>;
    /**
     * If the dropdown should show the empty content.
     * `true` if there's no options.
     */
    shouldShowEmpty: boolean;
    el: HTMLElement;
    menuVisible: boolean;
    isLoading: boolean;
    labelRenderText?: string;
    labelRenderContext: {};
    onChange: Function;
    onTouched: Function;
    positions: ConnectionPositionPair[];
    /**
     * Dropdown's with in pixel.
     */
    dropdownWidthStyle?: string;
    dropdownHeightStyle: 'auto' | '';
    isFocused: boolean;
    locale: TDSCascaderI18nInterface;
    dir: Direction;
    tdsClassContainer: string;
    tdsClassArrow: string;
    private destroy$;
    private inputString;
    private isOpening;
    private delayMenuTimer;
    private delaySelectTimer;
    get inSearchingMode(): boolean;
    set inputValue(inputValue: string);
    get inputValue(): string;
    get menuCls(): NgClassType;
    get menuColumnCls(): NgClassType;
    private get hasInput();
    private get hasValue();
    get showLabelRender(): boolean;
    get showPlaceholder(): boolean;
    get clearIconVisible(): boolean;
    get isLabelRenderTemplate(): boolean;
    constructor(cascaderService: TDSCascaderService, tdsConfigService: TDSConfigService, ngZone: NgZone, cdr: ChangeDetectorRef, i18nService: TDSI18nService, elementRef: ElementRef, renderer: Renderer2, directionality: Directionality, noAnimation?: TDSNoAnimationDirective | undefined);
    ngOnInit(): void;
    ngOnDestroy(): void;
    registerOnChange(fn: () => {}): void;
    registerOnTouched(fn: () => {}): void;
    writeValue(value: TDSSafeAny): void;
    delaySetMenuVisible(visible: boolean, delay?: number, setOpening?: boolean): void;
    setMenuVisible(visible: boolean): void;
    private clearDelayMenuTimer;
    clearSelection(event?: Event): void;
    getSubmitValue(): TDSSafeAny[];
    focus(): void;
    blur(): void;
    handleInputBlur(): void;
    handleInputFocus(): void;
    onTriggerClick(): void;
    onTriggerMouseEnter(): void;
    onTriggerMouseLeave(event: MouseEvent): void;
    onOptionMouseEnter(option: TDSCascaderOption, columnIndex: number, event: Event): void;
    onOptionMouseLeave(option: TDSCascaderOption, _columnIndex: number, event: Event): void;
    onOptionClick(option: TDSCascaderOption, columnIndex: number, event: Event): void;
    onClickOutside(event: MouseEvent): void;
    private isActionTrigger;
    private onEnter;
    private moveUpOrDown;
    private moveLeft;
    private moveRight;
    private clearDelaySelectTimer;
    private delaySetOptionActivated;
    private toggleSearchingMode;
    isOptionActivated(option: TDSCascaderOption, index: number): boolean;
    setDisabledState(isDisabled: boolean): void;
    closeMenu(): void;
    /**
     * Reposition the cascader panel. When a menu opens, the cascader expands
     * and may exceed the boundary of browser's window.
     */
    private reposition;
    /**
     * When a cascader options is changed, a child needs to know that it should re-render.
     */
    private checkChildren;
    private setDisplayLabel;
    private setDropdownStyles;
    private setLocale;
    private scrollToActivatedOptions;
    private setupKeydownListener;
    updateClassCss(): void;
    private getCssBySize;
    private getCssArrow;
    private getCssContainer;
    static ɵfac: i0.ɵɵFactoryDeclaration<TDSCascaderComponent, [null, null, null, null, null, null, null, { optional: true; }, { optional: true; host: true; }]>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TDSCascaderComponent, "tds-cascader, [tds-cascader]", ["tdsCascader"], { "tdsOptionRender": "tdsOptionRender"; "tdsShowInput": "tdsShowInput"; "tdsShowArrow": "tdsShowArrow"; "tdsAllowClear": "tdsAllowClear"; "tdsAutoFocus": "tdsAutoFocus"; "tdsChangeOnSelect": "tdsChangeOnSelect"; "tdsDisabled": "tdsDisabled"; "tdsColumnClassName": "tdsColumnClassName"; "tdsExpandTrigger": "tdsExpandTrigger"; "tdsValueProperty": "tdsValueProperty"; "tdsLabelRender": "tdsLabelRender"; "tdsLabelProperty": "tdsLabelProperty"; "tdsNotFoundContent": "tdsNotFoundContent"; "tdsSize": "tdsSize"; "tdsBackdrop": "tdsBackdrop"; "tdsShowSearch": "tdsShowSearch"; "tdsPlaceHolder": "tdsPlaceHolder"; "tdsMenuClassName": "tdsMenuClassName"; "tdsMenuStyle": "tdsMenuStyle"; "tdsMouseEnterDelay": "tdsMouseEnterDelay"; "tdsMouseLeaveDelay": "tdsMouseLeaveDelay"; "tdsTriggerAction": "tdsTriggerAction"; "tdsChangeOn": "tdsChangeOn"; "tdsLoadData": "tdsLoadData"; "tdsSuffixIcon": "tdsSuffixIcon"; "tdsExpandIcon": "tdsExpandIcon"; "tdsOptions": "tdsOptions"; }, { "tdsVisibleChange": "tdsVisibleChange"; "tdsSelectionChange": "tdsSelectionChange"; "tdsSelect": "tdsSelect"; "tdsClear": "tdsClear"; }, never, ["*"]>;
}
//# sourceMappingURL=cascader.component.d.ts.map