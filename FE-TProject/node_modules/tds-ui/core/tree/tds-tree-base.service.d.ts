import { BehaviorSubject } from 'rxjs';
import { TDSTreeNode, TDSTreeNodeKey } from './tds-tree-base-node';
import { TDSFormatEmitEvent } from './tds-tree-base.definitions';
import { TDSSafeAny } from 'tds-ui/shared/utility';
import * as i0 from "@angular/core";
export declare class TDSTreeBaseService {
    DRAG_SIDE_RANGE: number;
    DRAG_MIN_GAP: number;
    isCheckStrictly: boolean;
    isMultiple: boolean;
    selectedNode: TDSTreeNode;
    rootNodes: TDSTreeNode[];
    flattenNodes$: BehaviorSubject<TDSTreeNode[]>;
    selectedNodeList: TDSTreeNode[];
    expandedNodeList: TDSTreeNode[];
    checkedNodeList: TDSTreeNode[];
    halfCheckedNodeList: TDSTreeNode[];
    matchedNodeList: TDSTreeNode[];
    /**
     * reset tree nodes will clear default node list
     */
    initTree(tdsNodes: TDSTreeNode[]): void;
    flattenTreeData(tdsNodes: TDSTreeNode[], expandedKeys?: TDSTreeNodeKey[] | true): void;
    getSelectedNode(): TDSTreeNode | null;
    /**
     * get some list
     */
    getSelectedNodeList(): TDSTreeNode[];
    /**
     * return checked nodes
     */
    getCheckedNodeList(): TDSTreeNode[];
    getHalfCheckedNodeList(): TDSTreeNode[];
    /**
     * return expanded nodes
     */
    getExpandedNodeList(): TDSTreeNode[];
    /**
     * return search matched nodes
     */
    getMatchedNodeList(): TDSTreeNode[];
    isArrayOfTDSTreeNode(value: TDSSafeAny[]): boolean;
    /**
     * set drag node
     */
    setSelectedNode(node: TDSTreeNode): void;
    /**
     * set node selected status
     */
    setNodeActive(node: TDSTreeNode): void;
    /**
     * add or remove node to selectedNodeList
     */
    setSelectedNodeList(node: TDSTreeNode, isMultiple?: boolean): void;
    /**
     * merge checked nodes
     */
    setHalfCheckedNodeList(node: TDSTreeNode): void;
    setCheckedNodeList(node: TDSTreeNode): void;
    /**
     * conduct checked/selected/expanded keys
     */
    conductNodeState(type?: string): TDSTreeNode[];
    /**
     * set expanded nodes
     */
    setExpandedNodeList(node: TDSTreeNode): void;
    setMatchedNodeList(node: TDSTreeNode): void;
    /**
     * check state
     *
     * @param isCheckStrictly
     */
    refreshCheckState(isCheckStrictly?: boolean): void;
    conduct(node: TDSTreeNode, isCheckStrictly?: boolean): void;
    /**
     * 1、children half checked
     * 2、children all checked, parent checked
     * 3、no children checked
     */
    conductUp(node: TDSTreeNode): void;
    /**
     * reset child check state
     */
    conductDown(node: TDSTreeNode, value: boolean): void;
    /**
     * flush after delete node
     */
    afterRemove(nodes: TDSTreeNode[]): void;
    /**
     * drag event
     */
    refreshDragNode(node: TDSTreeNode): void;
    resetNodeLevel(node: TDSTreeNode): void;
    calcDropPosition(event: DragEvent): number;
    /**
     * drop
     * 0: inner -1: pre 1: next
     */
    dropAndApply(targetNode: TDSTreeNode, dragPos?: number): void;
    /**
     * emit Structure
     * eventName
     * node
     * event: MouseEvent / DragEvent
     * dragNode
     */
    formatEvent(eventName: string, node: TDSTreeNode | null, event: MouseEvent | DragEvent | null): TDSFormatEmitEvent;
    /**
     * New functions for flatten nodes
     */
    getIndexOfArray(list: TDSTreeNode[], key: string): number;
    /**
     * Render by checkedKeys
     * When keys equals null, just render with checkStrictly
     *
     * @param keys
     * @param checkStrictly
     */
    conductCheck(keys: TDSTreeNodeKey[] | null, checkStrictly: boolean): void;
    conductExpandedKeys(keys?: TDSTreeNodeKey[] | true): void;
    conductSelectedKeys(keys: TDSTreeNodeKey[], isMulti: boolean): void;
    /**
     * Expand parent nodes by child node
     *
     * @param node
     */
    expandNodeAllParentBySearch(node: TDSTreeNode): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TDSTreeBaseService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TDSTreeBaseService>;
}
//# sourceMappingURL=tds-tree-base.service.d.ts.map