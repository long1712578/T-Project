import * as i0 from '@angular/core';
import { EventEmitter, Directive, ViewChild, TemplateRef, Input, Output, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { distinctUntilChanged, takeUntil } from 'rxjs/operators';
import { DEFAULT_TOOLTIP_POSITIONS, POSITION_MAP, getPlacementName, TDSOverlayModule } from 'tds-ui/core/overlay';
import { toBoolean, TDSHelperObject } from 'tds-ui/shared/utility';
import { zoomBigMotion } from 'tds-ui/core/animation';
import * as i1 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i2 from '@angular/cdk/overlay';
import { OverlayModule } from '@angular/cdk/overlay';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i4 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';

const _c0 = ["overlay"];
class TDSTooltipBaseDirective {
    constructor(elementRef, hostView, resolver, renderer) {
        this.elementRef = elementRef;
        this.hostView = hostView;
        this.resolver = resolver;
        this.renderer = renderer;
        this.autoClose = null;
        this.visibleChange = new EventEmitter();
        this.internalVisible = false;
        this.destroy$ = new Subject();
        this.triggerDisposables = [];
    }
    /**
     * This true title that would be used in other parts on this component.
     */
    get _title() {
        return this.title || this.directiveTitle || null;
    }
    get _content() {
        return this.content || this.directiveContent || null;
    }
    get _footer() {
        return this.footer || this.directiveFooter || null;
    }
    get _trigger() {
        return typeof this.trigger !== 'undefined' ? this.trigger : 'hover';
    }
    get _placement() {
        const p = this.placement;
        return Array.isArray(p) && p.length > 0 ? p : typeof p === 'string' && p ? [p] : ['top'];
    }
    get _visible() {
        return (typeof this.visible !== 'undefined' ? this.visible : this.internalVisible) || false;
    }
    get _mouseEnterDelay() {
        return this.mouseEnterDelay || 0.15;
    }
    get _mouseLeaveDelay() {
        return this.mouseLeaveDelay || 0.1;
    }
    get _overlayClassName() {
        return this.overlayClassName || null;
    }
    get _overlayStyle() {
        return this.overlayStyle || null;
    }
    get _autoClose() {
        return this.autoClose != null ? this.autoClose : true;
    }
    getProxyPropertyMap() {
        return {
            noAnimation: ['noAnimation', () => true]
        };
    }
    ngOnChanges(changes) {
        const { trigger } = changes;
        if (trigger && !trigger.isFirstChange()) {
            this.registerTriggers();
        }
        if (this.component) {
            this.updatePropertiesByChanges(changes);
        }
    }
    ngAfterViewInit() {
        this.createComponent();
        this.registerTriggers();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        // Clear toggling timer. Issue #3875 #4317 #4386
        this.clearTogglingTimer();
        this.removeTriggerListeners();
    }
    show() {
        var _a;
        (_a = this.component) === null || _a === void 0 ? void 0 : _a.show();
    }
    hide() {
        var _a;
        (_a = this.component) === null || _a === void 0 ? void 0 : _a.hide();
    }
    /**
     * Force the component to update its position.
     */
    updatePosition() {
        if (this.component) {
            this.component.updatePosition();
        }
    }
    /**
     * Create a dynamic tooltip component. This method can be override.
     */
    createComponent() {
        const componentRef = this.componentRef;
        this.component = componentRef.instance;
        // Remove the component's DOM because it should be in the overlay container.
        this.renderer.removeChild(this.renderer.parentNode(this.elementRef.nativeElement), componentRef.location.nativeElement);
        this.component.setOverlayOrigin(this.origin || this.elementRef);
        this.initProperties();
        this.component.visibleChange
            .pipe(distinctUntilChanged(), takeUntil(this.destroy$))
            .subscribe((visible) => {
            this.internalVisible = visible;
            this.visibleChange.emit(visible);
        });
    }
    registerTriggers() {
        // When the method gets invoked, all properties has been synced to the dynamic component.
        // After removing the old API, we can just check the directive's own `trigger`.
        const el = this.elementRef.nativeElement;
        const trigger = this.trigger;
        this.removeTriggerListeners();
        if (trigger === 'hover') {
            let overlayElement;
            this.triggerDisposables.push(this.renderer.listen(el, 'mouseenter', () => {
                this.delayEnterLeave(true, true, this._mouseEnterDelay);
            }));
            this.triggerDisposables.push(this.renderer.listen(el, 'mouseleave', () => {
                var _a;
                this.delayEnterLeave(true, false, this._mouseLeaveDelay);
                if (((_a = this.component) === null || _a === void 0 ? void 0 : _a.overlay.overlayRef) && !overlayElement) {
                    overlayElement = this.component.overlay.overlayRef.overlayElement;
                    this.triggerDisposables.push(this.renderer.listen(overlayElement, 'mouseenter', () => {
                        this.delayEnterLeave(false, true, this._mouseEnterDelay);
                    }));
                    this.triggerDisposables.push(this.renderer.listen(overlayElement, 'mouseleave', () => {
                        this.delayEnterLeave(false, false, this._mouseLeaveDelay);
                    }));
                }
            }));
        }
        else if (trigger === 'focus') {
            this.triggerDisposables.push(this.renderer.listen(el, 'focus', () => this.show()));
            this.triggerDisposables.push(this.renderer.listen(el, 'blur', () => this.hide()));
        }
        else if (trigger === 'click') {
            this.triggerDisposables.push(this.renderer.listen(el, 'click', (e) => {
                e.preventDefault();
                this.show();
            }));
        }
        // Else do nothing because user wants to control the visibility programmatically.
    }
    updatePropertiesByChanges(changes) {
        this.updatePropertiesByKeys(Object.keys(changes));
    }
    updatePropertiesByKeys(keys) {
        var _a;
        const mappingProperties = Object.assign({ 
            // common mappings
            title: ['title', () => this._title], directiveTitle: ['title', () => this._title], content: ['content', () => this._content], directiveContent: ['content', () => this._content], footer: ['footer', () => this._footer], directiveFooter: ['footer', () => this._footer], trigger: ['trigger', () => this._trigger], placement: ['placement', () => this._placement], visible: ['visible', () => this._visible], mouseEnterDelay: ['mouseEnterDelay', () => this._mouseEnterDelay], mouseLeaveDelay: ['mouseLeaveDelay', () => this._mouseLeaveDelay], overlayClassName: ['overlayClassName', () => this._overlayClassName], overlayStyle: ['overlayStyle', () => this._overlayStyle], autoClose: ['autoClose', () => this._autoClose] }, this.getProxyPropertyMap());
        (keys || Object.keys(mappingProperties).filter(key => !key.startsWith('directive'))).forEach((property) => {
            if (mappingProperties[property]) {
                const [name, valueFn] = mappingProperties[property];
                this.updateComponentValue(name, valueFn());
            }
        });
        (_a = this.component) === null || _a === void 0 ? void 0 : _a.updateByDirective();
    }
    initProperties() {
        this.updatePropertiesByKeys();
    }
    updateComponentValue(key, value) {
        if (typeof value !== 'undefined') {
            // @ts-ignore
            this.component[key] = value;
        }
    }
    delayEnterLeave(isOrigin, isEnter, delay = -1) {
        if (this.delayTimer) {
            this.clearTogglingTimer();
        }
        else if (delay > 0) {
            this.delayTimer = setTimeout(() => {
                this.delayTimer = undefined;
                isEnter ? this.show() : this.hide();
            }, delay * 1000);
        }
        else {
            // `isOrigin` is used due to the tooltip will not hide immediately
            // (may caused by the fade-out animation).
            isEnter && isOrigin ? this.show() : this.hide();
        }
    }
    removeTriggerListeners() {
        this.triggerDisposables.forEach(dispose => dispose());
        this.triggerDisposables.length = 0;
    }
    clearTogglingTimer() {
        if (this.delayTimer) {
            clearTimeout(this.delayTimer);
            this.delayTimer = undefined;
        }
    }
}
TDSTooltipBaseDirective.ɵfac = function TDSTooltipBaseDirective_Factory(t) { return new (t || TDSTooltipBaseDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.Renderer2)); };
TDSTooltipBaseDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSTooltipBaseDirective, features: [i0.ɵɵNgOnChangesFeature] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTooltipBaseDirective, [{
            type: Directive
        }], function () { return [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }, { type: i0.Renderer2 }]; }, null);
})();
// tslint:disable-next-line:directive-class-suffix
class TDSTooltipBaseComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.title = null;
        this.content = null;
        this.footer = null;
        this.overlayStyle = {};
        this.backdrop = false;
        this.autoClose = true;
        this.visibleChange = new Subject();
        this._visible = false;
        this._trigger = 'hover';
        this.preferredPlacement = 'top';
        this.dir = 'ltr';
        this._classMap = {};
        this._prefix = 'tds-tooltip';
        this._positions = [...DEFAULT_TOOLTIP_POSITIONS];
        this.destroy$ = new Subject();
    }
    set visible(value) {
        const visible = toBoolean(value);
        if (this._visible !== visible) {
            this._visible = visible;
            this.visibleChange.next(visible);
        }
    }
    get visible() {
        return this._visible;
    }
    set trigger(value) {
        this._trigger = value;
    }
    get trigger() {
        return this._trigger;
    }
    set placement(value) {
        const preferredPosition = value.map(placement => POSITION_MAP[placement]);
        this._positions = [...preferredPosition, ...DEFAULT_TOOLTIP_POSITIONS];
    }
    ngOnInit() {
    }
    ngOnDestroy() {
        this.visibleChange.complete();
        this.destroy$.next();
        this.destroy$.complete();
    }
    show() {
        if (this.visible) {
            return;
        }
        if (!this.isEmpty()) {
            this.visible = true;
            this.visibleChange.next(true);
            this.cdr.detectChanges();
        }
        // for ltr for overlay to display tooltip in correct placement in rtl direction.
        // if (this.origin && this.overlay && this.overlay.overlayRef && this.overlay.overlayRef.getDirection() === 'rtl') {
        //   this.overlay.overlayRef.setDirection('ltr');
        // }
    }
    hide() {
        if (!this.visible) {
            return;
        }
        this.visible = false;
        this.visibleChange.next(false);
        this.cdr.detectChanges();
    }
    updateByDirective() {
        this.updateStyles();
        this.cdr.detectChanges();
        Promise.resolve().then(() => {
            this.updatePosition();
            this.updateVisibilityByTitle();
        });
    }
    /**
     * Force the component to update its position.
     */
    updatePosition() {
        if (this.origin && this.overlay && this.overlay.overlayRef) {
            this.overlay.overlayRef.updatePosition();
        }
    }
    onPositionChange(position) {
        this.preferredPlacement = getPlacementName(position);
        this.updateStyles();
        // We have to trigger immediate change detection or the element would blink.
        this.cdr.detectChanges();
    }
    updateStyles() {
        this._classMap = {
            [this.overlayClassName]: true,
            [`${this._prefix}-placement-${this.preferredPlacement}`]: true
        };
    }
    setOverlayOrigin(origin) {
        this.origin = origin;
        this.cdr.markForCheck();
    }
    onClickOutside(event) {
        if (!this.origin.nativeElement.contains(event.target) && this.trigger !== null) {
            this.hide();
        }
    }
    /**
     * Hide the component while the content is empty.
     */
    updateVisibilityByTitle() {
        if (this.isEmpty()) {
            this.hide();
        }
    }
}
TDSTooltipBaseComponent.ɵfac = function TDSTooltipBaseComponent_Factory(t) { return new (t || TDSTooltipBaseComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
TDSTooltipBaseComponent.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSTooltipBaseComponent, viewQuery: function TDSTooltipBaseComponent_Query(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵviewQuery(_c0, 5);
        }
        if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overlay = _t.first);
        }
    } });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTooltipBaseComponent, [{
            type: Directive
        }], function () { return [{ type: i0.ChangeDetectorRef }]; }, { overlay: [{
                type: ViewChild,
                args: ['overlay', { static: false }]
            }] });
})();
function isTooltipEmpty(value) {
    return value instanceof TemplateRef ? false : value === '' || !TDSHelperObject.hasValue(value);
}

function TDSToolTipComponent_ng_template_0_ng_container_5_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtext(1);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r2 = i0.ɵɵnextContext(2);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx_r2.title);
    }
}
function TDSToolTipComponent_ng_template_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 2)(1, "div", 3)(2, "div", 4);
        i0.ɵɵelement(3, "span", 5);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(4, "div", 6);
        i0.ɵɵtemplate(5, TDSToolTipComponent_ng_template_0_ng_container_5_Template, 2, 1, "ng-container", 7);
        i0.ɵɵelementEnd()()();
    }
    if (rf & 2) {
        const ctx_r1 = i0.ɵɵnextContext();
        i0.ɵɵproperty("ngClass", ctx_r1._classMap)("ngStyle", ctx_r1.overlayStyle)("@zoomBigMotion", "active");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngStyle", ctx_r1._contentStyleArrow);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", ctx_r1._tooltipArrowCss)("ngStyle", ctx_r1._contentStyleArrowContent);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", ctx_r1._tooltipCss);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r1.title);
    }
}
class TDSTooltipDirective extends TDSTooltipBaseDirective {
    constructor(elementRef, hostView, resolver, renderer) {
        super(elementRef, hostView, resolver, renderer);
        this.trigger = 'hover';
        this.placement = 'top';
        // tslint:disable-next-line:no-output-rename
        this.visibleChange = new EventEmitter();
        this.componentRef = this.hostView.createComponent(TDSToolTipComponent);
    }
    getProxyPropertyMap() {
        return {
            tooltipCss: ['tooltipContentCss', () => this.tooltipContentCss],
            tooltipArrowCss: ['tooltipArrowCss', () => this.tooltipArrowCss],
            tooltipColor: ['color', () => this.tooltipColor]
        };
    }
}
TDSTooltipDirective.ɵfac = function TDSTooltipDirective_Factory(t) { return new (t || TDSTooltipDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.Renderer2)); };
TDSTooltipDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSTooltipDirective, selectors: [["", "tds-tooltip", ""]], hostVars: 2, hostBindings: function TDSTooltipDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
            i0.ɵɵclassProp("tds-tooltip-open", ctx.visible);
        }
    }, inputs: { title: ["tooltipTitle", "title"], directiveTitle: ["tds-tooltip", "directiveTitle"], trigger: ["tooltipTrigger", "trigger"], placement: ["tooltipPlacement", "placement"], origin: ["tooltipOrigin", "origin"], visible: ["tooltipVisible", "visible"], mouseEnterDelay: ["tooltipMouseEnterDelay", "mouseEnterDelay"], mouseLeaveDelay: ["tooltipMouseLeaveDelay", "mouseLeaveDelay"], overlayClassName: ["tooltipOverlayClassName", "overlayClassName"], overlayStyle: ["tooltipOverlayStyle", "overlayStyle"], tooltipColor: "tooltipColor", tooltipContentCss: "tooltipContentCss", tooltipArrowCss: "tooltipArrowCss" }, outputs: { visibleChange: "tooltipVisibleChange" }, exportAs: ["tdsTooltip"], features: [i0.ɵɵInheritDefinitionFeature] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTooltipDirective, [{
            type: Directive,
            args: [{
                    selector: '[tds-tooltip]',
                    exportAs: 'tdsTooltip',
                    host: {
                        '[class.tds-tooltip-open]': 'visible'
                    }
                }]
        }], function () { return [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }, { type: i0.Renderer2 }]; }, { title: [{
                type: Input,
                args: ['tooltipTitle']
            }], directiveTitle: [{
                type: Input,
                args: ['tds-tooltip']
            }], trigger: [{
                type: Input,
                args: ['tooltipTrigger']
            }], placement: [{
                type: Input,
                args: ['tooltipPlacement']
            }], origin: [{
                type: Input,
                args: ['tooltipOrigin']
            }], visible: [{
                type: Input,
                args: ['tooltipVisible']
            }], mouseEnterDelay: [{
                type: Input,
                args: ['tooltipMouseEnterDelay']
            }], mouseLeaveDelay: [{
                type: Input,
                args: ['tooltipMouseLeaveDelay']
            }], overlayClassName: [{
                type: Input,
                args: ['tooltipOverlayClassName']
            }], overlayStyle: [{
                type: Input,
                args: ['tooltipOverlayStyle']
            }], tooltipColor: [{
                type: Input
            }], tooltipContentCss: [{
                type: Input
            }], tooltipArrowCss: [{
                type: Input
            }], visibleChange: [{
                type: Output,
                args: ['tooltipVisibleChange']
            }] });
})();
class TDSToolTipComponent extends TDSTooltipBaseComponent {
    constructor(cdr, directionality) {
        super(cdr);
        this.title = null;
        this.tooltipContentCss = null;
        this.tooltipArrowCss = null;
        this._tooltipCss = {};
        this._tooltipArrowCss = {};
        this._contentStyleMap = {};
        this._contentStyleArrowContent = {};
        this._contentStyleArrow = {};
    }
    isEmpty() {
        return isTooltipEmpty(this.title);
    }
    updateStyles() {
        const isColorPreset = this.color;
        this._classMap = {
            [this.overlayClassName]: true,
            [`${this._prefix}-placement-${this.preferredPlacement}`]: true,
        };
        if (TDSHelperObject.hasValue(this.color)) {
            this.getCssByColor();
        }
        else {
            //lấy mặc định or custom
            this._tooltipCss = this.tooltipContentCss || {
                ['bg-black bg-opacity-80 dark:bg-d-neutral-3-500 dark:bg-opacity-100 rounded p-2']: true,
            };
            this._tooltipArrowCss = this.tooltipArrowCss || {
                ' border-black  border-opacity-80 dark:border-d-neutral-3-500 dark:border-opacity-100 border-4': true
            };
        }
        this.p_StyleArrow();
    }
    p_StyleArrow() {
        let borderTransparent = '4px solid transparent';
        // let borderColor = '4px solid';
        if (this.preferredPlacement.indexOf("top") > -1) {
            this._contentStyleArrowContent = {
                width: '0',
                height: '0',
                borderLeft: borderTransparent,
                borderRight: borderTransparent,
                borderBottom: 0
                // borderTop: borderColor,
            };
        }
        if (this.preferredPlacement.indexOf("bottom") > -1) {
            this._contentStyleArrowContent = {
                width: '0',
                height: '0',
                borderLeft: borderTransparent,
                borderRight: borderTransparent,
                borderTop: 0
                // borderBottom: borderColor,        
            };
        }
        if (this.preferredPlacement.indexOf("left") > -1) {
            this._contentStyleArrowContent = {
                width: '0',
                height: '0',
                borderTop: borderTransparent,
                // borderLeft : borderColor,
                borderBottom: borderTransparent,
                borderRight: 0
            };
        }
        if (this.preferredPlacement.indexOf("right") > -1) {
            this._contentStyleArrowContent = {
                width: '0',
                height: '0',
                borderTop: borderTransparent,
                // borderRight : borderColor,
                borderBottom: borderTransparent,
                borderLeft: 0
            };
        }
        switch (this.preferredPlacement) {
            //#region top
            case "top":
                this._contentStyleArrow = {
                    bottom: '0',
                    left: '50%',
                    transform: 'translateX(-50%)',
                };
                break;
            case "topLeft":
                this._contentStyleArrow = {
                    bottom: '0',
                    left: '10px',
                };
                break;
            case "topRight":
                this._contentStyleArrow = {
                    bottom: '0',
                    right: '10px',
                };
                break;
            //#endregion
            //#region bottom
            case "bottom":
                this._contentStyleArrow = {
                    top: '0',
                    left: '50%',
                    transform: 'translateX(-50%)',
                };
                break;
            case "bottomLeft":
                this._contentStyleArrow = {
                    top: '0',
                    left: '10px',
                };
                break;
            case "bottomRight":
                this._contentStyleArrow = {
                    top: '0',
                    right: '10px',
                };
                break;
            //#endregion
            //#region left
            case "left":
                this._contentStyleArrow = {
                    right: '0px',
                    top: '50%',
                    transform: 'translateY(-50%)',
                };
                break;
            case "leftTop":
                this._contentStyleArrow = {
                    right: '0px',
                    top: '10px'
                };
                break;
            case "leftBottom":
                this._contentStyleArrow = {
                    right: '0px',
                    bottom: '10px'
                };
                break;
            //#endregion
            //#region right
            case "right":
                this._contentStyleArrow = {
                    left: '0px',
                    top: '50%',
                    transform: 'translateY(-50%)',
                };
                break;
            case "rightTop":
                this._contentStyleArrow = {
                    left: '0px',
                    top: '10px'
                };
                break;
            case "rightBottom":
                this._contentStyleArrow = {
                    left: '0px',
                    bottom: '10px'
                };
                break;
            ////#endregion
            default:
                this._contentStyleArrow = {
                    bottom: '0',
                    left: '50%',
                    transform: 'translateX(-50%)',
                };
                break;
        }
    }
    getCssByColor() {
        let contentCss = '';
        let arrowContent = '';
        switch (this.color) {
            case 'info':
                contentCss = "bg-info-400 dark:bg-d-info-400 p-2 rounded";
                arrowContent = 'border-4 border-info-400 dark:border-d-info-400';
                break;
            case 'success':
                contentCss = "bg-success-400 dark:bg-d-success-400 p-2 rounded";
                arrowContent = 'border-4 border-success-400 dark:border-d-success-400';
                break;
            case 'error':
                contentCss = "bg-error-400 dark:bg-d-error-400 p-2 rounded";
                arrowContent = 'border-4 border-error-400 dark:border-d-error-400';
                break;
            case 'warning':
                contentCss = "bg-warning-400 dark:bg-d-warning-400 p-2 rounded";
                arrowContent = 'border-4 border-warning-400 dark:border-d-warning-400';
                break;
        }
        this._tooltipCss = {
            [contentCss]: true
        };
        this._tooltipArrowCss = {
            [arrowContent]: true
        };
    }
}
TDSToolTipComponent.ɵfac = function TDSToolTipComponent_Factory(t) { return new (t || TDSToolTipComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.Directionality, 8)); };
TDSToolTipComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSToolTipComponent, selectors: [["tds-tooltip"]], exportAs: ["TDSTooltipComponent"], features: [i0.ɵɵInheritDefinitionFeature], decls: 2, vars: 4, consts: [["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "cdkConnectedOverlayPush", "overlayOutsideClick", "detach", "positionChange"], ["overlay", "cdkConnectedOverlay"], [1, "tds-tooltip", "p-1.5", "relative", "text-white", "text-body-2", "font-regular", 3, "ngClass", "ngStyle"], [1, "tds-tooltip-content", "p-1", "relative"], [1, "tds-tooltip-arrow", "absolute", "block", "bg-transparent", "pointer-events-none", 3, "ngStyle"], [1, "tds-tooltip-arrow-content", "block", 3, "ngClass", "ngStyle"], [1, "tds-tooltip-inner", 3, "ngClass"], [4, "tdsStringTemplateOutlet"]], template: function TDSToolTipComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵtemplate(0, TDSToolTipComponent_ng_template_0_Template, 6, 8, "ng-template", 0, 1, i0.ɵɵtemplateRefExtractor);
            i0.ɵɵlistener("overlayOutsideClick", function TDSToolTipComponent_Template_ng_template_overlayOutsideClick_0_listener($event) { return ctx.onClickOutside($event); })("detach", function TDSToolTipComponent_Template_ng_template_detach_0_listener() { return ctx.hide(); })("positionChange", function TDSToolTipComponent_Template_ng_template_positionChange_0_listener($event) { return ctx.onPositionChange($event); });
        }
        if (rf & 2) {
            i0.ɵɵproperty("cdkConnectedOverlayOrigin", ctx.origin)("cdkConnectedOverlayOpen", ctx._visible)("cdkConnectedOverlayPositions", ctx._positions)("cdkConnectedOverlayPush", true);
        }
    }, directives: [i2.CdkConnectedOverlay, i3.NgClass, i3.NgStyle, i4.TDSStringTemplateOutletDirective], encapsulation: 2, data: { animation: [zoomBigMotion] }, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSToolTipComponent, [{
            type: Component,
            args: [{
                    selector: 'tds-tooltip',
                    exportAs: 'TDSTooltipComponent',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    animations: [zoomBigMotion],
                    template: `
    <ng-template
      #overlay="cdkConnectedOverlay"
      cdkConnectedOverlay
      [cdkConnectedOverlayOrigin]="origin"
      [cdkConnectedOverlayOpen]="_visible"
      [cdkConnectedOverlayPositions]="_positions"
      [cdkConnectedOverlayPush]="true"
      (overlayOutsideClick)="onClickOutside($event)"
      (detach)="hide()"
      (positionChange)="onPositionChange($event)"
    >
      <div
        class="tds-tooltip  p-1.5 relative text-white text-body-2 font-regular"        
        [ngClass]="_classMap"
        [ngStyle]="overlayStyle"     
        [@zoomBigMotion]="'active'"
      >
        <div class="tds-tooltip-content p-1 relative">
          <div class="tds-tooltip-arrow absolute block bg-transparent pointer-events-none"
          [ngStyle]="_contentStyleArrow" >
            <span class="tds-tooltip-arrow-content block" [ngClass]='_tooltipArrowCss' [ngStyle]="_contentStyleArrowContent"></span>
          </div>
          <div class="tds-tooltip-inner" [ngClass]="_tooltipCss">
            <ng-container *tdsStringTemplateOutlet="title">{{ title }}</ng-container>
          </div>
        </div>
      </div>
    </ng-template>
  `,
                    preserveWhitespaces: false
                }]
        }], function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i1.Directionality, decorators: [{
                        type: Optional
                    }] }];
    }, null);
})();

class TDSToolTipModule {
}
TDSToolTipModule.ɵfac = function TDSToolTipModule_Factory(t) { return new (t || TDSToolTipModule)(); };
TDSToolTipModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSToolTipModule });
TDSToolTipModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[BidiModule, CommonModule, OverlayModule, TDSOutletModule, TDSOverlayModule]] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSToolTipModule, [{
            type: NgModule,
            args: [{
                    declarations: [TDSToolTipComponent, TDSTooltipDirective],
                    exports: [TDSToolTipComponent, TDSTooltipDirective],
                    imports: [BidiModule, CommonModule, OverlayModule, TDSOutletModule, TDSOverlayModule]
                }]
        }], null, null);
})();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSToolTipModule, { declarations: [TDSToolTipComponent, TDSTooltipDirective], imports: [BidiModule, CommonModule, OverlayModule, TDSOutletModule, TDSOverlayModule], exports: [TDSToolTipComponent, TDSTooltipDirective] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSToolTipComponent, TDSToolTipModule, TDSTooltipBaseComponent, TDSTooltipBaseDirective, TDSTooltipDirective, isTooltipEmpty };
//# sourceMappingURL=tds-ui-tooltip.mjs.map
