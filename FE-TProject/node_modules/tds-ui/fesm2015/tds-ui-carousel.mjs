import * as i4 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i2 from '@angular/cdk/platform';
import { PlatformModule } from '@angular/cdk/platform';
import * as i5 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Directive, InjectionToken, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, Inject, ContentChildren, ViewChild, Input, Output, NgModule } from '@angular/core';
import { __decorate } from 'tslib';
import { LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { InputBoolean, InputNumber } from 'tds-ui/shared/utility';
import * as i1 from 'tds-ui/core/config';
import { WithConfig } from 'tds-ui/core/config';
import * as i3 from 'tds-ui/core/services';

class TDSCarouselContentDirective {
    constructor(elementRef, renderer) {
        this.renderer = renderer;
        this._active = false;
        this.el = elementRef.nativeElement;
        this.renderer.addClass(elementRef.nativeElement, 'slick-slide');
    }
    set isActive(value) {
        this._active = value;
        if (this.isActive) {
            this.renderer.addClass(this.el, 'slick-active');
        }
        else {
            this.renderer.removeClass(this.el, 'slick-active');
        }
    }
    get isActive() {
        return this._active;
    }
}
TDSCarouselContentDirective.ɵfac = function TDSCarouselContentDirective_Factory(t) { return new (t || TDSCarouselContentDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2)); };
TDSCarouselContentDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSCarouselContentDirective, selectors: [["", "tds-carousel-content", ""]], exportAs: ["tdsCarouselContent"] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCarouselContentDirective, [{
            type: Directive,
            args: [{
                    selector: '[tds-carousel-content]',
                    exportAs: 'tdsCarouselContent'
                }]
        }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, null);
})();

class TDSCarouselBaseStrategy {
    constructor(carouselComponent, cdr, renderer, platform, options) {
        this.cdr = cdr;
        this.renderer = renderer;
        this.platform = platform;
        this.options = options;
        this.carouselComponent = carouselComponent;
    }
    get maxIndex() {
        return this.length - 1;
    }
    get firstEl() {
        return this.contents[0].el;
    }
    get lastEl() {
        return this.contents[this.maxIndex].el;
    }
    /**
     * Initialize dragging sequences.
     * @param contents
     */
    withCarouselContents(contents) {
        const carousel = this.carouselComponent;
        this.slickListEl = carousel.slickListEl;
        this.slickTrackEl = carousel.slickTrackEl;
        this.contents = (contents === null || contents === void 0 ? void 0 : contents.toArray()) || [];
        this.length = this.contents.length;
        if (this.platform.isBrowser) {
            const rect = carousel.el.getBoundingClientRect();
            this.unitWidth = rect.width;
            this.unitHeight = rect.height;
        }
        else {
            // Since we cannot call getBoundingClientRect in server, we just hide all items except for the first one.
            contents === null || contents === void 0 ? void 0 : contents.forEach((content, index) => {
                if (index === 0) {
                    this.renderer.setStyle(content.el, 'width', '100%');
                }
                else {
                    this.renderer.setStyle(content.el, 'display', 'none');
                }
            });
        }
    }
    /**
     * When user drag the carousel component.
     * @optional
     */
    dragging(_vector) { }
    /**
     * Destroy a scroll strategy.
     */
    dispose() { }
    getFromToInBoundary(f, t) {
        const length = this.maxIndex + 1;
        return { from: (f + length) % length, to: (t + length) % length };
    }
}

class TDSCarouselOpacityStrategy extends TDSCarouselBaseStrategy {
    withCarouselContents(contents) {
        super.withCarouselContents(contents);
        if (this.contents) {
            this.slickTrackEl.style.width = `${this.length * this.unitWidth}px`;
            this.contents.forEach((content, i) => {
                this.renderer.setStyle(content.el, 'opacity', this.carouselComponent.activeIndex === i ? '1' : '0');
                this.renderer.setStyle(content.el, 'position', 'relative');
                this.renderer.setStyle(content.el, 'width', `${this.unitWidth}px`);
                this.renderer.setStyle(content.el, 'left', `${-this.unitWidth * i}px`);
                this.renderer.setStyle(content.el, 'transition', ['opacity 500ms ease 0s', 'visibility 500ms ease 0s']);
            });
        }
    }
    switch(_f, _t) {
        const { to: t } = this.getFromToInBoundary(_f, _t);
        const complete$ = new Subject();
        this.contents.forEach((content, i) => {
            this.renderer.setStyle(content.el, 'opacity', t === i ? '1' : '0');
        });
        setTimeout(() => {
            complete$.next();
            complete$.complete();
        }, this.carouselComponent.tdsTransitionSpeed);
        return complete$;
    }
    dispose() {
        this.contents.forEach((content) => {
            this.renderer.setStyle(content.el, 'transition', null);
        });
        super.dispose();
    }
}

class TDSCarouselTransformStrategy extends TDSCarouselBaseStrategy {
    constructor(carouselComponent, cdr, renderer, platform, options) {
        super(carouselComponent, cdr, renderer, platform, options);
        this.isDragging = false;
        this.isTransitioning = false;
    }
    get vertical() {
        return this.carouselComponent.vertical;
    }
    dispose() {
        super.dispose();
        this.renderer.setStyle(this.slickTrackEl, 'transform', null);
    }
    withCarouselContents(contents) {
        super.withCarouselContents(contents);
        const carousel = this.carouselComponent;
        const activeIndex = carousel.activeIndex;
        // We only do when we are in browser.
        if (this.platform.isBrowser && this.contents.length) {
            this.renderer.setStyle(this.slickListEl, 'height', `${this.unitHeight}px`);
            if (this.vertical) {
                this.renderer.setStyle(this.slickTrackEl, 'width', `${this.unitWidth}px`);
                this.renderer.setStyle(this.slickTrackEl, 'height', `${this.length * this.unitHeight}px`);
                this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-activeIndex * this.unitHeight}px, 0)`);
            }
            else {
                this.renderer.setStyle(this.slickTrackEl, 'height', `${this.unitHeight}px`);
                this.renderer.setStyle(this.slickTrackEl, 'width', `${this.length * this.unitWidth}px`);
                this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-activeIndex * this.unitWidth}px, 0, 0)`);
            }
            this.contents.forEach((content) => {
                this.renderer.setStyle(content.el, 'position', 'relative');
                this.renderer.setStyle(content.el, 'width', `${this.unitWidth}px`);
                this.renderer.setStyle(content.el, 'height', `${this.unitHeight}px`);
            });
        }
    }
    switch(_f, _t) {
        const { to: t } = this.getFromToInBoundary(_f, _t);
        const complete$ = new Subject();
        this.renderer.setStyle(this.slickTrackEl, 'transition', `transform ${this.carouselComponent.tdsTransitionSpeed}ms ease`);
        if (this.vertical) {
            this.verticalTransform(_f, _t);
        }
        else {
            this.horizontalTransform(_f, _t);
        }
        this.isTransitioning = true;
        this.isDragging = false;
        setTimeout(() => {
            this.renderer.setStyle(this.slickTrackEl, 'transition', null);
            this.contents.forEach((content) => {
                this.renderer.setStyle(content.el, this.vertical ? 'top' : 'left', null);
            });
            if (this.vertical) {
                this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-t * this.unitHeight}px, 0)`);
            }
            else {
                this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-t * this.unitWidth}px, 0, 0)`);
            }
            this.isTransitioning = false;
            complete$.next();
            complete$.complete();
        }, this.carouselComponent.tdsTransitionSpeed);
        return complete$.asObservable();
    }
    dragging(_vector) {
        if (this.isTransitioning) {
            return;
        }
        const activeIndex = this.carouselComponent.activeIndex;
        if (this.carouselComponent.vertical) {
            if (!this.isDragging && this.length > 2) {
                if (activeIndex === this.maxIndex) {
                    this.prepareVerticalContext(true);
                }
                else if (activeIndex === 0) {
                    this.prepareVerticalContext(false);
                }
            }
            this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-activeIndex * this.unitHeight + _vector.x}px, 0)`);
        }
        else {
            if (!this.isDragging && this.length > 2) {
                if (activeIndex === this.maxIndex) {
                    this.prepareHorizontalContext(true);
                }
                else if (activeIndex === 0) {
                    this.prepareHorizontalContext(false);
                }
            }
            this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-activeIndex * this.unitWidth + _vector.x}px, 0, 0)`);
        }
        this.isDragging = true;
    }
    verticalTransform(_f, _t) {
        const { from: f, to: t } = this.getFromToInBoundary(_f, _t);
        const needToAdjust = this.length > 2 && _t !== t;
        if (needToAdjust) {
            this.prepareVerticalContext(t < f);
            this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-_t * this.unitHeight}px, 0)`);
        }
        else {
            this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(0, ${-t * this.unitHeight}px, 0`);
        }
    }
    horizontalTransform(_f, _t) {
        const { from: f, to: t } = this.getFromToInBoundary(_f, _t);
        const needToAdjust = this.length > 2 && _t !== t;
        if (needToAdjust) {
            this.prepareHorizontalContext(t < f);
            this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-_t * this.unitWidth}px, 0, 0)`);
        }
        else {
            this.renderer.setStyle(this.slickTrackEl, 'transform', `translate3d(${-t * this.unitWidth}px, 0, 0`);
        }
    }
    prepareVerticalContext(lastToFirst) {
        if (lastToFirst) {
            this.renderer.setStyle(this.firstEl, 'top', `${this.length * this.unitHeight}px`);
            this.renderer.setStyle(this.lastEl, 'top', null);
        }
        else {
            this.renderer.setStyle(this.firstEl, 'top', null);
            this.renderer.setStyle(this.lastEl, 'top', `${-this.unitHeight * this.length}px`);
        }
    }
    prepareHorizontalContext(lastToFirst) {
        if (lastToFirst) {
            this.renderer.setStyle(this.firstEl, 'left', `${this.length * this.unitWidth}px`);
            this.renderer.setStyle(this.lastEl, 'left', null);
        }
        else {
            this.renderer.setStyle(this.firstEl, 'left', null);
            this.renderer.setStyle(this.lastEl, 'left', `${-this.unitWidth * this.length}px`);
        }
    }
}

const TDS_CAROUSEL_CUSTOM_STRATEGIES = new InjectionToken('tds-carousel-custom-strategies');

const _c0 = ["slickList"];
const _c1 = ["slickTrack"];
function TDSCarouselComponent_ul_6_li_1_ng_template_1_Template(rf, ctx) { }
const _c2 = function (a0) { return { $implicit: a0 }; };
function TDSCarouselComponent_ul_6_li_1_Template(rf, ctx) {
    if (rf & 1) {
        const _r10 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "li", 9);
        i0.ɵɵlistener("click", function TDSCarouselComponent_ul_6_li_1_Template_li_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r10); const i_r7 = restoredCtx.index; const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.onLiClick(i_r7); });
        i0.ɵɵtemplate(1, TDSCarouselComponent_ul_6_li_1_ng_template_1_Template, 0, 0, "ng-template", 10);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const content_r6 = ctx.$implicit;
        const i_r7 = ctx.index;
        const ctx_r5 = i0.ɵɵnextContext(2);
        const _r3 = i0.ɵɵreference(8);
        i0.ɵɵclassProp("slick-active", content_r6.isActive);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngTemplateOutlet", ctx_r5.tdsDotRender || _r3)("ngTemplateOutletContext", i0.ɵɵpureFunction1(4, _c2, i_r7));
    }
}
function TDSCarouselComponent_ul_6_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "ul", 7);
        i0.ɵɵtemplate(1, TDSCarouselComponent_ul_6_li_1_Template, 2, 6, "li", 8);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const ctx_r2 = i0.ɵɵnextContext();
        i0.ɵɵclassProp("slick-dots-top", ctx_r2.tdsDotPosition === "top")("slick-dots-bottom", ctx_r2.tdsDotPosition === "bottom")("slick-dots-left", ctx_r2.tdsDotPosition === "left")("slick-dots-right", ctx_r2.tdsDotPosition === "right");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx_r2.carouselContents);
    }
}
function TDSCarouselComponent_ng_template_7_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "button");
        i0.ɵɵtext(1);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const index_r11 = ctx.$implicit;
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(index_r11 + 1);
    }
}
const _c3 = ["*"];
const TDS_CONFIG_MODULE_NAME = 'carousel';
class TDSCarouselComponent {
    constructor(elementRef, tdsConfigService, renderer, cdr, platform, resizeService, tdsDragService, directionality, customStrategies) {
        this.tdsConfigService = tdsConfigService;
        this.renderer = renderer;
        this.cdr = cdr;
        this.platform = platform;
        this.resizeService = resizeService;
        this.tdsDragService = tdsDragService;
        this.directionality = directionality;
        this.customStrategies = customStrategies;
        this._tdsModuleName = TDS_CONFIG_MODULE_NAME;
        this.tdsEffect = 'scrollx';
        this.tdsEnableSwipe = true;
        this.tdsDots = true;
        this.tdsAutoPlay = false;
        this.tdsAutoPlaySpeed = 3000;
        this.tdsTransitionSpeed = 500;
        /**
         * this property is passed directly to an TDSCarouselBaseStrategy
         */
        this.tdsStrategyOptions = undefined;
        this._dotPosition = 'bottom';
        this.tdsBeforeChange = new EventEmitter();
        this.tdsAfterChange = new EventEmitter();
        this.activeIndex = 0;
        this.vertical = false;
        this.transitionInProgress = null;
        this.dir = 'ltr';
        this.destroy$ = new Subject();
        this.gestureRect = null;
        this.pointerDelta = null;
        this.isTransiting = false;
        this.isDragging = false;
        this.onLiClick = (index) => {
            if (this.dir === 'rtl') {
                this.goTo(this.carouselContents.length - 1 - index);
            }
            else {
                this.goTo(index);
            }
        };
        /**
         * Drag carousel.
         */
        this.pointerDown = (event) => {
            if (!this.isDragging && !this.isTransiting && this.tdsEnableSwipe) {
                this.clearScheduledTransition();
                this.gestureRect = this.slickListEl.getBoundingClientRect();
                this.tdsDragService.requestDraggingSequence(event).subscribe(delta => {
                    var _a;
                    this.pointerDelta = delta;
                    this.isDragging = true;
                    (_a = this.strategy) === null || _a === void 0 ? void 0 : _a.dragging(this.pointerDelta);
                }, () => { }, () => {
                    if (this.tdsEnableSwipe && this.isDragging) {
                        const xDelta = this.pointerDelta ? this.pointerDelta.x : 0;
                        // Switch to another slide if delta is bigger than third of the width.
                        if (Math.abs(xDelta) > this.gestureRect.width / 3) {
                            this.goTo(xDelta > 0 ? this.activeIndex - 1 : this.activeIndex + 1);
                        }
                        else {
                            this.goTo(this.activeIndex);
                        }
                        this.gestureRect = null;
                        this.pointerDelta = null;
                    }
                    this.isDragging = false;
                });
            }
        };
        this.tdsDotPosition = 'bottom';
        this.renderer.addClass(elementRef.nativeElement, 'tds-carousel');
        this.el = elementRef.nativeElement;
    }
    set tdsDotPosition(value) {
        this._dotPosition = value;
        if (value === 'left' || value === 'right') {
            this.vertical = true;
        }
        else {
            this.vertical = false;
        }
    }
    get tdsDotPosition() {
        return this._dotPosition;
    }
    ngOnInit() {
        var _a;
        this.dir = this.directionality.value;
        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.markContentActive(this.activeIndex);
            this.cdr.detectChanges();
        });
    }
    ngAfterContentInit() {
        this.markContentActive(0);
    }
    ngAfterViewInit() {
        this.slickListEl = this.slickList.nativeElement;
        this.slickTrackEl = this.slickTrack.nativeElement;
        this.carouselContents.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.markContentActive(0);
            this.layout();
        });
        this.resizeService
            .subscribe()
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => {
            this.layout();
        });
        this.switchStrategy();
        this.markContentActive(0);
        this.layout();
        // If embedded in an entry component, it may do initial render at an inappropriate time.
        // ngZone.onStable won't do this trick
        // TODO: need to change this.
        Promise.resolve().then(() => {
            this.layout();
        });
    }
    ngOnChanges(changes) {
        const { tdsEffect, tdsDotPosition } = changes;
        if (tdsEffect && !tdsEffect.isFirstChange()) {
            this.switchStrategy();
            this.markContentActive(0);
            this.layout();
        }
        if (tdsDotPosition && !tdsDotPosition.isFirstChange()) {
            this.switchStrategy();
            this.markContentActive(0);
            this.layout();
        }
        if (!this.tdsAutoPlay || !this.tdsAutoPlaySpeed) {
            this.clearScheduledTransition();
        }
        else {
            this.scheduleNextTransition();
        }
    }
    ngOnDestroy() {
        this.clearScheduledTransition();
        if (this.strategy) {
            this.strategy.dispose();
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    onKeyDown(e) {
        if (e.keyCode === LEFT_ARROW) {
            e.preventDefault();
            this.pre();
        }
        else if (e.keyCode === RIGHT_ARROW) {
            this.next();
            e.preventDefault();
        }
    }
    next() {
        this.goTo(this.activeIndex + 1);
    }
    pre() {
        this.goTo(this.activeIndex - 1);
    }
    goTo(index) {
        if (this.carouselContents && this.carouselContents.length && !this.isTransiting) {
            const length = this.carouselContents.length;
            const from = this.activeIndex;
            const to = (index + length) % length;
            this.isTransiting = true;
            this.tdsBeforeChange.emit({ from, to });
            this.strategy.switch(this.activeIndex, index).subscribe(() => {
                this.scheduleNextTransition();
                this.tdsAfterChange.emit(index);
                this.isTransiting = false;
            });
            this.markContentActive(to);
            this.cdr.markForCheck();
        }
    }
    switchStrategy() {
        if (this.strategy) {
            this.strategy.dispose();
        }
        // Load custom strategies first.
        const customStrategy = this.customStrategies ? this.customStrategies.find(s => s.name === this.tdsEffect) : null;
        if (customStrategy) {
            this.strategy = new customStrategy.strategy(this, this.cdr, this.renderer, this.platform);
            return;
        }
        this.strategy =
            this.tdsEffect === 'scrollx'
                ? new TDSCarouselTransformStrategy(this, this.cdr, this.renderer, this.platform)
                : new TDSCarouselOpacityStrategy(this, this.cdr, this.renderer, this.platform);
    }
    scheduleNextTransition() {
        this.clearScheduledTransition();
        if (this.tdsAutoPlay && this.tdsAutoPlaySpeed > 0 && this.platform.isBrowser) {
            this.transitionInProgress = setTimeout(() => {
                this.goTo(this.activeIndex + 1);
            }, this.tdsAutoPlaySpeed);
        }
    }
    clearScheduledTransition() {
        if (this.transitionInProgress) {
            clearTimeout(this.transitionInProgress);
            this.transitionInProgress = null;
        }
    }
    markContentActive(index) {
        this.activeIndex = index;
        if (this.carouselContents) {
            this.carouselContents.forEach((slide, i) => {
                if (this.dir === 'rtl') {
                    slide.isActive = index === this.carouselContents.length - 1 - i;
                }
                else {
                    slide.isActive = index === i;
                }
            });
        }
        this.cdr.markForCheck();
    }
    layout() {
        if (this.strategy) {
            this.strategy.withCarouselContents(this.carouselContents);
        }
    }
}
TDSCarouselComponent.ɵfac = function TDSCarouselComponent_Factory(t) { return new (t || TDSCarouselComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.TDSConfigService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.Platform), i0.ɵɵdirectiveInject(i3.TDSResizeService), i0.ɵɵdirectiveInject(i3.TDSDragService), i0.ɵɵdirectiveInject(i4.Directionality, 8), i0.ɵɵdirectiveInject(TDS_CAROUSEL_CUSTOM_STRATEGIES, 8)); };
TDSCarouselComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCarouselComponent, selectors: [["tds-carousel"]], contentQueries: function TDSCarouselComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
            i0.ɵɵcontentQuery(dirIndex, TDSCarouselContentDirective, 4);
        }
        if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.carouselContents = _t);
        }
    }, viewQuery: function TDSCarouselComponent_Query(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵviewQuery(_c0, 5);
            i0.ɵɵviewQuery(_c1, 5);
        }
        if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.slickList = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.slickTrack = _t.first);
        }
    }, hostAttrs: [1, "block", "relative", "overflow-hidden", "w-full", "h-full"], hostVars: 4, hostBindings: function TDSCarouselComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
            i0.ɵɵclassProp("tds-carousel-vertical", ctx.vertical)("tds-carousel-rtl", ctx.dir === "rtl");
        }
    }, inputs: { tdsDotRender: "tdsDotRender", tdsEffect: "tdsEffect", tdsEnableSwipe: "tdsEnableSwipe", tdsDots: "tdsDots", tdsAutoPlay: "tdsAutoPlay", tdsAutoPlaySpeed: "tdsAutoPlaySpeed", tdsTransitionSpeed: "tdsTransitionSpeed", tdsStrategyOptions: "tdsStrategyOptions", tdsDotPosition: "tdsDotPosition" }, outputs: { tdsBeforeChange: "tdsBeforeChange", tdsAfterChange: "tdsAfterChange" }, exportAs: ["tdsCarousel"], features: [i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c3, decls: 9, vars: 3, consts: [[1, "slick-initialized", "slick-slider"], ["tabindex", "-1", 1, "slick-list", 3, "keydown", "mousedown", "touchstart"], ["slickList", ""], [1, "slick-track"], ["slickTrack", ""], ["class", "slick-dots", 3, "slick-dots-top", "slick-dots-bottom", "slick-dots-left", "slick-dots-right", 4, "ngIf"], ["renderDotTemplate", ""], [1, "slick-dots"], [3, "slick-active", "click", 4, "ngFor", "ngForOf"], [3, "click"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function TDSCarouselComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵprojectionDef();
            i0.ɵɵelementStart(0, "div", 0)(1, "div", 1, 2);
            i0.ɵɵlistener("keydown", function TDSCarouselComponent_Template_div_keydown_1_listener($event) { return ctx.onKeyDown($event); })("mousedown", function TDSCarouselComponent_Template_div_mousedown_1_listener($event) { return ctx.pointerDown($event); })("touchstart", function TDSCarouselComponent_Template_div_touchstart_1_listener($event) { return ctx.pointerDown($event); });
            i0.ɵɵelementStart(3, "div", 3, 4);
            i0.ɵɵprojection(5);
            i0.ɵɵelementEnd()();
            i0.ɵɵtemplate(6, TDSCarouselComponent_ul_6_Template, 2, 9, "ul", 5);
            i0.ɵɵelementEnd();
            i0.ɵɵtemplate(7, TDSCarouselComponent_ng_template_7_Template, 2, 1, "ng-template", null, 6, i0.ɵɵtemplateRefExtractor);
        }
        if (rf & 2) {
            i0.ɵɵclassProp("slick-vertical", ctx.tdsDotPosition === "left" || ctx.tdsDotPosition === "right");
            i0.ɵɵadvance(6);
            i0.ɵɵproperty("ngIf", ctx.tdsDots);
        }
    }, directives: [i5.NgIf, i5.NgForOf, i5.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    WithConfig()
], TDSCarouselComponent.prototype, "tdsEffect", void 0);
__decorate([
    WithConfig(),
    InputBoolean()
], TDSCarouselComponent.prototype, "tdsEnableSwipe", void 0);
__decorate([
    WithConfig(),
    InputBoolean()
], TDSCarouselComponent.prototype, "tdsDots", void 0);
__decorate([
    WithConfig(),
    InputBoolean()
], TDSCarouselComponent.prototype, "tdsAutoPlay", void 0);
__decorate([
    WithConfig(),
    InputNumber()
], TDSCarouselComponent.prototype, "tdsAutoPlaySpeed", void 0);
__decorate([
    InputNumber()
], TDSCarouselComponent.prototype, "tdsTransitionSpeed", void 0);
__decorate([
    WithConfig()
], TDSCarouselComponent.prototype, "tdsDotPosition", null);
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCarouselComponent, [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    selector: 'tds-carousel',
                    exportAs: 'tdsCarousel',
                    preserveWhitespaces: false,
                    template: `
    <div class="slick-initialized slick-slider" [class.slick-vertical]="tdsDotPosition === 'left' || tdsDotPosition === 'right'">
      <div
        #slickList
        class="slick-list"
        tabindex="-1"
        (keydown)="onKeyDown($event)"
        (mousedown)="pointerDown($event)"
        (touchstart)="pointerDown($event)"
      >
        <!-- Render carousel items. -->
        <div class="slick-track" #slickTrack>
          <ng-content></ng-content>
        </div>
      </div>
      <!-- Render dots. -->
      <ul
        class="slick-dots"
        *ngIf="tdsDots"
        [class.slick-dots-top]="tdsDotPosition === 'top'"
        [class.slick-dots-bottom]="tdsDotPosition === 'bottom'"
        [class.slick-dots-left]="tdsDotPosition === 'left'"
        [class.slick-dots-right]="tdsDotPosition === 'right'"
      >
        <li *ngFor="let content of carouselContents; let i = index" [class.slick-active]="content.isActive" (click)="onLiClick(i)">
          <ng-template [ngTemplateOutlet]="tdsDotRender || renderDotTemplate" [ngTemplateOutletContext]="{ $implicit: i }"></ng-template>
        </li>
      </ul>
    </div>

    <ng-template #renderDotTemplate let-index>
      <button>{{ index + 1 }}</button>
    </ng-template>
  `,
                    host: {
                        '[class.tds-carousel-vertical]': 'vertical',
                        '[class.tds-carousel-rtl]': `dir ==='rtl'`,
                        'class': 'block relative overflow-hidden w-full h-full'
                    }
                }]
        }], function () {
        return [{ type: i0.ElementRef }, { type: i1.TDSConfigService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i2.Platform }, { type: i3.TDSResizeService }, { type: i3.TDSDragService }, { type: i4.Directionality, decorators: [{
                        type: Optional
                    }] }, { type: undefined, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [TDS_CAROUSEL_CUSTOM_STRATEGIES]
                    }] }];
    }, { carouselContents: [{
                type: ContentChildren,
                args: [TDSCarouselContentDirective]
            }], slickList: [{
                type: ViewChild,
                args: ['slickList', { static: false }]
            }], slickTrack: [{
                type: ViewChild,
                args: ['slickTrack', { static: false }]
            }], tdsDotRender: [{
                type: Input
            }], tdsEffect: [{
                type: Input
            }], tdsEnableSwipe: [{
                type: Input
            }], tdsDots: [{
                type: Input
            }], tdsAutoPlay: [{
                type: Input
            }], tdsAutoPlaySpeed: [{
                type: Input
            }], tdsTransitionSpeed: [{
                type: Input
            }], tdsStrategyOptions: [{
                type: Input
            }], tdsDotPosition: [{
                type: Input
            }], tdsBeforeChange: [{
                type: Output
            }], tdsAfterChange: [{
                type: Output
            }] });
})();

class TDSCarouselModule {
}
TDSCarouselModule.ɵfac = function TDSCarouselModule_Factory(t) { return new (t || TDSCarouselModule)(); };
TDSCarouselModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSCarouselModule });
TDSCarouselModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[BidiModule, CommonModule, PlatformModule]] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCarouselModule, [{
            type: NgModule,
            args: [{
                    declarations: [TDSCarouselComponent, TDSCarouselContentDirective],
                    exports: [TDSCarouselComponent, TDSCarouselContentDirective],
                    imports: [BidiModule, CommonModule, PlatformModule]
                }]
        }], null, null);
})();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSCarouselModule, { declarations: [TDSCarouselComponent, TDSCarouselContentDirective], imports: [BidiModule, CommonModule, PlatformModule], exports: [TDSCarouselComponent, TDSCarouselContentDirective] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSCarouselBaseStrategy, TDSCarouselComponent, TDSCarouselContentDirective, TDSCarouselModule, TDS_CAROUSEL_CUSTOM_STRATEGIES };
//# sourceMappingURL=tds-ui-carousel.mjs.map
