import * as i1 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, Input, NgModule } from '@angular/core';
import * as i3 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';
import { __rest, __decorate } from 'tslib';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { TDSHelperObject, TDSHelperString, InputBoolean, InputNumber } from 'tds-ui/shared/utility';

function stripPercentToNumber(percent) {
    return +percent.replace('%', '');
}
const sortGradient = (gradients) => {
    let tempArr = [];
    Object.keys(gradients).forEach(key => {
        const value = gradients[key];
        const formatKey = stripPercentToNumber(key);
        if (!isNaN(formatKey)) {
            tempArr.push({
                key: formatKey,
                value
            });
        }
    });
    tempArr = tempArr.sort((a, b) => a.key - b.key);
    return tempArr;
};
const handleCircleGradient = (strokeColor) => {
    return sortGradient(strokeColor).map(({ key, value }) => ({ offset: `${key}%`, color: value }));
};
const handleLinearGradient = (strokeColor) => {
    const { from = '#1890ff', to = '#1890ff', direction = 'to right' } = strokeColor, rest = __rest(strokeColor, ["from", "to", "direction"]);
    if (Object.keys(rest).length !== 0) {
        const sortedGradients = sortGradient(rest)
            .map(({ key, value }) => `${value} ${key}%`)
            .join(', ');
        return `linear-gradient(${direction}, ${sortedGradients})`;
    }
    return `linear-gradient(${direction}, ${from}, ${to})`;
};

function TDSProgressComponent_ng_template_0_span_0_ng_container_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵelement(1, "span", 1);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r5 = i0.ɵɵnextContext(3);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", ctx_r5.icon);
    }
}
function TDSProgressComponent_ng_template_0_span_0_ng_template_2_ng_container_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtext(1);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const formatter_r9 = ctx.$implicit;
        const ctx_r8 = i0.ɵɵnextContext(4);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", formatter_r9(ctx_r8.percent), " ");
    }
}
const _c0 = function (a0) { return { $implicit: a0 }; };
function TDSProgressComponent_ng_template_0_span_0_ng_template_2_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵtemplate(0, TDSProgressComponent_ng_template_0_span_0_ng_template_2_ng_container_0_Template, 2, 1, "ng-container", 8);
    }
    if (rf & 2) {
        const ctx_r7 = i0.ɵɵnextContext(3);
        i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r7.formatter)("tdsStringTemplateOutletContext", i0.ɵɵpureFunction1(2, _c0, ctx_r7.percent));
    }
}
const _c1 = function (a0) { return { "p-0 m-0 absolute w-full inset-0 flex items-center justify-center": a0 }; };
function TDSProgressComponent_ng_template_0_span_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "span", 5);
        i0.ɵɵtemplate(1, TDSProgressComponent_ng_template_0_span_0_ng_container_1_Template, 2, 1, "ng-container", 6);
        i0.ɵɵtemplate(2, TDSProgressComponent_ng_template_0_span_0_ng_template_2_Template, 1, 4, "ng-template", null, 7, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const _r6 = i0.ɵɵreference(3);
        const ctx_r4 = i0.ɵɵnextContext(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(3, _c1, ctx_r4.isCircleStyle));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", (ctx_r4._status === "exception" || ctx_r4._status === "success") && !ctx_r4.format)("ngIfElse", _r6);
    }
}
function TDSProgressComponent_ng_template_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵtemplate(0, TDSProgressComponent_ng_template_0_span_0_Template, 4, 5, "span", 4);
    }
    if (rf & 2) {
        const ctx_r1 = i0.ɵɵnextContext();
        i0.ɵɵproperty("ngIf", ctx_r1.showInfo);
    }
}
function TDSProgressComponent_div_3_ng_container_1_div_1_div_3_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelement(0, "div", 18);
    }
    if (rf & 2) {
        const ctx_r14 = i0.ɵɵnextContext(4);
        i0.ɵɵstyleProp("width", ctx_r14.successPercent, "%")("border-radius", ctx_r14.strokeLinecap === "round" ? "100px" : "0")("height", ctx_r14._strokeWidth, "px");
    }
}
function TDSProgressComponent_div_3_ng_container_1_div_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 14)(1, "div", 15);
        i0.ɵɵelement(2, "div", 16);
        i0.ɵɵtemplate(3, TDSProgressComponent_div_3_ng_container_1_div_1_div_3_Template, 1, 6, "div", 17);
        i0.ɵɵelementEnd()();
    }
    if (rf & 2) {
        const ctx_r12 = i0.ɵɵnextContext(3);
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("width", ctx_r12.percent, "%")("border-radius", ctx_r12.strokeLinecap === "round" ? "100px" : "0")("background", !ctx_r12.isGradient ? ctx_r12.strokeColor : null)("background-image", ctx_r12.isGradient ? ctx_r12.lineGradient : null)("height", ctx_r12._strokeWidth, "px");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx_r12.successPercent || ctx_r12.successPercent === 0);
    }
}
function TDSProgressComponent_div_3_ng_container_1_ng_template_2_Template(rf, ctx) { }
function TDSProgressComponent_div_3_ng_container_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtemplate(1, TDSProgressComponent_div_3_ng_container_1_div_1_Template, 4, 11, "div", 12);
        i0.ɵɵtemplate(2, TDSProgressComponent_div_3_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 13);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r10 = i0.ɵɵnextContext(2);
        const _r0 = i0.ɵɵreference(1);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx_r10.isSteps);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngTemplateOutlet", _r0);
    }
}
function TDSProgressComponent_div_3_div_2_div_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelement(0, "div", 21);
    }
    if (rf & 2) {
        const step_r17 = ctx.$implicit;
        i0.ɵɵproperty("ngStyle", step_r17);
    }
}
function TDSProgressComponent_div_3_div_2_ng_template_2_Template(rf, ctx) { }
function TDSProgressComponent_div_3_div_2_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 19);
        i0.ɵɵtemplate(1, TDSProgressComponent_div_3_div_2_div_1_Template, 1, 1, "div", 20);
        i0.ɵɵtemplate(2, TDSProgressComponent_div_3_div_2_ng_template_2_Template, 0, 0, "ng-template", 13);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const ctx_r11 = i0.ɵɵnextContext(2);
        const _r0 = i0.ɵɵreference(1);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx_r11._steps);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngTemplateOutlet", _r0);
    }
}
function TDSProgressComponent_div_3_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 9);
        i0.ɵɵtemplate(1, TDSProgressComponent_div_3_ng_container_1_Template, 3, 2, "ng-container", 10);
        i0.ɵɵtemplate(2, TDSProgressComponent_div_3_div_2_Template, 3, 2, "div", 11);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const ctx_r2 = i0.ɵɵnextContext();
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx_r2.isSteps);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx_r2.isSteps);
    }
}
function TDSProgressComponent_div_4__svg_defs_2__svg_stop_2_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵnamespaceSVG();
        i0.ɵɵelement(0, "stop");
    }
    if (rf & 2) {
        const i_r23 = ctx.$implicit;
        i0.ɵɵattribute("offset", i_r23.offset)("stop-color", i_r23.color);
    }
}
function TDSProgressComponent_div_4__svg_defs_2_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵnamespaceSVG();
        i0.ɵɵelementStart(0, "defs")(1, "linearGradient", 26);
        i0.ɵɵtemplate(2, TDSProgressComponent_div_4__svg_defs_2__svg_stop_2_Template, 1, 2, "stop", 27);
        i0.ɵɵelementEnd()();
    }
    if (rf & 2) {
        const ctx_r19 = i0.ɵɵnextContext(2);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("id", "gradient-" + ctx_r19.gradientId);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx_r19.circleGradient);
    }
}
function TDSProgressComponent_div_4__svg_path_4_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵnamespaceSVG();
        i0.ɵɵelementStart(0, "path", 28);
        i0.ɵɵtext(1);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const p_r24 = ctx.$implicit;
        const ctx_r20 = i0.ɵɵnextContext(2);
        i0.ɵɵproperty("ngStyle", p_r24.strokePathStyle);
        i0.ɵɵattribute("d", ctx_r20.pathString)("stroke-linecap", ctx_r20.strokeLinecap)("stroke-width", ctx_r20.percent ? ctx_r20._strokeWidth : 0);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(p_r24.stroke);
    }
}
function TDSProgressComponent_div_4_ng_template_5_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵnamespaceSVG();
    }
}
function TDSProgressComponent_div_4_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 22);
        i0.ɵɵnamespaceSVG();
        i0.ɵɵelementStart(1, "svg", 23);
        i0.ɵɵtemplate(2, TDSProgressComponent_div_4__svg_defs_2_Template, 3, 2, "defs", 10);
        i0.ɵɵelement(3, "path", 24);
        i0.ɵɵtemplate(4, TDSProgressComponent_div_4__svg_path_4_Template, 2, 5, "path", 25);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(5, TDSProgressComponent_div_4_ng_template_5_Template, 0, 0, "ng-template", 13);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const ctx_r3 = i0.ɵɵnextContext();
        const _r0 = i0.ɵɵreference(1);
        i0.ɵɵstyleProp("width", ctx_r3.width, "px")("height", ctx_r3.width, "px")("font-size", ctx_r3.width * 0.15 + 6, "px");
        i0.ɵɵclassProp("tds-progress-circle-gradient", ctx_r3.isGradient);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx_r3.isGradient);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngStyle", ctx_r3.trailPathStyle);
        i0.ɵɵattribute("stroke-width", ctx_r3._strokeWidth)("d", ctx_r3.pathString);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx_r3.progressCirclePath)("ngForTrackBy", ctx_r3.trackByFn);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngTemplateOutlet", _r0);
    }
}
const _c2 = function (a0) { return { "relative w-full ": a0 }; };
let gradientIdSeed = 0;
const TDS_CONFIG_MODULE_NAME = 'progress';
const statusIconNameMap = new Map([
    ['success', 'success'],
    ['exception', 'error']
]);
const statusColorMap = new Map([
    ['normal', '#28A745'],
    ['exception', '#28A745'],
    ['success', '#28A745']
]);
const defaultFormatter = (p) => `${p}%`;
class TDSProgressComponent {
    constructor(cdr, 
    // public tdsConfigService: TDSConfigService,
    directionality) {
        this.cdr = cdr;
        this.directionality = directionality;
        this.showInfo = true;
        this.width = 132;
        this.strokeColor = undefined;
        this.size = 'default';
        this.percent = 0;
        this.strokeWidth = undefined;
        this.gapDegree = undefined;
        this.type = 'line';
        this.gapPosition = 'top';
        this.strokeLinecap = 'round';
        this.steps = 0;
        this._steps = [];
        /** Gradient style when `type` is `line`. */
        this.lineGradient = null;
        /** If user uses gradient color. */
        this.isGradient = false;
        /** If the linear progress is a step progress. */
        this.isSteps = false;
        /**
         * Each progress whose `type` is circle or dashboard should have unique id to
         * define `<linearGradient>`.
         */
        this.gradientId = gradientIdSeed++;
        /** Paths to rendered in the template. */
        this.progressCirclePath = [];
        this.trailPathStyle = null;
        this.dir = 'ltr';
        this.trackByFn = (index) => `${index}`;
        this.cachedStatus = 'normal';
        this.inferredStatus = 'normal';
        this.destroy$ = new Subject();
    }
    get formatter() {
        return this.format || defaultFormatter;
    }
    get _status() {
        return this.status || this.inferredStatus;
    }
    get _strokeWidth() {
        return this.strokeWidth || (this.type === 'line' && this.size !== 'small' ? 8 : 6);
    }
    get isCircleStyle() {
        return this.type === 'circle' || this.type === 'dashboard';
    }
    ngOnChanges(changes) {
        const { steps, gapPosition, strokeLinecap, strokeColor, gapDegree, type, status, percent, successPercent, strokeWidth } = changes;
        if (status) {
            this.cachedStatus = this.status || this.cachedStatus;
        }
        if (percent || successPercent) {
            const fillAll = parseInt(this.percent.toString(), 10) >= 100;
            if (fillAll) {
                if ((TDSHelperObject.hasValue(this.successPercent) && this.successPercent >= 100) || this.successPercent === undefined) {
                    this.inferredStatus = 'success';
                }
            }
            else {
                this.inferredStatus = this.cachedStatus;
            }
        }
        if (status || percent || successPercent || strokeColor) {
            this.updateIcon();
        }
        if (strokeColor) {
            this.setStrokeColor();
        }
        if (gapPosition || strokeLinecap || gapDegree || type || percent || strokeColor || strokeColor) {
            this.getCirclePaths();
        }
        if (percent || steps || strokeWidth) {
            this.isSteps = this.steps > 0;
            if (this.isSteps) {
                this.getSteps();
            }
        }
    }
    ngOnInit() {
        var _a;
        // this.tdsConfigService
        //   .getConfigChangeEventForComponent(TDS_CONFIG_MODULE_NAME)
        //   .pipe(takeUntil(this.destroy$))
        //   .subscribe(() => {
        this.updateIcon();
        this.setStrokeColor();
        this.getCirclePaths();
        // });
        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
        this.dir = this.directionality.value;
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    updateIcon() {
        const ret = statusIconNameMap.get(this._status);
        this.icon = "";
        if (TDSHelperString.hasValueString(ret)) {
            if (!this.isCircleStyle) {
                this.icon = `tdsi-${ret}-fill text-${ret}-400`;
            }
            else {
                switch (ret) {
                    case "error":
                        this.icon = `tdsi-close-fill text-${ret}-400`;
                        break;
                    default:
                        this.icon = `tdsi-tick-fill text-${ret}-400`;
                        break;
                }
            }
        }
    }
    /**
     * Calculate step render configs.
     */
    getSteps() {
        const current = Math.floor(this.steps * (this.percent / 100));
        const stepWidth = this.size === 'small' ? 2 : 14;
        const _steps = [];
        for (let i = 0; i < this.steps; i++) {
            let color;
            if (i <= current - 1) {
                color = this.strokeColor;
            }
            const stepStyle = {
                backgroundColor: `${color}`,
                width: `${stepWidth}px`,
                height: `${this._strokeWidth}px`
            };
            _steps.push(stepStyle);
        }
        this._steps = _steps;
    }
    /**
     * Calculate paths when the type is circle or dashboard.
     */
    getCirclePaths() {
        if (!this.isCircleStyle) {
            return;
        }
        const values = TDSHelperObject.hasValue(this.successPercent) ? [this.successPercent, this.percent] : [this.percent];
        // Calculate shared styles.
        const radius = 50 - this._strokeWidth / 2;
        const gapPosition = this.gapPosition || (this.type === 'circle' ? 'top' : 'bottom');
        const len = Math.PI * 2 * radius;
        const gapDegree = this.gapDegree || (this.type === 'circle' ? 0 : 75);
        let beginPositionX = 0;
        let beginPositionY = -radius;
        let endPositionX = 0;
        let endPositionY = radius * -2;
        switch (gapPosition) {
            case 'left':
                beginPositionX = -radius;
                beginPositionY = 0;
                endPositionX = radius * 2;
                endPositionY = 0;
                break;
            case 'right':
                beginPositionX = radius;
                beginPositionY = 0;
                endPositionX = radius * -2;
                endPositionY = 0;
                break;
            case 'bottom':
                beginPositionY = radius;
                endPositionY = radius * 2;
                break;
            default:
        }
        this.pathString = `M 50,50 m ${beginPositionX},${beginPositionY}
       a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
       a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
        this.trailPathStyle = {
            strokeDasharray: `${len - gapDegree}px ${len}px`,
            strokeDashoffset: `-${gapDegree / 2}px`,
            transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s'
        };
        // Calculate styles for each path.
        this.progressCirclePath = values
            .map((value, index) => {
            const isSuccessPercent = values.length === 2 && index === 0;
            return {
                stroke: this.isGradient && !isSuccessPercent ? `url(#gradient-${this.gradientId})` : null,
                strokePathStyle: {
                    stroke: !this.isGradient ? (isSuccessPercent ? statusColorMap.get('success') : this.strokeColor) : null,
                    transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s',
                    strokeDasharray: `${((value || 0) / 100) * (len - gapDegree)}px ${len}px`,
                    strokeDashoffset: `-${gapDegree / 2}px`
                }
            };
        })
            .reverse();
    }
    setStrokeColor() {
        const color = this.strokeColor;
        const isGradient = (this.isGradient = !!color && typeof color !== 'string');
        if (isGradient && !this.isCircleStyle) {
            this.lineGradient = handleLinearGradient(color);
        }
        else if (isGradient && this.isCircleStyle) {
            this.circleGradient = handleCircleGradient(this.strokeColor);
        }
        else {
            this.lineGradient = null;
            this.circleGradient = [];
        }
    }
}
TDSProgressComponent.ɵfac = function TDSProgressComponent_Factory(t) { return new (t || TDSProgressComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.Directionality, 8)); };
TDSProgressComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSProgressComponent, selectors: [["tds-progress"]], inputs: { showInfo: "showInfo", width: "width", strokeColor: "strokeColor", size: "size", format: "format", successPercent: "successPercent", percent: "percent", strokeWidth: "strokeWidth", gapDegree: "gapDegree", status: "status", type: "type", gapPosition: "gapPosition", strokeLinecap: "strokeLinecap", steps: "steps" }, exportAs: ["tdsProgress"], features: [i0.ɵɵNgOnChangesFeature], decls: 5, vars: 20, consts: [["progressInfoTemplate", ""], [3, "ngClass"], ["class", "w-full flex items-center", 4, "ngIf"], ["class", "tds-progress-inner relative", 3, "width", "height", "fontSize", "tds-progress-circle-gradient", 4, "ngIf"], ["class", "tds-progress-text pl-2 text-body-2 font-regular text-neutral-1-900 dark:text-d-neutral-1-900", 3, "ngClass", 4, "ngIf"], [1, "tds-progress-text", "pl-2", "text-body-2", "font-regular", "text-neutral-1-900", "dark:text-d-neutral-1-900", 3, "ngClass"], [4, "ngIf", "ngIfElse"], ["formatTemplate", ""], [4, "tdsStringTemplateOutlet", "tdsStringTemplateOutletContext"], [1, "w-full", "flex", "items-center"], [4, "ngIf"], ["class", "tds-progress-_steps-outer", 4, "ngIf"], ["class", "tds-progress-outer flex-auto", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "tds-progress-outer", "flex-auto"], [1, "tds-progress-inner", "relative", "w-full", "bg-neutral-2-300", "dark:bg-d-neutral-2-300", "overflow-hidden", "rounded-full"], [1, "tds-progress-bg", "bg-primary-1"], ["class", "tds-progress-success-bg  bg-primary-1", 3, "width", "border-radius", "height", 4, "ngIf"], [1, "tds-progress-success-bg", "bg-primary-1"], [1, "tds-progress-_steps-outer"], ["class", "tds-progress-_steps-item", 3, "ngStyle", 4, "ngFor", "ngForOf"], [1, "tds-progress-_steps-item", 3, "ngStyle"], [1, "tds-progress-inner", "relative"], ["viewBox", "0 0 100 100", 1, "tds-progress-circle"], ["fill-opacity", "0", 1, "tds-progress-circle-trail", "stroke-current", "text-neutral-2-300", "dark:text-d-neutral-2-300", 3, "ngStyle"], ["class", "tds-progress-circle-path stroke-current text-success-400", "fill-opacity", "0", 3, "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["x1", "100%", "y1", "0%", "x2", "0%", "y2", "0%", 3, "id"], [4, "ngFor", "ngForOf"], ["fill-opacity", "0", 1, "tds-progress-circle-path", "stroke-current", "text-success-400", 3, "ngStyle"]], template: function TDSProgressComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵtemplate(0, TDSProgressComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
            i0.ɵɵelementStart(2, "div", 1);
            i0.ɵɵtemplate(3, TDSProgressComponent_div_3_Template, 3, 2, "div", 2);
            i0.ɵɵtemplate(4, TDSProgressComponent_div_4_Template, 6, 15, "div", 3);
            i0.ɵɵelementEnd();
        }
        if (rf & 2) {
            i0.ɵɵadvance(2);
            i0.ɵɵclassMapInterpolate1("tds-progress  m-0 p-0 border-box  ", "tds-progress-_status-" + ctx._status, "");
            i0.ɵɵclassProp("tds-progress-line", ctx.type == "line")("tds-progress-small", ctx.size == "small")("tds-progress-show-info", ctx.showInfo)("tds-progress-circle", ctx.isCircleStyle)("tds-progress-_steps", ctx.isSteps)("tds-progress-rtl", ctx.dir === "rtl");
            i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(18, _c2, ctx.type == "line"));
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("ngIf", ctx.type === "line");
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("ngIf", ctx.isCircleStyle);
        }
    }, directives: [i2.NgIf, i2.NgClass, i3.TDSStringTemplateOutletDirective, i2.NgTemplateOutlet, i2.NgForOf, i2.NgStyle], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSProgressComponent.prototype, "showInfo", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "successPercent", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "percent", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "strokeWidth", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "gapDegree", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "steps", void 0);
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSProgressComponent, [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    selector: 'tds-progress',
                    exportAs: 'tdsProgress',
                    preserveWhitespaces: false,
                    template: `
    <ng-template #progressInfoTemplate>
      <span class="tds-progress-text pl-2 text-body-2 font-regular text-neutral-1-900 dark:text-d-neutral-1-900" *ngIf="showInfo" [ngClass]="{'p-0 m-0 absolute w-full inset-0 flex items-center justify-center':isCircleStyle}">
        <ng-container *ngIf="(_status === 'exception' || _status === 'success') && !format; else formatTemplate">
          <span [ngClass]="icon"> </span>
        </ng-container>
        <ng-template #formatTemplate>
          <ng-container *tdsStringTemplateOutlet="formatter; context: { $implicit: percent }; let formatter">
            {{ formatter(percent) }}
          </ng-container>
        </ng-template>
      </span>
    </ng-template>

    <div
      class="tds-progress  m-0 p-0 border-box  {{'tds-progress-_status-' + _status}}"
      [ngClass]="{'relative w-full ':type == 'line'}"
      [class.tds-progress-line]="type == 'line'"
      [class.tds-progress-small]="size == 'small'"
      [class.tds-progress-show-info]="showInfo"
      [class.tds-progress-circle]="isCircleStyle"
      [class.tds-progress-_steps]="isSteps"
      [class.tds-progress-rtl]="dir === 'rtl'"
    >
      <!-- line progress -->
      <div *ngIf="type === 'line'" class="w-full flex items-center">
        <!-- normal line style -->
        <ng-container *ngIf="!isSteps">
          <div class="tds-progress-outer flex-auto" *ngIf="!isSteps">
            <div class="tds-progress-inner relative w-full bg-neutral-2-300 dark:bg-d-neutral-2-300 overflow-hidden rounded-full">
              <div
                class="tds-progress-bg bg-primary-1"
                [style.width.%]="percent"
                [style.border-radius]="strokeLinecap === 'round' ? '100px' : '0'"
                [style.background]="!isGradient ? strokeColor : null"
                [style.background-image]="isGradient ? lineGradient : null"
                [style.height.px]="_strokeWidth"
              ></div>
              <div
                *ngIf="successPercent || successPercent === 0"
                class="tds-progress-success-bg  bg-primary-1"
                [style.width.%]="successPercent"
                [style.border-radius]="strokeLinecap === 'round' ? '100px' : '0'"
                [style.height.px]="_strokeWidth"
              ></div>
            </div>
          </div>
          <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template>
        </ng-container>
        <!-- step style -->
        <div class="tds-progress-_steps-outer" *ngIf="isSteps">
          <div *ngFor="let step of _steps; let i = index" class="tds-progress-_steps-item" [ngStyle]="step"></div>
          <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template>
        </div>
      </div>

      <!-- circle / dashboard progress -->
      <div
        [style.width.px]="this.width"
        [style.height.px]="this.width"
        [style.fontSize.px]="this.width * 0.15 + 6"
        class="tds-progress-inner relative"
        [class.tds-progress-circle-gradient]="isGradient"
        *ngIf="isCircleStyle"
      >
        <svg class="tds-progress-circle " viewBox="0 0 100 100">
          <defs *ngIf="isGradient">
            <linearGradient [id]="'gradient-' + gradientId" x1="100%" y1="0%" x2="0%" y2="0%">
              <stop *ngFor="let i of circleGradient" [attr.offset]="i.offset" [attr.stop-color]="i.color"></stop>
            </linearGradient>
          </defs>
          <path
            class="tds-progress-circle-trail stroke-current text-neutral-2-300 dark:text-d-neutral-2-300"
           
            fill-opacity="0"
            [attr.stroke-width]="_strokeWidth"
            [attr.d]="pathString"
            [ngStyle]="trailPathStyle"
          ></path>
          <path
            *ngFor="let p of progressCirclePath; trackBy: trackByFn"
            class="tds-progress-circle-path stroke-current text-success-400"
            fill-opacity="0"
            [attr.d]="pathString"
            [attr.stroke-linecap]="strokeLinecap"
           
            [attr.stroke-width]="percent ? _strokeWidth : 0"
            [ngStyle]="p.strokePathStyle"
          >{{p.stroke}}</path>
        </svg>
        <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template>
      </div>
    </div>
  `
                }]
        }], function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i1.Directionality, decorators: [{
                        type: Optional
                    }] }];
    }, { showInfo: [{
                type: Input
            }], width: [{
                type: Input
            }], strokeColor: [{
                type: Input
            }], size: [{
                type: Input
            }], format: [{
                type: Input
            }], successPercent: [{
                type: Input
            }], percent: [{
                type: Input
            }], strokeWidth: [{
                type: Input
            }], gapDegree: [{
                type: Input
            }], status: [{
                type: Input
            }], type: [{
                type: Input
            }], gapPosition: [{
                type: Input
            }], strokeLinecap: [{
                type: Input
            }], steps: [{
                type: Input
            }] });
})();

class TDSProgressModule {
}
TDSProgressModule.ɵfac = function TDSProgressModule_Factory(t) { return new (t || TDSProgressModule)(); };
TDSProgressModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSProgressModule });
TDSProgressModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[BidiModule, CommonModule, TDSOutletModule]] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSProgressModule, [{
            type: NgModule,
            args: [{
                    exports: [TDSProgressComponent],
                    declarations: [TDSProgressComponent],
                    imports: [BidiModule, CommonModule, TDSOutletModule]
                }]
        }], null, null);
})();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSProgressModule, { declarations: [TDSProgressComponent], imports: [BidiModule, CommonModule, TDSOutletModule], exports: [TDSProgressComponent] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSProgressComponent, TDSProgressModule };
//# sourceMappingURL=tds-ui-progress.mjs.map
