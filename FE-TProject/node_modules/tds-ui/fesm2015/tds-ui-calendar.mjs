import * as i1$2 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i2$2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Directive, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, ContentChildren, TemplateRef, forwardRef, Optional, ContentChild, NgModule } from '@angular/core';
import * as i4 from '@angular/forms';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import * as i5 from 'tds-ui/button';
import { TDSButtonModule } from 'tds-ui/button';
import * as i3 from 'tds-ui/date-picker';
import { LibPackerModule, TDSDatePickerModule } from 'tds-ui/date-picker';
import * as i2 from 'tds-ui/dropdown';
import { TDSDropDownModule } from 'tds-ui/dropdown';
import * as i1 from 'tds-ui/i18n';
import { TDSI18nModule } from 'tds-ui/i18n';
import * as i2$1 from 'tds-ui/radio';
import { TDSRadioModule } from 'tds-ui/radio';
import { TDSSelectModule } from 'tds-ui/select';
import { CandyDate } from 'tds-ui/core/time';
import { startOfWeek, endOfWeek, eachDayOfInterval, startOfMonth, endOfMonth, setMinutes, setHours, startOfDay, startOfMinute, endOfDay, addDays, addMinutes, isSameSecond, differenceInMinutes, isSameDay } from 'date-fns';
import { __decorate } from 'tslib';
import { Subject, BehaviorSubject, interval, merge } from 'rxjs';
import { startWith, switchMapTo, map, takeUntil, switchMap } from 'rxjs/operators';
import { InputBoolean } from 'tds-ui/shared/utility';
import * as i1$1 from 'tds-ui/core/services';
import { TDSDestroyService } from 'tds-ui/core/services';
import * as i4$1 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';

class TDSDateCellDirective {
}
TDSDateCellDirective.ɵfac = function TDSDateCellDirective_Factory(t) { return new (t || TDSDateCellDirective)(); };
TDSDateCellDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSDateCellDirective, selectors: [["", "tdsDateCell", ""]], exportAs: ["tdsDateCell"] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDateCellDirective, [{
            type: Directive,
            args: [{
                    selector: '[tdsDateCell]',
                    exportAs: 'tdsDateCell'
                }]
        }], null, null);
})();
class TDSMonthCellDirective {
}
TDSMonthCellDirective.ɵfac = function TDSMonthCellDirective_Factory(t) { return new (t || TDSMonthCellDirective)(); };
TDSMonthCellDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSMonthCellDirective, selectors: [["", "tdsMonthCell", ""]], exportAs: ["tdsMonthCell"] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSMonthCellDirective, [{
            type: Directive,
            args: [{
                    selector: '[tdsMonthCell]',
                    exportAs: 'tdsMonthCell'
                }]
        }], null, null);
})();
class TDSDateFullCellDirective {
}
TDSDateFullCellDirective.ɵfac = function TDSDateFullCellDirective_Factory(t) { return new (t || TDSDateFullCellDirective)(); };
TDSDateFullCellDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSDateFullCellDirective, selectors: [["", "tdsDateFullCell", ""]], exportAs: ["tdsDateFullCell"] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDateFullCellDirective, [{
            type: Directive,
            args: [{
                    selector: '[tdsDateFullCell]',
                    exportAs: 'tdsDateFullCell'
                }]
        }], null, null);
})();
class TDSMonthFullCellDirective {
}
TDSMonthFullCellDirective.ɵfac = function TDSMonthFullCellDirective_Factory(t) { return new (t || TDSMonthFullCellDirective)(); };
TDSMonthFullCellDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSMonthFullCellDirective, selectors: [["", "tdsMonthFullCell", ""]], exportAs: ["tdsMonthFullCell"] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSMonthFullCellDirective, [{
            type: Directive,
            args: [{
                    selector: '[tdsMonthFullCell]',
                    exportAs: 'tdsMonthFullCell'
                }]
        }], null, null);
})();

class TDSCalendarDatepickerComponent {
    constructor(cdr, i18n, dateHelper) {
        this.cdr = cdr;
        this.i18n = i18n;
        this.dateHelper = dateHelper;
        this.tdsMode = "date";
        this.tdsViewDate = new Date();
        this.tdsViewDateChange = new EventEmitter();
        this.tdsValueChange = new EventEmitter();
        this.activeDate = new CandyDate();
        this.formatDate = 'MMMM yyyy';
        this.viewDate = '';
        this.dropdownVisible = false;
    }
    ngOnChanges(changes) {
        if (changes.tdsViewDate || changes.tdsMode) {
            this.activeDate = new CandyDate(this.tdsViewDate);
            this.updateFormatDate();
        }
    }
    ngOnInit() {
        // this.weekStartsOn = this.i18n.getDateLocale().
        this.updateFormatDate();
    }
    onChangeDatePicker(result) {
        if (!this.activeDate.isSame(result)) {
            this.activeDate = new CandyDate(result);
        }
        this.dropdownVisible = false;
        this.updateFormatDate();
        this.valueChange();
    }
    onNextPrevious(e, step) {
        e.stopPropagation();
        e.preventDefault();
        switch (this.tdsMode) {
            case 'date':
                this.activeDate = new CandyDate(this.activeDate.addDays(step).nativeDate);
                break;
            case 'week':
                this.activeDate = new CandyDate(this.activeDate.addMonths(step).nativeDate);
                break;
            case 'month':
                this.activeDate = new CandyDate(this.activeDate.addMonths(step).nativeDate);
                break;
            case 'year':
                this.activeDate = new CandyDate(this.activeDate.addYears(step).nativeDate);
                break;
            default:
                this.activeDate = new CandyDate(this.activeDate.addMonths(step).nativeDate);
                break;
        }
        this.valueChange();
        this.updateFormatDate();
    }
    updateFormatDate() {
        switch (this.tdsMode) {
            case 'date':
                this.formatDate = 'EEEE - dd/MM/yyyy';
                break;
            case 'week':
                this.formatDate = 'MMMM yyyy';
                break;
            case 'month':
                this.formatDate = 'MMMM - yyyy';
                break;
            case 'year':
                this.formatDate = 'yyyy';
                break;
            default:
                this.formatDate = 'yyyy';
                break;
        }
        this.viewDate = this.dateHelper.format(this.activeDate.nativeDate, this.formatDate);
        this.cdr.markForCheck();
    }
    valueChange() {
        let viewDate = this.activeDate.clone().nativeDate;
        this.tdsViewDateChange.emit(viewDate);
        let rangeDate = [];
        switch (this.tdsMode) {
            case 'week':
                rangeDate = this.getDayOfWeek(viewDate);
                break;
            case 'month':
                rangeDate = this.getDayOfMonth(viewDate);
                break;
            default:
                rangeDate = [viewDate];
                break;
        }
        this.tdsValueChange.emit(rangeDate);
    }
    onDropdownOutsideClick() {
        if (this.dropdownVisible) {
            this.dropdownVisible = false;
        }
    }
    getDayOfWeek(viewDate) {
        let startWeek = startOfWeek(viewDate, { weekStartsOn: this.tdsWeekStartsOn || this.dateHelper.getFirstDayOfWeek() });
        let endWeek = endOfWeek(viewDate, { weekStartsOn: this.tdsWeekStartsOn || this.dateHelper.getFirstDayOfWeek() });
        return eachDayOfInterval({
            start: startWeek,
            end: endWeek
        });
    }
    getDayOfMonth(viewDate) {
        let startMonth = startOfMonth(viewDate);
        let endMonth = endOfMonth(viewDate);
        return eachDayOfInterval({
            start: startMonth,
            end: endMonth
        });
    }
}
TDSCalendarDatepickerComponent.ɵfac = function TDSCalendarDatepickerComponent_Factory(t) { return new (t || TDSCalendarDatepickerComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.TDSI18nService), i0.ɵɵdirectiveInject(i1.DateHelperService)); };
TDSCalendarDatepickerComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCalendarDatepickerComponent, selectors: [["tds-calendar-datepicker"]], inputs: { tdsMode: "tdsMode", tdsViewDate: "tdsViewDate", locale: "locale", tdsWeekStartsOn: "tdsWeekStartsOn" }, outputs: { tdsViewDateChange: "tdsViewDateChange", tdsValueChange: "tdsValueChange" }, exportAs: ["tdsCalendarDatepicker"], features: [i0.ɵɵNgOnChangesFeature], decls: 11, vars: 9, consts: [[1, "inline-flex", "justify-center", "items-center", "gap-x-4"], [1, "text-neutral-1-500", "hover:bg-neutral-3-50", "active:bg-neutral-3-100", "border", "border-transparent", "p-1.5", "rounded-full", "inline-flex", "justify-center", "items-center", 3, "click"], [1, "tdsi-arrow-left-line", "text-2xl", "leading-6"], ["tds-dropdown", "", 1, "inline-flex", "justify-center", "items-center", "text-heading-4", "font-semibold", "text-neutral-1-900", "py-2", 3, "autoClose", "placement", "visible", "trigger", "tdsDropdownMenu", "visibleChange", "tdsDropdownOutsideClick"], [1, "tdsi-arrow-right-line", "text-2xl", "leading-6"], ["drpDatepicker", "tdsDropdownMenu"], [1, "w-full"], [3, "inline", "ngModel", "mode", "ngModelChange"]], template: function TDSCalendarDatepickerComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵelementStart(0, "div", 0)(1, "button", 1);
            i0.ɵɵlistener("click", function TDSCalendarDatepickerComponent_Template_button_click_1_listener($event) { return ctx.onNextPrevious($event, -1); });
            i0.ɵɵelement(2, "span", 2);
            i0.ɵɵelementEnd();
            i0.ɵɵelementStart(3, "button", 3);
            i0.ɵɵlistener("visibleChange", function TDSCalendarDatepickerComponent_Template_button_visibleChange_3_listener($event) { return ctx.dropdownVisible = $event; })("tdsDropdownOutsideClick", function TDSCalendarDatepickerComponent_Template_button_tdsDropdownOutsideClick_3_listener() { return ctx.onDropdownOutsideClick(); });
            i0.ɵɵtext(4);
            i0.ɵɵelementEnd();
            i0.ɵɵelementStart(5, "button", 1);
            i0.ɵɵlistener("click", function TDSCalendarDatepickerComponent_Template_button_click_5_listener($event) { return ctx.onNextPrevious($event, 1); });
            i0.ɵɵelement(6, "span", 4);
            i0.ɵɵelementEnd()();
            i0.ɵɵelementStart(7, "tds-dropdown-menu", null, 5)(9, "div", 6)(10, "tds-date-picker", 7);
            i0.ɵɵlistener("ngModelChange", function TDSCalendarDatepickerComponent_Template_tds_date_picker_ngModelChange_10_listener($event) { return ctx.onChangeDatePicker($event); });
            i0.ɵɵelementEnd()()();
        }
        if (rf & 2) {
            const _r0 = i0.ɵɵreference(8);
            i0.ɵɵadvance(3);
            i0.ɵɵproperty("autoClose", false)("placement", "bottomCenter")("visible", ctx.dropdownVisible)("trigger", "click")("tdsDropdownMenu", _r0);
            i0.ɵɵadvance(1);
            i0.ɵɵtextInterpolate1(" ", ctx.viewDate, " ");
            i0.ɵɵadvance(6);
            i0.ɵɵproperty("inline", true)("ngModel", ctx.activeDate.nativeDate)("mode", ctx.tdsMode);
        }
    }, directives: [i2.TDSDropDownDirective, i2.TDSDropdownMenuComponent, i3.TDSDatePickerComponent, i4.NgControlStatus, i4.NgModel], encapsulation: 2, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarDatepickerComponent, [{
            type: Component,
            args: [{ selector: 'tds-calendar-datepicker', exportAs: 'tdsCalendarDatepicker', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"inline-flex justify-center items-center gap-x-4 \">\r\n    <button (click)=\"onNextPrevious($event,-1)\" class=\"text-neutral-1-500 hover:bg-neutral-3-50 active:bg-neutral-3-100 border border-transparent p-1.5 rounded-full inline-flex justify-center items-center\">\r\n        <span class=\"tdsi-arrow-left-line text-2xl leading-6\"></span>\r\n    </button>\r\n    <button class=\"inline-flex justify-center items-center text-heading-4 font-semibold text-neutral-1-900 py-2\" [autoClose]=\"false\" [placement]=\"'bottomCenter'\" [(visible)]=\"dropdownVisible\" [trigger]=\"'click'\"  tds-dropdown [tdsDropdownMenu]=\"drpDatepicker\" (tdsDropdownOutsideClick)=\"onDropdownOutsideClick()\">\r\n        {{viewDate}}\r\n    </button>\r\n    <button (click)=\"onNextPrevious($event,1)\"  class=\"text-neutral-1-500 hover:bg-neutral-3-50 active:bg-neutral-3-100 border border-transparent p-1.5 rounded-full inline-flex justify-center items-center\">\r\n        <span class=\"tdsi-arrow-right-line text-2xl leading-6\"></span>\r\n    </button>\r\n</div>\r\n<tds-dropdown-menu #drpDatepicker=\"tdsDropdownMenu\">\r\n    <div class=\"w-full\" >\r\n        <tds-date-picker [inline]=\"true\" [ngModel]=\"activeDate.nativeDate\" (ngModelChange)=\"onChangeDatePicker($event)\" [mode]=\"tdsMode\">\r\n        </tds-date-picker>\r\n    </div>\r\n</tds-dropdown-menu>" }]
        }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.TDSI18nService }, { type: i1.DateHelperService }]; }, { tdsMode: [{
                type: Input
            }], tdsViewDate: [{
                type: Input
            }], locale: [{
                type: Input
            }], tdsWeekStartsOn: [{
                type: Input
            }], tdsViewDateChange: [{
                type: Output
            }], tdsValueChange: [{
                type: Output
            }] });
})();

function TDSCalendarHeaderComponent_button_10_Template(rf, ctx) {
    if (rf & 1) {
        const _r2 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "button", 7);
        i0.ɵɵlistener("click", function TDSCalendarHeaderComponent_button_10_Template_button_click_0_listener($event) { i0.ɵɵrestoreView(_r2); const ctx_r1 = i0.ɵɵnextContext(); return ctx_r1.onToday($event); });
        i0.ɵɵelementStart(1, "span", 8);
        i0.ɵɵtext(2);
        i0.ɵɵelementEnd()();
    }
    if (rf & 2) {
        const ctx_r0 = i0.ɵɵnextContext();
        i0.ɵɵadvance(2);
        i0.ɵɵtextInterpolate1(" ", ctx_r0.toDayTypeText, " ");
    }
}
class TDSCalendarHeaderComponent {
    constructor(i18n, dateHelper, cdr) {
        this.i18n = i18n;
        this.dateHelper = dateHelper;
        this.cdr = cdr;
        this.tdsMode = 'month';
        this.tdsFullscreen = true;
        this.tdsViewDate = new Date();
        this.tdsModeChange = new EventEmitter();
        this.tdsActiveDateChange = new EventEmitter();
        this.tdsViewDateChange = new EventEmitter();
        this.hiddenTodaybtn = false;
        this.activeDate = new CandyDate();
    }
    get activeYear() {
        return this.activeDate.getYear();
    }
    get activeMonth() {
        return this.activeDate.getMonth();
    }
    get size() {
        return this.tdsFullscreen ? 'md' : 'sm';
    }
    get dayTypeText() {
        return this.i18n.getLocale().Calendar.lang.day;
    }
    get weekTypeText() {
        return this.i18n.getLocale().Calendar.lang.week;
    }
    get yearTypeText() {
        return this.i18n.getLocale().Calendar.lang.year;
    }
    get monthTypeText() {
        return this.i18n.getLocale().Calendar.lang.month;
    }
    get toDayTypeText() {
        return this.i18n.getLocale().Calendar.lang.today;
    }
    ngOnInit() {
        this.updateDate(this.tdsViewDate);
    }
    onToday(e) {
        e.preventDefault();
        e.stopImmediatePropagation();
        this.activeDate = new CandyDate(new Date());
        this.tdsViewDateChange.emit(this.activeDate.nativeDate);
        // this.checkHiddenTodayBtn();    
    }
    onModeChange(e) {
        this.tdsModeChange.emit(e);
        this.checkHiddenTodayBtn();
    }
    onValueChange(date) {
        this.tdsActiveDateChange.emit(new CandyDate(date));
        this.tdsViewDateChange.emit(date);
        this.checkHiddenTodayBtn();
    }
    ngOnChanges(changes) {
        if (changes.tdsViewDate) {
            this.updateDate(this.tdsViewDate);
            this.checkHiddenTodayBtn();
        }
    }
    updateDate(date) {
        this.activeDate = new CandyDate(date);
    }
    checkHiddenTodayBtn() {
        this.hiddenTodaybtn = this.tdsMode == "date" && !this.activeDate.isSame(new Date());
        this.cdr.markForCheck();
    }
}
TDSCalendarHeaderComponent.ɵfac = function TDSCalendarHeaderComponent_Factory(t) { return new (t || TDSCalendarHeaderComponent)(i0.ɵɵdirectiveInject(i1.TDSI18nService), i0.ɵɵdirectiveInject(i1.DateHelperService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
TDSCalendarHeaderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCalendarHeaderComponent, selectors: [["tds-calendar-header"]], hostAttrs: [1, "tds-fullcalendar-header", "tds-picker-calendar-header", "w-full", "flex", "items-center", "justify-between", "py-2", "px-3"], inputs: { tdsMode: "tdsMode", tdsFullscreen: "tdsFullscreen", tdsViewDate: "tdsViewDate" }, outputs: { tdsModeChange: "tdsModeChange", tdsActiveDateChange: "tdsActiveDateChange", tdsViewDateChange: "tdsViewDateChange" }, exportAs: ["tdsCalendarHeader"], features: [i0.ɵɵNgOnChangesFeature], decls: 14, vars: 12, consts: [[1, "tds-calendar-header-left", "flex", "items-center"], [1, "mr-2", 3, "ngModel", "ngModelChange"], ["tds-radio-button", "", 3, "value"], ["tds-button-flat", "", "color", "primary", 3, "click", 4, "ngIf"], [1, "tds-calendar-header-middle"], [3, "tdsViewDate", "tdsMode", "tdsViewDateChange"], [1, "tds-calendar-header-right", "min-w-[30%]"], ["tds-button-flat", "", "color", "primary", 3, "click"], [1, "flex", "items-center"]], template: function TDSCalendarHeaderComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵelementStart(0, "div", 0)(1, "tds-radio-group", 1);
            i0.ɵɵlistener("ngModelChange", function TDSCalendarHeaderComponent_Template_tds_radio_group_ngModelChange_1_listener($event) { return ctx.tdsMode = $event; })("ngModelChange", function TDSCalendarHeaderComponent_Template_tds_radio_group_ngModelChange_1_listener($event) { return ctx.onModeChange($event); });
            i0.ɵɵelementStart(2, "label", 2);
            i0.ɵɵtext(3);
            i0.ɵɵelementEnd();
            i0.ɵɵelementStart(4, "label", 2);
            i0.ɵɵtext(5);
            i0.ɵɵelementEnd();
            i0.ɵɵelementStart(6, "label", 2);
            i0.ɵɵtext(7);
            i0.ɵɵelementEnd();
            i0.ɵɵelementStart(8, "label", 2);
            i0.ɵɵtext(9);
            i0.ɵɵelementEnd()();
            i0.ɵɵtemplate(10, TDSCalendarHeaderComponent_button_10_Template, 3, 1, "button", 3);
            i0.ɵɵelementEnd();
            i0.ɵɵelementStart(11, "div", 4)(12, "tds-calendar-datepicker", 5);
            i0.ɵɵlistener("tdsViewDateChange", function TDSCalendarHeaderComponent_Template_tds_calendar_datepicker_tdsViewDateChange_12_listener($event) { return ctx.onValueChange($event); });
            i0.ɵɵelementEnd()();
            i0.ɵɵelement(13, "div", 6);
        }
        if (rf & 2) {
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("ngModel", ctx.tdsMode);
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("value", "date");
            i0.ɵɵadvance(1);
            i0.ɵɵtextInterpolate(ctx.dayTypeText);
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("value", "week");
            i0.ɵɵadvance(1);
            i0.ɵɵtextInterpolate(ctx.weekTypeText);
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("value", "month");
            i0.ɵɵadvance(1);
            i0.ɵɵtextInterpolate(ctx.monthTypeText);
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("value", "year");
            i0.ɵɵadvance(1);
            i0.ɵɵtextInterpolate(ctx.yearTypeText);
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("ngIf", ctx.hiddenTodaybtn);
            i0.ɵɵadvance(2);
            i0.ɵɵproperty("tdsViewDate", ctx.tdsViewDate)("tdsMode", ctx.tdsMode);
        }
    }, directives: [i2$1.TDSRadioGroupComponent, i4.NgControlStatus, i4.NgModel, i2$1.TDSRadioComponent, i2$1.TDSRadioButtonDirective, i2$2.NgIf, i5.TDSButtonFlatComponent, TDSCalendarDatepickerComponent], encapsulation: 2, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarHeaderComponent, [{
            type: Component,
            args: [{
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'tds-calendar-header',
                    exportAs: 'tdsCalendarHeader',
                    template: `
    <div class="tds-calendar-header-left flex items-center ">
          <tds-radio-group class="mr-2" [(ngModel)]="tdsMode" (ngModelChange)="onModeChange($event)">
            <label tds-radio-button [value]="'date'">{{dayTypeText}}</label>
            <label tds-radio-button [value]="'week'">{{weekTypeText}}</label>
            <label tds-radio-button [value]="'month'">{{monthTypeText}}</label>
            <label tds-radio-button [value]="'year'">{{yearTypeText}}</label>            
          </tds-radio-group>
          <button tds-button-flat color="primary" *ngIf="hiddenTodaybtn" (click)="onToday($event)">
            <span class="flex items-center"> {{toDayTypeText}} </span>
          </button>
        </div>
        <div class="tds-calendar-header-middle">
          <tds-calendar-datepicker [tdsViewDate]="tdsViewDate" [tdsMode]="tdsMode" (tdsViewDateChange)="onValueChange($event)"></tds-calendar-datepicker>
        </div>
        <div class="tds-calendar-header-right min-w-[30%]">
        <!-- <tds-radio-group [(ngModel)]="tdsMode">
            <label tds-radio-button [value]="'date'">Hangzhou</label>
            <label tds-radio-button [value]="'week'">Chengdu</label>
            <label tds-radio-button [value]="'month'">Shanghai</label>
            <label tds-radio-button [value]="'year'">Beijing</label>            
          </tds-radio-group> -->
        </div>
  `,
                    host: {
                        class: 'tds-fullcalendar-header tds-picker-calendar-header w-full flex items-center justify-between py-2 px-3',
                    }
                }]
        }], function () { return [{ type: i1.TDSI18nService }, { type: i1.DateHelperService }, { type: i0.ChangeDetectorRef }]; }, { tdsMode: [{
                type: Input
            }], tdsFullscreen: [{
                type: Input
            }], tdsViewDate: [{
                type: Input
            }], tdsModeChange: [{
                type: Output
            }], tdsActiveDateChange: [{
                type: Output
            }], tdsViewDateChange: [{
                type: Output
            }] });
})();

var DAYS_OF_WEEK;
(function (DAYS_OF_WEEK) {
    DAYS_OF_WEEK[DAYS_OF_WEEK["SUNDAY"] = 0] = "SUNDAY";
    DAYS_OF_WEEK[DAYS_OF_WEEK["MONDAY"] = 1] = "MONDAY";
    DAYS_OF_WEEK[DAYS_OF_WEEK["TUESDAY"] = 2] = "TUESDAY";
    DAYS_OF_WEEK[DAYS_OF_WEEK["WEDNESDAY"] = 3] = "WEDNESDAY";
    DAYS_OF_WEEK[DAYS_OF_WEEK["THURSDAY"] = 4] = "THURSDAY";
    DAYS_OF_WEEK[DAYS_OF_WEEK["FRIDAY"] = 5] = "FRIDAY";
    DAYS_OF_WEEK[DAYS_OF_WEEK["SATURDAY"] = 6] = "SATURDAY";
})(DAYS_OF_WEEK || (DAYS_OF_WEEK = {}));
const DEFAULT_WEEKEND_DAYS = [
    DAYS_OF_WEEK.SUNDAY,
    DAYS_OF_WEEK.SATURDAY,
];
const DAYS_IN_WEEK = 7;
const HOURS_IN_DAY = 24;
const MINUTES_IN_HOUR = 60;
const SECONDS_IN_DAY = 60 * 60 * 24;
function sanitiseHours(hours) {
    return Math.max(Math.min(23, hours), 0);
}
function sanitiseMinutes(minutes) {
    return Math.max(Math.min(59, minutes), 0);
}
function getTimezoneOffset(date) {
    return new Date(date).getTimezoneOffset();
}
function getDayViewHourGrid({ viewDate, hourSegments, hourDuration, dayStart, dayEnd }) {
    const hours = [];
    let startOfView = setMinutes(setHours(startOfDay(viewDate), sanitiseHours(dayStart.hour)), sanitiseMinutes(dayStart.minute));
    let endOfView = setMinutes(setHours(startOfMinute(endOfDay(viewDate)), sanitiseHours(dayEnd.hour)), sanitiseMinutes(dayEnd.minute));
    const segmentDuration = (hourDuration || MINUTES_IN_HOUR) / hourSegments;
    let startOfViewDay = startOfDay(viewDate);
    const endOfViewDay = endOfDay(viewDate);
    let dateAdjustment = (d) => d;
    // this means that we change from or to DST on this day and that's going to cause problems so we bump the date
    if (getTimezoneOffset(startOfViewDay) !==
        getTimezoneOffset(endOfViewDay)) {
        startOfViewDay = addDays(startOfViewDay, 1);
        startOfView = addDays(startOfView, 1);
        endOfView = addDays(endOfView, 1);
        dateAdjustment = (d) => addDays(d, -1);
    }
    const dayDuration = hourDuration
        ? (HOURS_IN_DAY * 60) / hourDuration
        : MINUTES_IN_HOUR;
    for (let i = 0; i < dayDuration; i++) {
        const segments = [];
        for (let j = 0; j < hourSegments; j++) {
            const date = addMinutes(addMinutes(startOfView, i * (hourDuration || MINUTES_IN_HOUR)), j * segmentDuration);
            if (date >= startOfView && date < endOfView) {
                segments.push({
                    date: dateAdjustment(date),
                    displayDate: date,
                    isStart: j === 0,
                });
            }
        }
        if (segments.length > 0) {
            hours.push({ segments });
        }
    }
    return hours;
}
const trackByHourSegment = (index, segment) => segment.date.toISOString();
function isEventIsPeriod({ event, periodStart, periodEnd }) {
    const eventStart = event.start;
    const eventEnd = event.end || event.start;
    if (eventStart > periodStart && eventStart < periodEnd) {
        return true;
    }
    if (eventEnd > periodStart && eventEnd < periodEnd) {
        return true;
    }
    if (eventStart < periodStart && eventEnd > periodEnd) {
        return true;
    }
    if (isSameSecond(eventStart, periodStart) ||
        isSameSecond(eventStart, periodEnd)) {
        return true;
    }
    if (isSameSecond(eventEnd, periodStart) ||
        isSameSecond(eventEnd, periodEnd)) {
        return true;
    }
    return false;
}
function getEventsInPeriod({ events, periodStart, periodEnd }) {
    return events.filter((event) => isEventIsPeriod({ event, periodStart, periodEnd }));
}
function getOverLappingWeekViewEvents(events, top, bottom) {
    return events.filter((previousEvent) => {
        const previousEventTop = previousEvent.top;
        const previousEventBottom = previousEvent.top + previousEvent.height;
        if (top < previousEventBottom && previousEventBottom < bottom) {
            return true;
        }
        else if (top < previousEventTop && previousEventTop < bottom) {
            return true;
        }
        else if (previousEventTop <= top && bottom <= previousEventBottom) {
            return true;
        }
        return false;
    });
}
function getDayView({ events, viewDate, hourSegments, dayStart, dayEnd, eventWidth, segmentHeight, hourDuration, minimumEventHeight }) {
    const startOfView = setMinutes(setHours(startOfDay(viewDate), sanitiseHours(dayStart.hour)), sanitiseMinutes(dayStart.minute));
    const endOfView = setMinutes(setHours(startOfMinute(endOfDay(viewDate)), sanitiseHours(dayEnd.hour)), sanitiseMinutes(dayEnd.minute));
    endOfView.setSeconds(59, 999);
    const previousDayEvents = [];
    const eventsInPeriod = getEventsInPeriod({
        events: events === null || events === void 0 ? void 0 : events.filter((event) => !event.allDay),
        periodStart: startOfView,
        periodEnd: endOfView,
    });
    const dayViewEvents = eventsInPeriod
        .sort((eventA, eventB) => {
        return eventA.start.valueOf() - eventB.start.valueOf();
    })
        .map((event) => {
        const eventStart = event.start;
        const eventEnd = event.end || eventStart;
        const startsBeforeDay = eventStart < startOfView;
        const endsAfterDay = eventEnd > endOfView;
        const hourHeightModifier = (hourSegments * segmentHeight) / (hourDuration || MINUTES_IN_HOUR);
        let top = 0;
        if (eventStart > startOfView) {
            // adjust the difference in minutes if the user's offset is different between the start of the day and the event (e.g. when going to or from DST)
            const eventOffset = getTimezoneOffset(eventStart);
            const startOffset = getTimezoneOffset(startOfView);
            const diff = startOffset - eventOffset;
            top += differenceInMinutes(eventStart, startOfView) + diff;
        }
        top *= hourHeightModifier;
        top = Math.floor(top);
        const startDate = startsBeforeDay ? startOfView : eventStart;
        const endDate = endsAfterDay ? endOfView : eventEnd;
        const timezoneOffset = getTimezoneOffset(startDate) -
            getTimezoneOffset(endDate);
        let height = differenceInMinutes(endDate, startDate) + timezoneOffset;
        if (!event.end) {
            height = segmentHeight;
        }
        else {
            height *= hourHeightModifier;
        }
        if (minimumEventHeight && height < minimumEventHeight) {
            height = minimumEventHeight;
        }
        height = Math.floor(height);
        const bottom = top + height;
        const overlappingPreviousEvents = getOverLappingWeekViewEvents(previousDayEvents, top, bottom);
        let left = 0;
        while (overlappingPreviousEvents.some((previousEvent) => previousEvent.left === left)) {
            left += eventWidth;
        }
        const dayEvent = {
            event,
            height,
            width: eventWidth,
            top,
            left,
            startsBeforeDay,
            endsAfterDay,
        };
        previousDayEvents.push(dayEvent);
        return dayEvent;
    });
    const width = Math.max(...dayViewEvents.map((event) => event.left + event.width));
    const allDayEvents = getEventsInPeriod({
        events: events === null || events === void 0 ? void 0 : events.filter((event) => event.allDay),
        periodStart: startOfDay(startOfView),
        periodEnd: endOfDay(endOfView),
    });
    return {
        events: dayViewEvents,
        width,
        allDayEvents,
        period: {
            events: eventsInPeriod,
            start: startOfView,
            end: endOfView,
        },
    };
}

const _c0$3 = ["*"];
class TDSCalendarEventComponent {
    constructor() {
        this.tdsStartDate = new Date();
        this.tdsEndDate = new Date();
        this.changes = new Subject();
    }
    ngOnInit() {
    }
    ngOnChanges() {
        this.changes.next();
    }
}
TDSCalendarEventComponent.ɵfac = function TDSCalendarEventComponent_Factory(t) { return new (t || TDSCalendarEventComponent)(); };
TDSCalendarEventComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCalendarEventComponent, selectors: [["tds-calendar-event"]], inputs: { tdsStartDate: "tdsStartDate", tdsEndDate: "tdsEndDate", tdsData: "tdsData", tdsTemplate: "tdsTemplate" }, features: [i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0$3, decls: 1, vars: 0, template: function TDSCalendarEventComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵprojectionDef();
            i0.ɵɵprojection(0);
        }
    }, encapsulation: 2, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarEventComponent, [{
            type: Component,
            args: [{
                    selector: 'tds-calendar-event',
                    template: `
    <ng-content></ng-content>
  `,
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], function () { return []; }, { tdsStartDate: [{
                type: Input
            }], tdsEndDate: [{
                type: Input
            }], tdsData: [{
                type: Input
            }], tdsTemplate: [{
                type: Input
            }] });
})();

function TDSCalendarCurrentTimeComponent_ng_template_0_div_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 3)(1, "div", 4)(2, "div", 5);
        i0.ɵɵtext(3);
        i0.ɵɵpipe(4, "date");
        i0.ɵɵelementEnd()()();
    }
    if (rf & 2) {
        const ctx_r12 = i0.ɵɵnextContext();
        const topPx_r9 = ctx_r12.topPx;
        const now_r10 = ctx_r12.now;
        const ctx_r11 = i0.ɵɵnextContext();
        i0.ɵɵstyleProp("top", topPx_r9, "px")("left", ctx_r11.widthColTime, "px");
        i0.ɵɵadvance(3);
        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(4, 5, now_r10, "HH:mm"));
    }
}
function TDSCalendarCurrentTimeComponent_ng_template_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵtemplate(0, TDSCalendarCurrentTimeComponent_ng_template_0_div_0_Template, 5, 8, "div", 2);
    }
    if (rf & 2) {
        const isVisible_r8 = ctx.isVisible;
        i0.ɵɵproperty("ngIf", isVisible_r8);
    }
}
function TDSCalendarCurrentTimeComponent_ng_template_2_Template(rf, ctx) { }
const _c0$2 = function (a0, a1, a2, a3, a4, a5, a6, a7) { return { columnDate: a0, dayStartHour: a1, dayStartMinute: a2, dayEndHour: a3, dayEndMinute: a4, isVisible: a5, topPx: a6, now: a7 }; };
class TDSCalendarCurrentTimeComponent {
    constructor(zone, cdr, destroy$) {
        this.zone = zone;
        this.cdr = cdr;
        this.destroy$ = destroy$;
        this.columnDate$ = new BehaviorSubject(undefined);
        //1 phút hiển thị 1 lần
        this.marker$ = interval(60 * 1000).pipe(
        // switchMap(() => ),
        startWith(0), switchMapTo(this.columnDate$), map((columnDate) => {
            const now = new Date();
            const startOfDay = setMinutes(setHours(columnDate, this.dayStartHour), this.dayStartMinute);
            const endOfDay = setMinutes(setHours(columnDate, this.dayEndHour), this.dayEndMinute);
            const hourHeightModifier = (this.hourSegments * this.hourSegmentHeight) /
                (this.hourDuration || 60);
            return {
                isVisible: isSameDay(columnDate, now) &&
                    now >= startOfDay &&
                    now <= endOfDay,
                top: differenceInMinutes(now, startOfDay) *
                    hourHeightModifier,
                now: now
            };
        }), takeUntil(this.destroy$));
    }
    ngOnChanges(changes) {
        if (changes.columnDate) {
            this.columnDate$.next(changes.columnDate.currentValue);
        }
    }
}
TDSCalendarCurrentTimeComponent.ɵfac = function TDSCalendarCurrentTimeComponent_Factory(t) { return new (t || TDSCalendarCurrentTimeComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1$1.TDSDestroyService)); };
TDSCalendarCurrentTimeComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCalendarCurrentTimeComponent, selectors: [["tds-calendar-current-time"]], inputs: { columnDate: "columnDate", dayStartHour: "dayStartHour", dayStartMinute: "dayStartMinute", dayEndHour: "dayEndHour", dayEndMinute: "dayEndMinute", hourSegments: "hourSegments", hourDuration: "hourDuration", hourSegmentHeight: "hourSegmentHeight", customTemplate: "customTemplate", widthColTime: "widthColTime" }, features: [i0.ɵɵProvidersFeature([
            TDSDestroyService
        ]), i0.ɵɵNgOnChangesFeature], decls: 6, vars: 17, consts: [["defaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "cal-current-time-marker bg-primary-1 absolute inset-0 h-px ", 3, "top", "left", 4, "ngIf"], [1, "cal-current-time-marker", "bg-primary-1", "absolute", "inset-0", "h-px"], [1, "w-full", "flex", "items-center", "justify-center", "relative"], [1, "absolute", "-left-[60px]", "text-primary-1", "z-10", "bg-white"]], template: function TDSCalendarCurrentTimeComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵtemplate(0, TDSCalendarCurrentTimeComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
            i0.ɵɵtemplate(2, TDSCalendarCurrentTimeComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
            i0.ɵɵpipe(3, "async");
            i0.ɵɵpipe(4, "async");
            i0.ɵɵpipe(5, "async");
        }
        if (rf & 2) {
            const _r0 = i0.ɵɵreference(1);
            let tmp_1_0;
            i0.ɵɵadvance(2);
            i0.ɵɵproperty("ngTemplateOutlet", ctx.customTemplate || _r0)("ngTemplateOutletContext", i0.ɵɵpureFunction8(8, _c0$2, ctx.columnDate, ctx.dayStartHour, ctx.dayStartMinute, ctx.dayEndHour, ctx.dayEndMinute, (tmp_1_0 = i0.ɵɵpipeBind1(3, 2, ctx.marker$)) == null ? null : tmp_1_0.isVisible, (tmp_1_0 = i0.ɵɵpipeBind1(4, 4, ctx.marker$)) == null ? null : tmp_1_0.top, (tmp_1_0 = i0.ɵɵpipeBind1(5, 6, ctx.marker$)) == null ? null : tmp_1_0.now));
        }
    }, directives: [i2$2.NgIf, i2$2.NgTemplateOutlet], pipes: [i2$2.DatePipe, i2$2.AsyncPipe], encapsulation: 2, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarCurrentTimeComponent, [{
            type: Component,
            args: [{ selector: 'tds-calendar-current-time', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        TDSDestroyService
                    ], template: "<ng-template #defaultTemplate let-columnDate=\"columnDate\" let-dayStartHour=\"dayStartHour\"\n    let-dayStartMinute=\"dayStartMinute\" let-dayEndHour=\"dayEndHour\" let-dayEndMinute=\"dayEndMinute\"\n    let-isVisible=\"isVisible\" let-topPx=\"topPx\" let-now=\"now\">\n\n    <div class=\"cal-current-time-marker bg-primary-1 absolute inset-0 h-px \" *ngIf=\"isVisible\"\n        [style.top.px]=\"topPx\" [style.left.px]=\"widthColTime\">\n        <div class=\"w-full flex items-center justify-center relative \">\n            <div class=\"absolute -left-[60px] text-primary-1 z-10  bg-white\">{{ now | date:\"HH:mm\"}}</div>            \n        </div>\n    </div>\n</ng-template>\n<ng-template [ngTemplateOutlet]=\"customTemplate || defaultTemplate\" [ngTemplateOutletContext]=\"{\n  columnDate: columnDate,\n  dayStartHour: dayStartHour,\n  dayStartMinute: dayStartMinute,\n  dayEndHour: dayEndHour,\n  dayEndMinute: dayEndMinute,\n  isVisible: (marker$ | async)?.isVisible,\n  topPx: (marker$ | async)?.top,\n  now: (marker$ | async)?.now\n}\">\n</ng-template>" }]
        }], function () { return [{ type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i1$1.TDSDestroyService }]; }, { columnDate: [{
                type: Input
            }], dayStartHour: [{
                type: Input
            }], dayStartMinute: [{
                type: Input
            }], dayEndHour: [{
                type: Input
            }], dayEndMinute: [{
                type: Input
            }], hourSegments: [{
                type: Input
            }], hourDuration: [{
                type: Input
            }], hourSegmentHeight: [{
                type: Input
            }], customTemplate: [{
                type: Input
            }], widthColTime: [{
                type: Input
            }] });
})();

function TDSCalendarModeDayComponent_ng_template_6_ng_template_0_tr_0_Template(rf, ctx) {
    if (rf & 1) {
        const _r11 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "tr", 9)(1, "td", 10);
        i0.ɵɵtext(2);
        i0.ɵɵpipe(3, "date");
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(4, "td", 11);
        i0.ɵɵlistener("click", function TDSCalendarModeDayComponent_ng_template_6_ng_template_0_tr_0_Template_td_click_4_listener($event) { i0.ɵɵrestoreView(_r11); const segment_r6 = i0.ɵɵnextContext().$implicit; const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.onClickSegment($event, segment_r6); });
        i0.ɵɵelementEnd()();
    }
    if (rf & 2) {
        const segment_r6 = i0.ɵɵnextContext().$implicit;
        const week_r2 = i0.ɵɵnextContext().$implicit;
        const ctx_r7 = i0.ɵɵnextContext();
        i0.ɵɵadvance(1);
        i0.ɵɵattribute("rowspan", week_r2.segments.length);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", i0.ɵɵpipeBind2(3, 4, segment_r6.displayDate, "HH:mm"), " ");
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("height", ctx_r7.hourSegmentHeight, "px");
    }
}
function TDSCalendarModeDayComponent_ng_template_6_ng_template_0_tr_1_Template(rf, ctx) {
    if (rf & 1) {
        const _r16 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "tr", 12)(1, "td", 11);
        i0.ɵɵlistener("click", function TDSCalendarModeDayComponent_ng_template_6_ng_template_0_tr_1_Template_td_click_1_listener($event) { i0.ɵɵrestoreView(_r16); const segment_r6 = i0.ɵɵnextContext().$implicit; const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.onClickSegment($event, segment_r6); });
        i0.ɵɵelementEnd()();
    }
    if (rf & 2) {
        const ctx_r8 = i0.ɵɵnextContext(3);
        i0.ɵɵadvance(1);
        i0.ɵɵstyleProp("height", ctx_r8.hourSegmentHeight, "px");
    }
}
function TDSCalendarModeDayComponent_ng_template_6_ng_template_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵtemplate(0, TDSCalendarModeDayComponent_ng_template_6_ng_template_0_tr_0_Template, 5, 7, "tr", 7);
        i0.ɵɵtemplate(1, TDSCalendarModeDayComponent_ng_template_6_ng_template_0_tr_1_Template, 2, 2, "tr", 8);
    }
    if (rf & 2) {
        const segment_r6 = ctx.$implicit;
        i0.ɵɵproperty("ngIf", segment_r6.isStart);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !segment_r6.isStart);
    }
}
function TDSCalendarModeDayComponent_ng_template_6_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵtemplate(0, TDSCalendarModeDayComponent_ng_template_6_ng_template_0_Template, 2, 2, "ng-template", 6);
    }
    if (rf & 2) {
        const week_r2 = ctx.$implicit;
        const ctx_r0 = i0.ɵɵnextContext();
        i0.ɵɵproperty("ngForOf", week_r2.segments)("ngForTrackBy", ctx_r0.trackByHourSegment);
    }
}
function TDSCalendarModeDayComponent_div_8_ng_template_3_ng_container_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtext(1);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const dataEvent_r18 = i0.ɵɵnextContext().$implicit;
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1("", dataEvent_r18.event.template, " ");
    }
}
function TDSCalendarModeDayComponent_div_8_ng_template_3_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 16);
        i0.ɵɵtemplate(1, TDSCalendarModeDayComponent_div_8_ng_template_3_ng_container_1_Template, 2, 1, "ng-container", 17);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const dataEvent_r18 = ctx.$implicit;
        i0.ɵɵstyleProp("height", dataEvent_r18.height, "px")("margin-top", dataEvent_r18.top, "px")("margin-left", dataEvent_r18.left, "px")("width", dataEvent_r18.width, "px");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("tdsStringTemplateOutlet", dataEvent_r18.event.template);
    }
}
function TDSCalendarModeDayComponent_div_8_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 13)(1, "div", 14);
        i0.ɵɵelement(2, "div", 15);
        i0.ɵɵtemplate(3, TDSCalendarModeDayComponent_div_8_ng_template_3_Template, 2, 9, "ng-template", 3);
        i0.ɵɵelementEnd()();
    }
    if (rf & 2) {
        const ctx_r1 = i0.ɵɵnextContext();
        i0.ɵɵstyleProp("left", ctx_r1.widthColTime, "px");
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("width", ctx_r1.maxWidth, "px");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx_r1.dayView.events);
    }
}
const _c0$1 = ["*"];
class TDSCalendarModeDayComponent {
    constructor(destroy$, cdr, elementRef) {
        this.destroy$ = destroy$;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.viewDate = new Date();
        this.start = new CandyDate();
        /**
         * Giờ kết thúc ngày trong thời gian 24 giờ. Phải là 0-23
         */
        this.dayEndHour = 17;
        /**
        * Phút cuối ngày. Phải là 0-59
        */
        this.dayEndMinute = 30;
        /**
        * Giờ bắt đầu ngày trong thời gian 24 giờ. Phải là 0-23
        */
        this.dayStartHour = 8;
        /**
        * Phút bắt đầu ngày. Phải là 0-59
        */
        this.dayStartMinute = 0;
        /**
         * The number of segments in an hour. Must divide equally into 60.
         */
        this.hourSegments = 4;
        /**
         * The height in pixels of each hour segment
         */
        this.hourSegmentHeight = 30;
        /**
         * The minimum height in pixels of each event
         */
        this.minimumEventHeight = 100;
        /**
        * The width in pixels of each hour segment
        */
        this.hourSegmentWidth = 200;
        /**
         * The duration of each segment group in minutes
         */
        this.hourDuration = 60;
        this.widthColTime = 80;
        /**
         * @hidden
         */
        this.trackByHourSegment = trackByHourSegment;
        this.weekViewHour = [];
        this.activeDate = new CandyDate();
        this.maxWidth = 0;
        this.widthTable = null;
        this.listOfTemplateEventItem$ = new BehaviorSubject([]);
        this.tdsClickSegment = new EventEmitter();
        this.listOfEvent = [];
        this.paddingLeftContent = 16;
    }
    ngOnInit() {
        this.listOfTemplateEventItem$.pipe(takeUntil(this.destroy$))
            .subscribe((value) => {
            let dayStart = {
                hour: this.dayStartHour,
                minute: this.dayStartMinute,
            };
            let dayEnd = {
                hour: this.dayEndHour,
                minute: this.dayEndMinute,
            };
            this.listOfEvent = [...value];
            this.dayView = getDayView({
                events: [...value], viewDate: this.viewDate, hourSegments: this.hourSegments, dayStart: dayStart,
                dayEnd: dayEnd, eventWidth: this.hourSegmentWidth, hourDuration: this.hourDuration, minimumEventHeight: this.minimumEventHeight, segmentHeight: this.hourSegmentHeight
            });
            let width = this.paddingLeftContent;
            let widthComp = this.elementRef.nativeElement.getBoundingClientRect().width;
            this.dayView.events.forEach(e => {
                const widtCol = e.left + e.width;
                if (width < widtCol) {
                    width = widtCol;
                }
            });
            this.widthTable = width > widthComp ? width + this.widthColTime + this.paddingLeftContent : null;
            this.maxWidth = width == 0 ? 0 : width;
            this.cdr.markForCheck();
        });
    }
    ngOnChanges(changes) {
        if (changes.viewDate) {
            this.buildTime();
            this.cdr.markForCheck();
        }
    }
    ngAfterContentInit() {
        this.listEventComp.changes.pipe(startWith(true), switchMap(() => merge(...[
            this.listEventComp.changes,
            ...this.listEventComp.map(option => option.changes),
        ]).pipe(startWith(true))), takeUntil(this.destroy$)).subscribe(() => {
            const listOfEventInterface = this.listEventComp.toArray().map(item => {
                const { tdsEndDate, tdsStartDate, tdsData, tdsTemplate } = item;
                return {
                    start: tdsStartDate,
                    end: tdsEndDate,
                    data: tdsData,
                    template: tdsTemplate,
                    allDay: false
                };
            });
            this.listOfTemplateEventItem$.next(listOfEventInterface);
        });
    }
    onClickSegment(e, date) {
        e.stopPropagation();
        e.preventDefault();
        this.tdsClickSegment.emit(date);
    }
    buildTime() {
        this.activeDate = new CandyDate(this.viewDate);
        let dayStart = {
            hour: this.dayStartHour,
            minute: this.dayStartMinute,
        };
        let dayEnd = {
            hour: this.dayEndHour,
            minute: this.dayEndMinute,
        };
        this.weekViewHour = getDayViewHourGrid({
            dayStart: dayStart,
            dayEnd: dayEnd,
            hourDuration: this.hourDuration,
            viewDate: this.viewDate,
            hourSegments: this.hourSegments
        });
        this.listOfTemplateEventItem$.next(this.listOfEvent);
    }
}
TDSCalendarModeDayComponent.ɵfac = function TDSCalendarModeDayComponent_Factory(t) { return new (t || TDSCalendarModeDayComponent)(i0.ɵɵdirectiveInject(i1$1.TDSDestroyService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSCalendarModeDayComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCalendarModeDayComponent, selectors: [["tds-calendar-mode-day"]], contentQueries: function TDSCalendarModeDayComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
            i0.ɵɵcontentQuery(dirIndex, TDSCalendarEventComponent, 5);
        }
        if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.listEventComp = _t);
        }
    }, hostAttrs: [1, "w-full", "block", "border", "border-neutral-2-200"], inputs: { viewDate: "viewDate", locale: "locale", start: "start", dayEndHour: "dayEndHour", dayEndMinute: "dayEndMinute", dayStartHour: "dayStartHour", dayStartMinute: "dayStartMinute", hourSegments: "hourSegments", hourSegmentHeight: "hourSegmentHeight", minimumEventHeight: "minimumEventHeight", hourSegmentWidth: "hourSegmentWidth", hourDuration: "hourDuration", widthColTime: "widthColTime", currentTimeMarkerTemplate: "currentTimeMarkerTemplate" }, outputs: { tdsClickSegment: "tdsClickSegment" }, features: [i0.ɵɵProvidersFeature([TDSDestroyService]), i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0$1, decls: 10, vars: 15, consts: [[1, "w-full", "h-full", "relative", "overflow-auto", "tds-custom-scroll"], [1, "table-fixed", "min-w-full"], [3, "width"], ["ngFor", "", 3, "ngForOf"], [3, "columnDate", "dayStartHour", "dayStartMinute", "dayEndHour", "dayEndMinute", "hourSegments", "hourDuration", "hourSegmentHeight", "customTemplate", "widthColTime"], ["class", "tds-calendar-event-container pointer-events-none absolute inset-0 pl-4", 3, "left", 4, "ngIf"], ["ngFor", "", 3, "ngForOf", "ngForTrackBy"], ["class", "tds-calendar-segment-start", 4, "ngIf"], ["class", "tds-calendar-segment", 4, "ngIf"], [1, "tds-calendar-segment-start"], [1, "tds-calendar-col-lock", "align-top", "text-center", "sticky", "left-0", "z-10", "bg-white"], [1, "cursor-pointer", 3, "click"], [1, "tds-calendar-segment"], [1, "tds-calendar-event-container", "pointer-events-none", "absolute", "inset-0", "pl-4"], [1, "w-full", "h-full", "relative", "pointer-events-none"], [1, "h-px", "pointer-events-none"], [1, "absolute", "pointer-events-auto"], [4, "tdsStringTemplateOutlet"]], template: function TDSCalendarModeDayComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵprojectionDef();
            i0.ɵɵelementStart(0, "div", 0)(1, "table", 1)(2, "colgroup");
            i0.ɵɵelement(3, "col", 2)(4, "col");
            i0.ɵɵelementEnd();
            i0.ɵɵelementStart(5, "tbody");
            i0.ɵɵtemplate(6, TDSCalendarModeDayComponent_ng_template_6_Template, 1, 2, "ng-template", 3);
            i0.ɵɵelementEnd()();
            i0.ɵɵelement(7, "tds-calendar-current-time", 4);
            i0.ɵɵtemplate(8, TDSCalendarModeDayComponent_div_8_Template, 4, 5, "div", 5);
            i0.ɵɵelementEnd();
            i0.ɵɵprojection(9);
        }
        if (rf & 2) {
            i0.ɵɵadvance(1);
            i0.ɵɵstyleProp("width", ctx.widthTable, "px");
            i0.ɵɵadvance(2);
            i0.ɵɵproperty("width", ctx.widthColTime);
            i0.ɵɵadvance(3);
            i0.ɵɵproperty("ngForOf", ctx.weekViewHour);
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("columnDate", ctx.viewDate)("dayStartHour", ctx.dayStartHour)("dayStartMinute", ctx.dayStartMinute)("dayEndHour", ctx.dayEndHour)("dayEndMinute", ctx.dayEndMinute)("hourSegments", ctx.hourSegments)("hourDuration", ctx.hourDuration)("hourSegmentHeight", ctx.hourSegmentHeight)("customTemplate", ctx.currentTimeMarkerTemplate)("widthColTime", ctx.widthColTime);
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("ngIf", ctx.dayView);
        }
    }, directives: [i2$2.NgForOf, i2$2.NgIf, TDSCalendarCurrentTimeComponent, i4$1.TDSStringTemplateOutletDirective], pipes: [i2$2.DatePipe], encapsulation: 2, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarModeDayComponent, [{
            type: Component,
            args: [{ selector: 'tds-calendar-mode-day', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, providers: [TDSDestroyService], host: {
                        class: "w-full block border  border-neutral-2-200"
                    }, template: "<div class=\"w-full h-full  relative overflow-auto tds-custom-scroll\">\n    <table class=\"table-fixed min-w-full\" [style.width.px]=\"widthTable\">\n        <colgroup>\n            <col [width]=\"widthColTime\">\n            <col>\n        </colgroup>\n        <tbody>\n            <ng-template ngFor [ngForOf]=\"weekViewHour\" let-week let-idx=\"index\" let-total=\"count\">               \n                <ng-template ngFor [ngForOf]=\"week.segments\" let-segment [ngForTrackBy]=\"trackByHourSegment\">\n                    <tr  *ngIf=\"segment.isStart\" class=\"tds-calendar-segment-start\">\n                        <td [attr.rowspan]=\"week.segments.length\" class=\"tds-calendar-col-lock align-top text-center sticky left-0 z-10 bg-white \">\n                            {{segment.displayDate | date:\"HH:mm\"}}\n                        </td>\n                        <td class=\"cursor-pointer\" [style.height.px]=\"hourSegmentHeight\" (click)=\"onClickSegment($event,segment)\">\n                            \n                        </td>\n                    </tr>\n                    <tr *ngIf=\"!segment.isStart\" class=\"tds-calendar-segment\">\n                        <td class=\"cursor-pointer\" [style.height.px]=\"hourSegmentHeight\" (click)=\"onClickSegment($event,segment)\">                           \n                        </td>\n                    </tr>                    \n                </ng-template>\n            </ng-template>\n        </tbody>\n    </table>\n    <tds-calendar-current-time\n    [columnDate]=\"viewDate\"\n    [dayStartHour]=\"dayStartHour\"\n    [dayStartMinute]=\"dayStartMinute\"\n    [dayEndHour]=\"dayEndHour\"\n    [dayEndMinute]=\"dayEndMinute\"\n    [hourSegments]=\"hourSegments\"\n    [hourDuration]=\"hourDuration\"\n    [hourSegmentHeight]=\"hourSegmentHeight\"\n    [customTemplate]=\"currentTimeMarkerTemplate\"\n    [widthColTime]=\"widthColTime\"\n  ></tds-calendar-current-time>\n    <!-- <ng-template ngFor [ngForOf]=\"weekViewHour\" let-week let-idx=\"index\" let-total=\"count\">\n        <ng-template ngFor [ngForOf]=\"week.segments\" let-segment [ngForTrackBy]=\"trackByHourSegment\">\n            <div class=\"w-full flex\" [ngClass]=\"{'border-t border-neutral-2-200':segment.isStart}\"\n                [style.height.px]=\"hourSegmentHeight\">\n                <div class=\"w-20 text-center\">\n                    <span *ngIf=\"segment.isStart\">\n                        {{segment.displayDate | date:\"HH:mm\"}}\n                    </span>\n                </div>\n                <div class=\"flex-auto\">\n\n                </div>\n            </div>\n        </ng-template>\n    </ng-template> -->\n    <div class=\"tds-calendar-event-container pointer-events-none absolute inset-0 pl-4\" [style.left.px]=\"widthColTime\" *ngIf=\"dayView\">\n        <div class=\"w-full h-full relative pointer-events-none\">\n            <div class=\"h-px pointer-events-none\" [style.width.px]=\"maxWidth\"></div>\n            <ng-template ngFor [ngForOf]=\"dayView.events\" let-dataEvent>\n                <div class=\"absolute pointer-events-auto\" [style.height.px]=\"dataEvent.height\" [style.marginTop.px]=\"dataEvent.top\"\n                    [style.marginLeft.px]=\"dataEvent.left\" [style.width.px]=\"dataEvent.width\">\n                    <ng-container *tdsStringTemplateOutlet=\"dataEvent.event.template\">{{ dataEvent.event.template }}\n                    </ng-container>\n                </div>\n            </ng-template>   \n        </div>\n    </div>     \n  \n</div>\n<ng-content></ng-content>" }]
        }], function () { return [{ type: i1$1.TDSDestroyService }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, { viewDate: [{
                type: Input
            }], locale: [{
                type: Input
            }], start: [{
                type: Input
            }], dayEndHour: [{
                type: Input
            }], dayEndMinute: [{
                type: Input
            }], dayStartHour: [{
                type: Input
            }], dayStartMinute: [{
                type: Input
            }], hourSegments: [{
                type: Input
            }], hourSegmentHeight: [{
                type: Input
            }], minimumEventHeight: [{
                type: Input
            }], hourSegmentWidth: [{
                type: Input
            }], hourDuration: [{
                type: Input
            }], widthColTime: [{
                type: Input
            }], currentTimeMarkerTemplate: [{
                type: Input
            }], listEventComp: [{
                type: ContentChildren,
                args: [TDSCalendarEventComponent, { descendants: true }]
            }], tdsClickSegment: [{
                type: Output
            }] });
})();

function TDSCalendarComponent_ng_container_3_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵelementStart(1, "tds-calendar-mode-day", 4);
        i0.ɵɵprojection(2);
        i0.ɵɵelementEnd();
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r0 = i0.ɵɵnextContext();
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("viewDate", ctx_r0.activeDate.nativeDate);
    }
}
function TDSCalendarComponent_ng_container_4_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtext(1, " tu\u1EA7n ");
        i0.ɵɵelementContainerEnd();
    }
}
function TDSCalendarComponent_ng_container_5_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtext(1, " th\u00E1ng ");
        i0.ɵɵelementContainerEnd();
    }
}
function TDSCalendarComponent_ng_container_6_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtext(1, " n\u0103m ");
        i0.ɵɵelementContainerEnd();
    }
}
const _c0 = ["*"];
class TDSCalendarComponent {
    constructor(cdr, directionality) {
        this.cdr = cdr;
        this.directionality = directionality;
        this.activeDate = new CandyDate();
        this.prefixCls = 'tds-picker-calendar';
        this.destroy$ = new Subject();
        this.dir = 'ltr';
        this.onChangeFn = () => { };
        this.onTouchFn = () => { };
        this.tdsMode = 'month';
        this.tdsModeChange = new EventEmitter();
        this.tdsPanelChange = new EventEmitter();
        this.tdsSelectChange = new EventEmitter();
        this.tdsValueChange = new EventEmitter();
        this.tdsFullscreen = true;
    }
    get dateCell() {
        return (this.tdsDateCell || this.tdsDateCellChild);
    }
    get dateFullCell() {
        return (this.tdsDateFullCell || this.tdsDateFullCellChild);
    }
    get monthCell() {
        return (this.tdsMonthCell || this.tdsMonthCellChild);
    }
    get monthFullCell() {
        return (this.tdsMonthFullCell || this.tdsMonthFullCellChild);
    }
    ngOnInit() {
        var _a;
        this.dir = this.directionality.value;
        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.dir = this.directionality.value;
        });
    }
    onModeChange(mode) {
        this.tdsModeChange.emit(mode);
        this.tdsPanelChange.emit({ date: this.activeDate.nativeDate, mode });
    }
    onYearSelect(year) {
        const date = this.activeDate.setYear(year);
        this.updateDate(date);
    }
    onMonthSelect(month) {
        const date = this.activeDate.setMonth(month);
        this.updateDate(date);
    }
    onDateSelect(date) {
        // Only activeDate is enough in calendar
        // this.value = date;
        this.updateDate(date);
    }
    writeValue(value) {
        this.updateDate(new CandyDate(value), false);
        this.cdr.markForCheck();
    }
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    registerOnTouched(fn) {
        this.onTouchFn = fn;
    }
    updateDate(date, touched = true) {
        this.activeDate = date;
        if (touched) {
            this.onChangeFn(date.nativeDate);
            this.onTouchFn();
            this.tdsSelectChange.emit(date.nativeDate);
            this.tdsValueChange.emit(date.nativeDate);
        }
    }
    ngOnChanges(changes) {
        if (changes.tdsValue) {
            this.updateDate(new CandyDate(this.tdsValue), false);
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
TDSCalendarComponent.ɵfac = function TDSCalendarComponent_Factory(t) { return new (t || TDSCalendarComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1$2.Directionality, 8)); };
TDSCalendarComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCalendarComponent, selectors: [["tds-calendar"]], contentQueries: function TDSCalendarComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
            i0.ɵɵcontentQuery(dirIndex, TDSDateCellDirective, 5, TemplateRef);
            i0.ɵɵcontentQuery(dirIndex, TDSDateFullCellDirective, 5, TemplateRef);
            i0.ɵɵcontentQuery(dirIndex, TDSMonthCellDirective, 5, TemplateRef);
            i0.ɵɵcontentQuery(dirIndex, TDSMonthFullCellDirective, 5, TemplateRef);
        }
        if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tdsDateCellChild = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tdsDateFullCellChild = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tdsMonthCellChild = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tdsMonthFullCellChild = _t.first);
        }
    }, hostAttrs: [1, "tds-picker-calendar", "border", "border-primary-1", "block"], hostVars: 6, hostBindings: function TDSCalendarComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
            i0.ɵɵclassProp("tds-picker-calendar-full", ctx.tdsFullscreen)("tds-picker-calendar-mini", !ctx.tdsFullscreen)("tds-picker-calendar-rtl", ctx.dir === "rtl");
        }
    }, inputs: { tdsMode: "tdsMode", tdsValue: "tdsValue", tdsDisabledDate: "tdsDisabledDate", tdsDateCell: "tdsDateCell", tdsDateFullCell: "tdsDateFullCell", tdsMonthCell: "tdsMonthCell", tdsMonthFullCell: "tdsMonthFullCell", tdsFullscreen: "tdsFullscreen" }, outputs: { tdsModeChange: "tdsModeChange", tdsPanelChange: "tdsPanelChange", tdsSelectChange: "tdsSelectChange", tdsValueChange: "tdsValueChange" }, exportAs: ["tdsCalendar"], features: [i0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => TDSCalendarComponent), multi: true }]), i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 7, vars: 8, consts: [[3, "tdsFullscreen", "tdsViewDate", "tdsMode", "tdsViewDateChange", "tdsModeChange"], [1, "tds-picker-calendar-body"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "viewDate"]], template: function TDSCalendarComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵprojectionDef();
            i0.ɵɵelementStart(0, "tds-calendar-header", 0);
            i0.ɵɵlistener("tdsViewDateChange", function TDSCalendarComponent_Template_tds_calendar_header_tdsViewDateChange_0_listener($event) { return ctx.activeDate.nativeDate = $event; })("tdsModeChange", function TDSCalendarComponent_Template_tds_calendar_header_tdsModeChange_0_listener($event) { return ctx.onModeChange($event); });
            i0.ɵɵelementEnd();
            i0.ɵɵelementStart(1, "div", 1);
            i0.ɵɵelementContainerStart(2, 2);
            i0.ɵɵtemplate(3, TDSCalendarComponent_ng_container_3_Template, 3, 1, "ng-container", 3);
            i0.ɵɵtemplate(4, TDSCalendarComponent_ng_container_4_Template, 2, 0, "ng-container", 3);
            i0.ɵɵtemplate(5, TDSCalendarComponent_ng_container_5_Template, 2, 0, "ng-container", 3);
            i0.ɵɵtemplate(6, TDSCalendarComponent_ng_container_6_Template, 2, 0, "ng-container", 3);
            i0.ɵɵelementContainerEnd();
            i0.ɵɵelementEnd();
        }
        if (rf & 2) {
            i0.ɵɵproperty("tdsFullscreen", ctx.tdsFullscreen)("tdsViewDate", ctx.activeDate.nativeDate)("tdsMode", ctx.tdsMode);
            i0.ɵɵadvance(2);
            i0.ɵɵproperty("ngSwitch", ctx.tdsMode);
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("ngSwitchCase", "date");
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("ngSwitchCase", "week");
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("ngSwitchCase", "month");
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("ngSwitchCase", "year");
        }
    }, directives: [TDSCalendarHeaderComponent, i2$2.NgSwitch, i2$2.NgSwitchCase, TDSCalendarModeDayComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSCalendarComponent.prototype, "tdsFullscreen", void 0);
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarComponent, [{
            type: Component,
            args: [{
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'tds-calendar',
                    exportAs: 'tdsCalendar',
                    template: `
    <tds-calendar-header
      [tdsFullscreen]="tdsFullscreen"
      [(tdsViewDate)]="activeDate.nativeDate"
      [tdsMode]="tdsMode"
      (tdsModeChange)="onModeChange($event)"
      
    ></tds-calendar-header>
    <div class="tds-picker-calendar-body">
      <ng-container [ngSwitch]="tdsMode">
        <ng-container *ngSwitchCase="'date'">
          <tds-calendar-mode-day [viewDate]="activeDate.nativeDate">
            <ng-content></ng-content>
          </tds-calendar-mode-day>
        </ng-container>
        <ng-container *ngSwitchCase="'week'">
          tuần
        </ng-container>
        <ng-container *ngSwitchCase="'month'">
          tháng
        </ng-container>
        <ng-container *ngSwitchCase="'year'">
          năm
        </ng-container>
      </ng-container>
    </div>
    <!-- <div class="tds-picker-panel">
      <div class="tds-picker-{{ tdsMode === 'month' ? 'day' : 'month' }}-panel">
        <div class="">
          <ng-container *ngIf="tdsMode === 'month'; then monthModeTable; else yearModeTable"></ng-container>
        </div>
      </div>
    </div> -->
    <!-- <ng-template #monthModeTable> -->
      <!--  TODO [cellRender] [fullCellRender] -->
      <!-- <date-table
        [prefixCls]="prefixCls"
        [value]="activeDate"
        [activeDate]="activeDate"
        [cellRender]="$any(dateCell)"
        [fullCellRender]="$any(dateFullCell)"
        [disabledDate]="tdsDisabledDate"
        (valueChange)="onDateSelect($event)"
      ></date-table>
    </ng-template> -->

    <!--  TODO [cellRender] [fullCellRender] -->
    <!-- <ng-template #yearModeTable>
      <month-table
        [prefixCls]="prefixCls"
        [value]="activeDate"
        [activeDate]="activeDate"
        [cellRender]="$any(monthCell)"
        [fullCellRender]="$any(monthFullCell)"
        (valueChange)="onDateSelect($event)"
      ></month-table>
    </ng-template> -->
  `,
                    host: {
                        class: 'tds-picker-calendar border border-primary-1 block',
                        '[class.tds-picker-calendar-full]': 'tdsFullscreen',
                        '[class.tds-picker-calendar-mini]': '!tdsFullscreen',
                        '[class.tds-picker-calendar-rtl]': `dir === 'rtl'`
                    },
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => TDSCalendarComponent), multi: true }]
                }]
        }], function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i1$2.Directionality, decorators: [{
                        type: Optional
                    }] }];
    }, { tdsMode: [{
                type: Input
            }], tdsValue: [{
                type: Input
            }], tdsDisabledDate: [{
                type: Input
            }], tdsModeChange: [{
                type: Output
            }], tdsPanelChange: [{
                type: Output
            }], tdsSelectChange: [{
                type: Output
            }], tdsValueChange: [{
                type: Output
            }], tdsDateCell: [{
                type: Input
            }], tdsDateCellChild: [{
                type: ContentChild,
                args: [TDSDateCellDirective, { static: false, read: TemplateRef }]
            }], tdsDateFullCell: [{
                type: Input
            }], tdsDateFullCellChild: [{
                type: ContentChild,
                args: [TDSDateFullCellDirective, { static: false, read: TemplateRef }]
            }], tdsMonthCell: [{
                type: Input
            }], tdsMonthCellChild: [{
                type: ContentChild,
                args: [TDSMonthCellDirective, { static: false, read: TemplateRef }]
            }], tdsMonthFullCell: [{
                type: Input
            }], tdsMonthFullCellChild: [{
                type: ContentChild,
                args: [TDSMonthFullCellDirective, { static: false, read: TemplateRef }]
            }], tdsFullscreen: [{
                type: Input
            }] });
})();

class TDSCalendarModeWeekComponent {
    constructor() { }
    ngOnInit() {
    }
}
TDSCalendarModeWeekComponent.ɵfac = function TDSCalendarModeWeekComponent_Factory(t) { return new (t || TDSCalendarModeWeekComponent)(); };
TDSCalendarModeWeekComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCalendarModeWeekComponent, selectors: [["tds-calendar-mode-week"]], decls: 2, vars: 0, template: function TDSCalendarModeWeekComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵelementStart(0, "p");
            i0.ɵɵtext(1, "tds-calendar-mode-week works!");
            i0.ɵɵelementEnd();
        }
    }, encapsulation: 2, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarModeWeekComponent, [{
            type: Component,
            args: [{ selector: 'tds-calendar-mode-week', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: "<p>tds-calendar-mode-week works!</p>\n" }]
        }], function () { return []; }, null);
})();

class TDSCalendarModeMonthComponent {
    constructor() { }
    ngOnInit() {
    }
}
TDSCalendarModeMonthComponent.ɵfac = function TDSCalendarModeMonthComponent_Factory(t) { return new (t || TDSCalendarModeMonthComponent)(); };
TDSCalendarModeMonthComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCalendarModeMonthComponent, selectors: [["tds-calendar-mode-month"]], decls: 2, vars: 0, template: function TDSCalendarModeMonthComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵelementStart(0, "p");
            i0.ɵɵtext(1, "tds-calendar-mode-month works!");
            i0.ɵɵelementEnd();
        }
    }, encapsulation: 2, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarModeMonthComponent, [{
            type: Component,
            args: [{ selector: 'tds-calendar-mode-month', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: "<p>tds-calendar-mode-month works!</p>\n" }]
        }], function () { return []; }, null);
})();

class TDSCalendarModeYearComponent {
    constructor() { }
    ngOnInit() {
    }
}
TDSCalendarModeYearComponent.ɵfac = function TDSCalendarModeYearComponent_Factory(t) { return new (t || TDSCalendarModeYearComponent)(); };
TDSCalendarModeYearComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCalendarModeYearComponent, selectors: [["tds-calendar-mode-year"]], decls: 2, vars: 0, template: function TDSCalendarModeYearComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵelementStart(0, "p");
            i0.ɵɵtext(1, "tds-calendar-mode-year works!");
            i0.ɵɵelementEnd();
        }
    }, encapsulation: 2, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarModeYearComponent, [{
            type: Component,
            args: [{ selector: 'tds-calendar-mode-year', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: "<p>tds-calendar-mode-year works!</p>\n" }]
        }], function () { return []; }, null);
})();

class TDSCalendarModule {
}
TDSCalendarModule.ɵfac = function TDSCalendarModule_Factory(t) { return new (t || TDSCalendarModule)(); };
TDSCalendarModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSCalendarModule });
TDSCalendarModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[BidiModule,
            CommonModule,
            FormsModule,
            TDSI18nModule,
            TDSRadioModule,
            TDSSelectModule,
            LibPackerModule,
            TDSDropDownModule,
            TDSDatePickerModule,
            TDSRadioModule,
            TDSButtonModule,
            TDSOutletModule
        ]] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCalendarModule, [{
            type: NgModule,
            args: [{
                    declarations: [
                        TDSCalendarHeaderComponent,
                        TDSCalendarComponent,
                        TDSDateCellDirective,
                        TDSDateFullCellDirective,
                        TDSMonthCellDirective,
                        TDSMonthFullCellDirective,
                        TDSCalendarDatepickerComponent,
                        TDSCalendarModeDayComponent,
                        TDSCalendarModeWeekComponent,
                        TDSCalendarModeMonthComponent,
                        TDSCalendarModeYearComponent,
                        TDSCalendarEventComponent,
                        TDSCalendarCurrentTimeComponent
                    ],
                    exports: [
                        TDSCalendarComponent,
                        TDSDateCellDirective,
                        TDSDateFullCellDirective,
                        TDSMonthCellDirective,
                        TDSMonthFullCellDirective,
                        TDSCalendarDatepickerComponent,
                        TDSCalendarModeDayComponent,
                        TDSCalendarModeWeekComponent,
                        TDSCalendarModeMonthComponent,
                        TDSCalendarModeYearComponent,
                        TDSCalendarEventComponent,
                        TDSCalendarHeaderComponent,
                        TDSCalendarCurrentTimeComponent
                    ],
                    imports: [BidiModule,
                        CommonModule,
                        FormsModule,
                        TDSI18nModule,
                        TDSRadioModule,
                        TDSSelectModule,
                        LibPackerModule,
                        TDSDropDownModule,
                        TDSDatePickerModule,
                        TDSRadioModule,
                        TDSButtonModule,
                        TDSOutletModule
                    ]
                }]
        }], null, null);
})();
(function () {
    (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSCalendarModule, { declarations: [TDSCalendarHeaderComponent,
            TDSCalendarComponent,
            TDSDateCellDirective,
            TDSDateFullCellDirective,
            TDSMonthCellDirective,
            TDSMonthFullCellDirective,
            TDSCalendarDatepickerComponent,
            TDSCalendarModeDayComponent,
            TDSCalendarModeWeekComponent,
            TDSCalendarModeMonthComponent,
            TDSCalendarModeYearComponent,
            TDSCalendarEventComponent,
            TDSCalendarCurrentTimeComponent], imports: [BidiModule,
            CommonModule,
            FormsModule,
            TDSI18nModule,
            TDSRadioModule,
            TDSSelectModule,
            LibPackerModule,
            TDSDropDownModule,
            TDSDatePickerModule,
            TDSRadioModule,
            TDSButtonModule,
            TDSOutletModule], exports: [TDSCalendarComponent,
            TDSDateCellDirective,
            TDSDateFullCellDirective,
            TDSMonthCellDirective,
            TDSMonthFullCellDirective,
            TDSCalendarDatepickerComponent,
            TDSCalendarModeDayComponent,
            TDSCalendarModeWeekComponent,
            TDSCalendarModeMonthComponent,
            TDSCalendarModeYearComponent,
            TDSCalendarEventComponent,
            TDSCalendarHeaderComponent,
            TDSCalendarCurrentTimeComponent] });
})();

/**
 * Generated bundle index. Do not edit.
 */

export { DAYS_OF_WEEK, SECONDS_IN_DAY, TDSCalendarComponent, TDSCalendarCurrentTimeComponent, TDSCalendarDatepickerComponent, TDSCalendarEventComponent, TDSCalendarHeaderComponent, TDSCalendarModeDayComponent, TDSCalendarModeMonthComponent, TDSCalendarModeWeekComponent, TDSCalendarModeYearComponent, TDSCalendarModule, TDSDateCellDirective, TDSDateFullCellDirective, TDSMonthCellDirective, TDSMonthFullCellDirective, getDayView, getDayViewHourGrid, getEventsInPeriod, trackByHourSegment };
//# sourceMappingURL=tds-ui-calendar.mjs.map
