import * as i1$2 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i1$1 from '@angular/cdk/overlay';
import { OverlayConfig, ConnectionPositionPair, OverlayModule } from '@angular/cdk/overlay';
import * as i3 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, ViewEncapsulation, Input, EventEmitter, Optional, Output, forwardRef, Directive, Inject, Host, TemplateRef, ContentChildren, ViewChildren, ViewChild, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import * as i2$1 from 'tds-ui/core/no-animation';
import { TDSNoAnimationModule } from 'tds-ui/core/no-animation';
import * as i1 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';
import { __decorate } from 'tslib';
import { InputBoolean } from 'tds-ui/shared/utility';
import { scrollIntoView } from 'tds-ui/core/util';
import { UP_ARROW, DOWN_ARROW, ESCAPE, TAB, ENTER } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { Subject, Subscription, defer, merge } from 'rxjs';
import { takeUntil, distinctUntilChanged, tap, delay, filter, take, switchMap } from 'rxjs/operators';
import * as i2 from 'tds-ui/form-field';
import { TDS_FORM_FIELD } from 'tds-ui/form-field';
import { slideMotion } from 'tds-ui/core/animation';

function TDSAutocompleteOptgroupComponent_ng_container_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtext(1);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r0 = i0.ɵɵnextContext();
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx_r0.label);
    }
}
const _c0$2 = [[["tds-auto-option"]]];
const _c1$2 = ["tds-auto-option"];
class TDSAutocompleteOptgroupComponent {
    constructor() { }
}
TDSAutocompleteOptgroupComponent.ɵfac = function TDSAutocompleteOptgroupComponent_Factory(t) { return new (t || TDSAutocompleteOptgroupComponent)(); };
TDSAutocompleteOptgroupComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSAutocompleteOptgroupComponent, selectors: [["tds-auto-optgroup"]], hostAttrs: [1, "flex", "w-full", "flex-col", "px-3", "text-neutral-1-900", "text-body-2", "font-regular"], inputs: { label: "label" }, exportAs: ["tdsAutoOptgroup"], ngContentSelectors: _c1$2, decls: 3, vars: 1, consts: [[1, "tds-select-item", "tds-select-item-group"], [4, "tdsStringTemplateOutlet"]], template: function TDSAutocompleteOptgroupComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵprojectionDef(_c0$2);
            i0.ɵɵelementStart(0, "div", 0);
            i0.ɵɵtemplate(1, TDSAutocompleteOptgroupComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
            i0.ɵɵelementEnd();
            i0.ɵɵprojection(2);
        }
        if (rf & 2) {
            i0.ɵɵadvance(1);
            i0.ɵɵproperty("tdsStringTemplateOutlet", ctx.label);
        }
    }, directives: [i1.TDSStringTemplateOutletDirective], encapsulation: 2, changeDetection: 0 });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSAutocompleteOptgroupComponent, [{
            type: Component,
            args: [{
                    selector: 'tds-auto-optgroup',
                    exportAs: 'tdsAutoOptgroup',
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    template: `
    <div class="tds-select-item tds-select-item-group">
      <ng-container *tdsStringTemplateOutlet="label">{{ label }}</ng-container>
    </div>
    <ng-content select="tds-auto-option"></ng-content>
  `,
                    host: {
                        class: "flex w-full flex-col px-3 text-neutral-1-900 text-body-2 font-regular"
                    }
                }]
        }], function () { return []; }, { label: [{
                type: Input
            }] });
})();

const _c0$1 = function (a0, a1, a2) { return { "py-2": a0, "py-1.5": a1, "py-2.5": a2 }; };
const _c1$1 = ["*"];
class TDSAutoOptionSelectionChange {
    constructor(source, isUserInput = false) {
        this.source = source;
        this.isUserInput = isUserInput;
    }
}
class TDSAutocompleteOptionComponent {
    constructor(changeDetectorRef, element, TDSAutocompleteOptgroupComponent) {
        this.changeDetectorRef = changeDetectorRef;
        this.element = element;
        this.TDSAutocompleteOptgroupComponent = TDSAutocompleteOptgroupComponent;
        this.size = 'md';
        this.disabled = false;
        this.selectionChange = new EventEmitter();
        this.mouseEntered = new EventEmitter();
        this.active = false;
        this.selected = false;
    }
    select(emit = true) {
        this.selected = true;
        this.changeDetectorRef.markForCheck();
        if (emit) {
            this.emitSelectionChangeEvent();
        }
    }
    onMouseEnter() {
        this.mouseEntered.emit(this);
    }
    deselect() {
        this.selected = false;
        this.changeDetectorRef.markForCheck();
        this.emitSelectionChangeEvent();
    }
    /** Git display label */
    getLabel() {
        return this.label || this.value.toString();
    }
    /** Set active (only styles) */
    setActiveStyles() {
        if (!this.active) {
            this.active = true;
            this.changeDetectorRef.markForCheck();
        }
    }
    /** Unset active (only styles) */
    setInactiveStyles() {
        if (this.active) {
            this.active = false;
            this.changeDetectorRef.markForCheck();
        }
    }
    scrollIntoViewIfNeeded() {
        scrollIntoView(this.element.nativeElement);
    }
    selectViaInteraction() {
        if (!this.disabled) {
            this.selected = !this.selected;
            if (this.selected) {
                this.setActiveStyles();
            }
            else {
                this.setInactiveStyles();
            }
            this.emitSelectionChangeEvent(true);
            this.changeDetectorRef.markForCheck();
        }
    }
    emitSelectionChangeEvent(isUserInput = false) {
        this.selectionChange.emit(new TDSAutoOptionSelectionChange(this, isUserInput));
    }
}
TDSAutocompleteOptionComponent.ɵfac = function TDSAutocompleteOptionComponent_Factory(t) { return new (t || TDSAutocompleteOptionComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TDSAutocompleteOptgroupComponent, 8)); };
TDSAutocompleteOptionComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSAutocompleteOptionComponent, selectors: [["tds-auto-option"]], hostAttrs: ["role", "menuitem", 1, "tds-select-item", "tds-select-item-option", "px-3", "text-neutral-1-900", "dark:text-d-neutral-1-900", "text-body-2", "font-regular", "hover:bg-neutral-3-50", "dark:hover:bg-d-neutral-3-300", "flex", "w-full"], hostVars: 18, hostBindings: function TDSAutocompleteOptionComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵlistener("click", function TDSAutocompleteOptionComponent_click_HostBindingHandler() { return ctx.selectViaInteraction(); })("mouseenter", function TDSAutocompleteOptionComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mousedown", function TDSAutocompleteOptionComponent_mousedown_HostBindingHandler($event) { return $event.preventDefault(); });
        }
        if (rf & 2) {
            i0.ɵɵattribute("aria-selected", ctx.selected.toString())("aria-disabled", ctx.disabled.toString());
            i0.ɵɵclassProp("tds-select-item-option-grouped", ctx.TDSAutocompleteOptgroupComponent)("tds-select-item-option-selected", ctx.selected)("bg-neutral-3-50", (ctx.selected || ctx.active) && !ctx.disabled)("dark:bg-d-neutral-3-300", (ctx.selected || ctx.active) && !ctx.disabled)("tds-select-item-option-active", ctx.active)("cursor-pointer", !ctx.disabled)("cursor-not-allowed", ctx.disabled)("tds-select-item-option-disabled", ctx.disabled);
        }
    }, inputs: { size: "size", value: "value", label: "label", disabled: "disabled" }, outputs: { selectionChange: "selectionChange", mouseEntered: "mouseEntered" }, exportAs: ["tdsAutoOption"], ngContentSelectors: _c1$1, decls: 2, vars: 5, consts: [[1, "tds-select-item-option-content", "w-full", "flex", "break-words", 3, "ngClass"]], template: function TDSAutocompleteOptionComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵprojectionDef();
            i0.ɵɵelementStart(0, "div", 0);
            i0.ɵɵprojection(1);
            i0.ɵɵelementEnd();
        }
        if (rf & 2) {
            i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(1, _c0$1, ctx.size === "md", ctx.size === "sm", ctx.size === "lg"));
        }
    }, directives: [i3.NgClass], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSAutocompleteOptionComponent.prototype, "disabled", void 0);
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSAutocompleteOptionComponent, [{
            type: Component,
            args: [{
                    selector: 'tds-auto-option',
                    exportAs: 'tdsAutoOption',
                    // preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    template: `
    <div class="tds-select-item-option-content w-full flex break-words" [ngClass]="{'py-2': size === 'md',
    'py-1.5': size === 'sm',
    'py-2.5': size === 'lg'}">    
      <ng-content></ng-content>
    </div>
  `,
                    host: {
                        role: 'menuitem',
                        class: 'tds-select-item tds-select-item-option px-3  text-neutral-1-900 dark:text-d-neutral-1-900 text-body-2 font-regular hover:bg-neutral-3-50 dark:hover:bg-d-neutral-3-300 flex w-full',
                        '[class.tds-select-item-option-grouped]': 'TDSAutocompleteOptgroupComponent',
                        '[class.tds-select-item-option-selected]': 'selected',
                        '[class.bg-neutral-3-50]': '(selected ||active) && !disabled',
                        '[class.dark:bg-d-neutral-3-300]': '(selected ||active) && !disabled',
                        '[class.tds-select-item-option-active]': 'active',
                        '[class.cursor-pointer]': "!disabled",
                        '[class.cursor-not-allowed]': "disabled",
                        '[class.tds-select-item-option-disabled]': 'disabled',
                        '[attr.aria-selected]': 'selected.toString()',
                        '[attr.aria-disabled]': 'disabled.toString()',
                        '(click)': 'selectViaInteraction()',
                        '(mouseenter)': 'onMouseEnter()',
                        '(mousedown)': '$event.preventDefault()'
                    }
                }]
        }], function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: TDSAutocompleteOptgroupComponent, decorators: [{
                        type: Optional
                    }] }];
    }, { size: [{
                type: Input
            }], value: [{
                type: Input
            }], label: [{
                type: Input
            }], disabled: [{
                type: Input
            }], selectionChange: [{
                type: Output
            }], mouseEntered: [{
                type: Output
            }] });
})();

const TDS_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TDSAutocompleteTriggerDirective),
    multi: true
};
function getTDSAutocompleteMissingPanelError() {
    return Error('Attempting to open an undefined instance of `tds-autocomplete`. ' +
        'Make sure that the id passed to the `tdsAutocomplete` is correct and that ' +
        "you're attempting to open it after the ngAfterContentInit hook.");
}
class TDSAutocompleteTriggerDirective {
    constructor(elementRef, overlay, viewContainerRef, _formField, 
    // @Optional() private nzInputGroupWhitSuffixOrPrefixDirective: NzInputGroupWhitSuffixOrPrefixDirective,
    document) {
        this.elementRef = elementRef;
        this.overlay = overlay;
        this.viewContainerRef = viewContainerRef;
        this._formField = _formField;
        this.document = document;
        this.onChange = () => { };
        this.onTouched = () => { };
        this.panelOpen = false;
        this.destroy$ = new Subject();
        this.overlayRef = null;
        this.portal = null;
        this.previousValue = null;
    }
    /** Current active option */
    get activeOption() {
        if (this.tdsAutocomplete && this.tdsAutocomplete.options.length) {
            return this.tdsAutocomplete.activeItem;
        }
        else {
            return null;
        }
    }
    ngAfterViewInit() {
        if (this.tdsAutocomplete) {
            this.tdsAutocomplete.animationStateChange.pipe(takeUntil(this.destroy$)).subscribe(event => {
                if (event.toState === 'void') {
                    if (this.overlayRef) {
                        this.overlayRef.dispose();
                        this.overlayRef = null;
                    }
                }
            });
        }
        if (this._formField) {
            this._formField._control.stateChanges.pipe(distinctUntilChanged()).subscribe(res => {
                if (this._formField._control.focused)
                    if (this.canOpen() && !this.panelOpen) {
                        this.openPanel();
                    }
            });
        }
    }
    ngOnDestroy() {
        this.destroyPanel();
    }
    writeValue(value) {
        Promise.resolve(null).then(() => this.setTriggerValue(value));
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        const element = this.elementRef.nativeElement;
        element.disabled = isDisabled;
        this.closePanel();
    }
    openPanel() {
        this.previousValue = this.elementRef.nativeElement.value;
        this.attachOverlay();
        this.updateStatus();
    }
    closePanel() {
        if (this.panelOpen) {
            this.tdsAutocomplete.isOpen = this.panelOpen = false;
            if (this.overlayRef && this.overlayRef.hasAttached()) {
                this.overlayRef.detach();
                this.selectionChangeSubscription.unsubscribe();
                this.overlayOutsideClickSubscription.unsubscribe();
                this.optionsChangeSubscription.unsubscribe();
                this.portal = null;
            }
        }
    }
    handleKeydown(event) {
        const keyCode = event.keyCode;
        const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;
        if (keyCode === ESCAPE) {
            event.preventDefault();
        }
        if (this.panelOpen && (keyCode === ESCAPE || keyCode === TAB)) {
            // Reset value when tab / ESC close
            if (this.activeOption && this.activeOption.getLabel() !== this.previousValue) {
                this.setTriggerValue(this.previousValue);
            }
            this.closePanel();
        }
        else if (this.panelOpen && keyCode === ENTER) {
            if (this.tdsAutocomplete.showPanel) {
                event.preventDefault();
                if (this.activeOption) {
                    this.activeOption.selectViaInteraction();
                }
                else {
                    this.closePanel();
                }
            }
        }
        else if (this.panelOpen && isArrowKey && this.tdsAutocomplete.showPanel) {
            event.stopPropagation();
            event.preventDefault();
            if (keyCode === UP_ARROW) {
                this.tdsAutocomplete.setPreviousItemActive();
            }
            else {
                this.tdsAutocomplete.setNextItemActive();
            }
            if (this.activeOption) {
                this.activeOption.scrollIntoViewIfNeeded();
            }
            this.doBackfill();
        }
    }
    handleInput(event) {
        const target = event.target;
        const document = this.document;
        let value = target.value;
        if (target.type === 'number') {
            value = value === '' ? null : parseFloat(value);
        }
        if (this.previousValue !== value) {
            this.previousValue = value;
            this.onChange(value);
            if (this.canOpen() && document.activeElement === event.target) {
                this.openPanel();
            }
        }
    }
    handleFocus() {
        // if (!this._formField)
        if (this.canOpen()) {
            this.openPanel();
        }
        // else {
        // }
    }
    handleBlur() {
        this.onTouched();
    }
    /**
     * Subscription data source changes event
     */
    subscribeOptionsChange() {
        const optionChanges = this.tdsAutocomplete.options.changes.pipe(tap(() => this.positionStrategy.reapplyLastPosition()), delay(0));
        return optionChanges.subscribe(() => {
            this.resetActiveItem();
            if (this.panelOpen) {
                this.overlayRef.updatePosition();
            }
        });
    }
    /**
     * Subscription option changes event and set the value
     */
    subscribeSelectionChange() {
        return this.tdsAutocomplete.selectionChange.subscribe((option) => {
            this.setValueAndClose(option);
        });
    }
    subscribeOverlayOutsideClick() {
        return this.overlayRef.outsidePointerEvents()
            .pipe(filter((e) => !this.elementRef.nativeElement.contains(e.target)))
            .subscribe(() => {
            this.closePanel();
        });
    }
    attachOverlay() {
        if (!this.tdsAutocomplete) {
            throw getTDSAutocompleteMissingPanelError();
        }
        if (!this.portal && this.tdsAutocomplete.template) {
            this.portal = new TemplatePortal(this.tdsAutocomplete.template, this.viewContainerRef);
        }
        if (!this.overlayRef) {
            this.overlayRef = this.overlay.create(this.getOverlayConfig());
        }
        if (this.overlayRef && !this.overlayRef.hasAttached()) {
            this.overlayRef.attach(this.portal);
            this.selectionChangeSubscription = this.subscribeSelectionChange();
            this.optionsChangeSubscription = this.subscribeOptionsChange();
            this.overlayOutsideClickSubscription = this.subscribeOverlayOutsideClick();
            this.overlayRef
                .detachments()
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => {
                this.closePanel();
            });
        }
        this.tdsAutocomplete.isOpen = this.panelOpen = true;
    }
    updateStatus() {
        if (this.overlayRef) {
            this.overlayRef.updateSize({ width: this.tdsAutocomplete.width || this.getHostWidth() });
        }
        this.tdsAutocomplete.setVisibility();
        this.resetActiveItem();
        if (this.activeOption) {
            this.activeOption.scrollIntoViewIfNeeded();
        }
    }
    destroyPanel() {
        if (this.overlayRef) {
            this.closePanel();
        }
    }
    getOverlayConfig() {
        return new OverlayConfig({
            positionStrategy: this.getOverlayPosition(),
            disposeOnNavigation: true,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
            // default host element width
            width: this.tdsAutocomplete.width || this.getHostWidth()
        });
    }
    getConnectedElement() {
        return this._formField
            ? this._formField._elementRef
            : this.elementRef;
    }
    getHostWidth() {
        return this.getConnectedElement().nativeElement.getBoundingClientRect().width;
    }
    getOverlayPosition() {
        const positions = [
            new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
            new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
        ];
        this.positionStrategy = this.overlay
            .position()
            .flexibleConnectedTo(this.getConnectedElement())
            .withFlexibleDimensions(false)
            .withPush(false)
            .withPositions(positions)
            .withTransformOriginOn('.tds-select-dropdown');
        return this.positionStrategy;
    }
    resetActiveItem() {
        const index = this.tdsAutocomplete.getOptionIndex(this.previousValue);
        this.tdsAutocomplete.clearSelectedOptions(null, true);
        if (index !== -1) {
            this.tdsAutocomplete.setActiveItem(index);
            this.tdsAutocomplete.activeItem.select(false);
        }
        else {
            this.tdsAutocomplete.setActiveItem(this.tdsAutocomplete.defaultActiveFirstOption ? 0 : -1);
        }
    }
    setValueAndClose(option) {
        const value = option.value;
        this.setTriggerValue(option.getLabel());
        this.onChange(value);
        this.elementRef.nativeElement.focus();
        if (this.tdsAutocomplete.autoClose)
            this.closePanel();
    }
    setTriggerValue(value) {
        const option = this.tdsAutocomplete.getOption(value);
        const displayValue = option ? option.getLabel() : value;
        this.elementRef.nativeElement.value = displayValue != null ? displayValue : '';
        if (!this.tdsAutocomplete.backfill) {
            this.previousValue = displayValue;
        }
    }
    doBackfill() {
        if (this.tdsAutocomplete.backfill && this.tdsAutocomplete.activeItem) {
            this.setTriggerValue(this.tdsAutocomplete.activeItem.getLabel());
        }
    }
    canOpen() {
        const element = this.elementRef.nativeElement;
        return !element.readOnly && !element.disabled;
    }
}
TDSAutocompleteTriggerDirective.ɵfac = function TDSAutocompleteTriggerDirective_Factory(t) { return new (t || TDSAutocompleteTriggerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$1.Overlay), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(TDS_FORM_FIELD, 9), i0.ɵɵdirectiveInject(DOCUMENT, 8)); };
TDSAutocompleteTriggerDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSAutocompleteTriggerDirective, selectors: [["input", "tdsAutocomplete", ""], ["textarea", "tdsAutocomplete", ""]], hostAttrs: ["autocomplete", "off", "aria-autocomplete", "list"], hostBindings: function TDSAutocompleteTriggerDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵlistener("focusin", function TDSAutocompleteTriggerDirective_focusin_HostBindingHandler() { return ctx.handleFocus(); })("blur", function TDSAutocompleteTriggerDirective_blur_HostBindingHandler() { return ctx.handleBlur(); })("input", function TDSAutocompleteTriggerDirective_input_HostBindingHandler($event) { return ctx.handleInput($event); })("keydown", function TDSAutocompleteTriggerDirective_keydown_HostBindingHandler($event) { return ctx.handleKeydown($event); });
        }
    }, inputs: { tdsAutocomplete: "tdsAutocomplete" }, exportAs: ["tdsAutocompleteTrigger"], features: [i0.ɵɵProvidersFeature([TDS_AUTOCOMPLETE_VALUE_ACCESSOR])] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSAutocompleteTriggerDirective, [{
            type: Directive,
            args: [{
                    selector: `input[tdsAutocomplete], textarea[tdsAutocomplete]`,
                    exportAs: 'tdsAutocompleteTrigger',
                    providers: [TDS_AUTOCOMPLETE_VALUE_ACCESSOR],
                    host: {
                        autocomplete: 'off',
                        'aria-autocomplete': 'list',
                        '(focusin)': 'handleFocus()',
                        '(blur)': 'handleBlur()',
                        '(input)': 'handleInput($event)',
                        '(keydown)': 'handleKeydown($event)'
                    }
                }]
        }], function () {
        return [{ type: i0.ElementRef }, { type: i1$1.Overlay }, { type: i0.ViewContainerRef }, { type: i2.TDSFormField, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [TDS_FORM_FIELD]
                    }, {
                        type: Host
                    }] }, { type: undefined, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [DOCUMENT]
                    }] }];
    }, { tdsAutocomplete: [{
                type: Input
            }] });
})();

const _c0 = ["panel"];
const _c1 = ["content"];
function TDSAutocompleteComponent_ng_template_0_4_ng_template_0_Template(rf, ctx) { }
function TDSAutocompleteComponent_ng_template_0_4_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵtemplate(0, TDSAutocompleteComponent_ng_template_0_4_ng_template_0_Template, 0, 0, "ng-template");
    }
}
function TDSAutocompleteComponent_ng_template_0_ng_template_5_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵprojection(0);
    }
}
function TDSAutocompleteComponent_ng_template_0_ng_template_7_tds_auto_option_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "tds-auto-option", 8);
        i0.ɵɵtext(1);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const option_r9 = ctx.$implicit;
        i0.ɵɵproperty("value", option_r9)("label", option_r9 && option_r9.label ? option_r9.label : option_r9);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1(" ", option_r9 && option_r9.label ? option_r9.label : option_r9, " ");
    }
}
function TDSAutocompleteComponent_ng_template_0_ng_template_7_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵtemplate(0, TDSAutocompleteComponent_ng_template_0_ng_template_7_tds_auto_option_0_Template, 2, 3, "tds-auto-option", 7);
    }
    if (rf & 2) {
        const ctx_r6 = i0.ɵɵnextContext(2);
        i0.ɵɵproperty("ngForOf", ctx_r6.dataSource);
    }
}
function TDSAutocompleteComponent_ng_template_0_Template(rf, ctx) {
    if (rf & 1) {
        const _r11 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵlistener("@slideMotion.done", function TDSAutocompleteComponent_ng_template_0_Template_div_animation_slideMotion_done_0_listener($event) { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.onAnimationEvent($event); });
        i0.ɵɵelementStart(2, "div", 2)(3, "div", 3);
        i0.ɵɵtemplate(4, TDSAutocompleteComponent_ng_template_0_4_Template, 1, 0, null, 4);
        i0.ɵɵelementEnd()()();
        i0.ɵɵtemplate(5, TDSAutocompleteComponent_ng_template_0_ng_template_5_Template, 1, 0, "ng-template", null, 5, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtemplate(7, TDSAutocompleteComponent_ng_template_0_ng_template_7_Template, 1, 1, "ng-template", null, 6, i0.ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
        const _r3 = i0.ɵɵreference(6);
        const _r5 = i0.ɵɵreference(8);
        const ctx_r0 = i0.ɵɵnextContext();
        i0.ɵɵclassProp("tds-select-dropdown-hidden", !ctx_r0.showPanel)("hidden", !ctx_r0.showPanel)("tds-select-dropdown-rtl", ctx_r0.dir === "rtl");
        i0.ɵɵproperty("ngClass", ctx_r0.overlayClassName)("ngStyle", ctx_r0.overlayStyle)("@slideMotion", undefined)("@.disabled", ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.noAnimation);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngTemplateOutlet", ctx_r0.dataSource ? _r5 : _r3);
    }
}
const _c2 = ["*"];
class TDSAutocompleteComponent {
    constructor(changeDetectorRef, ngZone, directionality, noAnimation) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.directionality = directionality;
        this.noAnimation = noAnimation;
        this.overlayClassName = '';
        this.overlayStyle = {};
        this.defaultActiveFirstOption = true;
        this.backfill = false;
        this.compareWith = (o1, o2) => o1 === o2;
        this.autoClose = true;
        this.selectionChange = new EventEmitter();
        this.showPanel = true;
        this.isOpen = false;
        this.activeItem = null;
        this.dir = 'ltr';
        this.destroy$ = new Subject();
        this.animationStateChange = new EventEmitter();
        this.activeItemIndex = -1;
        this.selectionChangeSubscription = Subscription.EMPTY;
        this.optionMouseEnterSubscription = Subscription.EMPTY;
        this.dataSourceChangeSubscription = Subscription.EMPTY;
        /** Options changes listener */
        this.optionSelectionChanges = defer(() => {
            if (this.options) {
                return merge(...this.options.map(option => option.selectionChange));
            }
            return this.ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this.optionSelectionChanges));
        });
        this.optionMouseEnter = defer(() => {
            if (this.options) {
                return merge(...this.options.map(option => option.mouseEntered));
            }
            return this.ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this.optionMouseEnter));
        });
    }
    /**
     * Options accessor, its source may be content or dataSource
     */
    get options() {
        // first dataSource
        if (this.dataSource) {
            return this.fromDataSourceOptions;
        }
        else {
            return this.fromContentOptions;
        }
    }
    ngOnInit() {
        var _a;
        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.changeDetectorRef.detectChanges();
        });
        this.dir = this.directionality.value;
    }
    onAnimationEvent(event) {
        this.animationStateChange.emit(event);
    }
    ngAfterContentInit() {
        if (!this.dataSource) {
            this.optionsInit();
        }
    }
    ngAfterViewInit() {
        if (this.dataSource) {
            this.optionsInit();
        }
    }
    ngOnDestroy() {
        this.dataSourceChangeSubscription.unsubscribe();
        this.selectionChangeSubscription.unsubscribe();
        this.optionMouseEnterSubscription.unsubscribe();
        this.destroy$.next();
        this.destroy$.complete();
    }
    setVisibility() {
        this.showPanel = !!this.options.length;
        this.changeDetectorRef.markForCheck();
    }
    setActiveItem(index) {
        const activeItem = this.options.get(index);
        if (activeItem && !activeItem.active) {
            this.activeItem = activeItem;
            this.activeItemIndex = index;
            this.clearSelectedOptions(this.activeItem);
            this.activeItem.setActiveStyles();
        }
        else {
            this.activeItem = null;
            this.activeItemIndex = -1;
            this.clearSelectedOptions();
        }
        this.changeDetectorRef.markForCheck();
    }
    setNextItemActive() {
        const nextIndex = this.activeItemIndex + 1 <= this.options.length - 1 ? this.activeItemIndex + 1 : 0;
        this.setActiveItem(nextIndex);
    }
    setPreviousItemActive() {
        const previousIndex = this.activeItemIndex - 1 < 0 ? this.options.length - 1 : this.activeItemIndex - 1;
        this.setActiveItem(previousIndex);
    }
    getOptionIndex(value) {
        return this.options.reduce((result, current, index) => result === -1 ? (this.compareWith(value, current.value) ? index : -1) : result, -1);
    }
    getOption(value) {
        return this.options.find(item => this.compareWith(value, item.value)) || null;
    }
    optionsInit() {
        this.setVisibility();
        this.subscribeOptionChanges();
        const changes = this.dataSource ? this.fromDataSourceOptions.changes : this.fromContentOptions.changes;
        // async
        this.dataSourceChangeSubscription = changes.subscribe(e => {
            if (!e.dirty && this.isOpen) {
                setTimeout(() => this.setVisibility());
            }
            this.subscribeOptionChanges();
        });
    }
    /**
     * Clear the status of options
     */
    clearSelectedOptions(skip, deselect = false) {
        this.options.forEach(option => {
            if (option !== skip) {
                if (deselect) {
                    option.deselect();
                }
                option.setInactiveStyles();
            }
        });
    }
    subscribeOptionChanges() {
        this.selectionChangeSubscription.unsubscribe();
        this.selectionChangeSubscription = this.optionSelectionChanges
            .pipe(filter((event) => event.isUserInput))
            .subscribe((event) => {
            event.source.select();
            event.source.setActiveStyles();
            this.activeItem = event.source;
            this.activeItemIndex = this.getOptionIndex(this.activeItem.value);
            this.clearSelectedOptions(event.source, true);
            this.selectionChange.emit(event.source);
        });
        this.optionMouseEnterSubscription.unsubscribe();
        this.optionMouseEnterSubscription = this.optionMouseEnter.subscribe((event) => {
            event.setActiveStyles();
            this.activeItem = event;
            this.activeItemIndex = this.getOptionIndex(this.activeItem.value);
            this.clearSelectedOptions(event);
        });
    }
}
TDSAutocompleteComponent.ɵfac = function TDSAutocompleteComponent_Factory(t) { return new (t || TDSAutocompleteComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$2.Directionality, 8), i0.ɵɵdirectiveInject(i2$1.TDSNoAnimationDirective, 9)); };
TDSAutocompleteComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSAutocompleteComponent, selectors: [["tds-autocomplete"]], contentQueries: function TDSAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
            i0.ɵɵcontentQuery(dirIndex, TDSAutocompleteOptionComponent, 5);
        }
        if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fromContentOptions = _t);
        }
    }, viewQuery: function TDSAutocompleteComponent_Query(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵviewQuery(TemplateRef, 5);
            i0.ɵɵviewQuery(_c0, 5);
            i0.ɵɵviewQuery(_c1, 5);
            i0.ɵɵviewQuery(TDSAutocompleteOptionComponent, 5);
        }
        if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panel = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fromDataSourceOptions = _t);
        }
    }, inputs: { width: "width", overlayClassName: "overlayClassName", overlayStyle: "overlayStyle", defaultActiveFirstOption: "defaultActiveFirstOption", backfill: "backfill", compareWith: "compareWith", dataSource: "dataSource", autoClose: "autoClose" }, outputs: { selectionChange: "selectionChange" }, exportAs: ["tdsAutocomplete"], ngContentSelectors: _c2, decls: 1, vars: 0, consts: [[1, "tds-select-dropdown", "tds-select-dropdown-placement-bottomLeft", "w-full", "bg-white", "py-1.5", "shadow-1-lg", "rounded", "dark:bg-d-neutral-3-200", 3, "ngClass", "ngStyle"], ["panel", ""], [1, "tds-custom-scroll", 2, "max-height", "256px", "overflow-y", "auto", "overflow-anchor", "none"], [1, "flex", "flex-col"], [4, "ngTemplateOutlet"], ["contentTemplate", ""], ["optionsTemplate", ""], [3, "value", "label", 4, "ngFor", "ngForOf"], [3, "value", "label"]], template: function TDSAutocompleteComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵprojectionDef();
            i0.ɵɵtemplate(0, TDSAutocompleteComponent_ng_template_0_Template, 9, 11, "ng-template");
        }
    }, directives: [i3.NgClass, i3.NgStyle, i3.NgTemplateOutlet, i3.NgForOf, TDSAutocompleteOptionComponent], encapsulation: 2, data: { animation: [slideMotion] }, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSAutocompleteComponent.prototype, "defaultActiveFirstOption", void 0);
__decorate([
    InputBoolean()
], TDSAutocompleteComponent.prototype, "backfill", void 0);
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSAutocompleteComponent, [{
            type: Component,
            args: [{
                    selector: 'tds-autocomplete',
                    exportAs: 'tdsAutocomplete',
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    template: `
    <ng-template>
      <div
        #panel
        class="tds-select-dropdown tds-select-dropdown-placement-bottomLeft w-full bg-white py-1.5 shadow-1-lg rounded dark:bg-d-neutral-3-200"
        [class.tds-select-dropdown-hidden]="!showPanel"
        [class.hidden]="!showPanel"
        [class.tds-select-dropdown-rtl]="dir === 'rtl'"
        [ngClass]="overlayClassName"
        [ngStyle]="overlayStyle"
        @slideMotion
        (@slideMotion.done)="onAnimationEvent($event)"
        [@.disabled]="noAnimation?.noAnimation"
      >
        <div style="max-height: 256px; overflow-y: auto; overflow-anchor: none;" class="tds-custom-scroll">
          <div class="flex flex-col">
            <ng-template *ngTemplateOutlet="dataSource ? optionsTemplate : contentTemplate"></ng-template>
          </div>
        </div>
      </div>
      <ng-template #contentTemplate>
        <ng-content></ng-content>
      </ng-template>
      <ng-template #optionsTemplate>
        <tds-auto-option
          *ngFor="let option of dataSource!"
          [value]="option"
          [label]="option && $any(option).label ? $any(option).label : $any(option)"
        >
          {{ option && $any(option).label ? $any(option).label : $any(option) }}
        </tds-auto-option>
      </ng-template>
    </ng-template>
  `,
                    animations: [slideMotion]
                }]
        }], function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1$2.Directionality, decorators: [{
                        type: Optional
                    }] }, { type: i2$1.TDSNoAnimationDirective, decorators: [{
                        type: Host
                    }, {
                        type: Optional
                    }] }];
    }, { width: [{
                type: Input
            }], overlayClassName: [{
                type: Input
            }], overlayStyle: [{
                type: Input
            }], defaultActiveFirstOption: [{
                type: Input
            }], backfill: [{
                type: Input
            }], compareWith: [{
                type: Input
            }], dataSource: [{
                type: Input
            }], autoClose: [{
                type: Input
            }], selectionChange: [{
                type: Output
            }], fromContentOptions: [{
                type: ContentChildren,
                args: [TDSAutocompleteOptionComponent, { descendants: true }]
            }], fromDataSourceOptions: [{
                type: ViewChildren,
                args: [TDSAutocompleteOptionComponent]
            }], template: [{
                type: ViewChild,
                args: [TemplateRef, { static: false }]
            }], panel: [{
                type: ViewChild,
                args: ['panel', { static: false }]
            }], content: [{
                type: ViewChild,
                args: ['content', { static: false }]
            }] });
})();

class TDSAutocompleteModule {
}
TDSAutocompleteModule.ɵfac = function TDSAutocompleteModule_Factory(t) { return new (t || TDSAutocompleteModule)(); };
TDSAutocompleteModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSAutocompleteModule });
TDSAutocompleteModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[BidiModule, CommonModule, OverlayModule, FormsModule, TDSOutletModule, TDSNoAnimationModule]] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSAutocompleteModule, [{
            type: NgModule,
            args: [{
                    declarations: [
                        TDSAutocompleteComponent,
                        TDSAutocompleteOptionComponent,
                        TDSAutocompleteTriggerDirective,
                        TDSAutocompleteOptgroupComponent
                    ],
                    exports: [
                        TDSAutocompleteComponent,
                        TDSAutocompleteOptionComponent,
                        TDSAutocompleteTriggerDirective,
                        TDSAutocompleteOptgroupComponent
                    ],
                    imports: [BidiModule, CommonModule, OverlayModule, FormsModule, TDSOutletModule, TDSNoAnimationModule]
                }]
        }], null, null);
})();
(function () {
    (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSAutocompleteModule, { declarations: [TDSAutocompleteComponent,
            TDSAutocompleteOptionComponent,
            TDSAutocompleteTriggerDirective,
            TDSAutocompleteOptgroupComponent], imports: [BidiModule, CommonModule, OverlayModule, FormsModule, TDSOutletModule, TDSNoAnimationModule], exports: [TDSAutocompleteComponent,
            TDSAutocompleteOptionComponent,
            TDSAutocompleteTriggerDirective,
            TDSAutocompleteOptgroupComponent] });
})();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSAutoOptionSelectionChange, TDSAutocompleteComponent, TDSAutocompleteModule, TDSAutocompleteOptgroupComponent, TDSAutocompleteOptionComponent, TDSAutocompleteTriggerDirective, TDS_AUTOCOMPLETE_VALUE_ACCESSOR, getTDSAutocompleteMissingPanelError };
//# sourceMappingURL=tds-ui-auto-complete.mjs.map
