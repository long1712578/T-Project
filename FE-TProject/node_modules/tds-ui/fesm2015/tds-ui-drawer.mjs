import { __decorate, __rest } from 'tslib';
import { ESCAPE } from '@angular/cdk/keycodes';
import * as i1 from '@angular/cdk/overlay';
import { OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import * as i7 from '@angular/cdk/portal';
import { ComponentPortal, TemplatePortal, CdkPortalOutlet, PortalModule } from '@angular/cdk/portal';
import * as i4 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Directive, EventEmitter, TemplateRef, Type, Injector, Component, ChangeDetectionStrategy, Optional, Inject, Input, Output, ViewChild, ContentChild, NgModule, Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { toCssPixel, TDSHelperObject, InputBoolean } from 'tds-ui/shared/utility';
import * as i2 from '@angular/cdk/a11y';
import * as i3 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i5 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';
import * as i6 from 'tds-ui/button';
import { TDSButtonModule } from 'tds-ui/button';

class TDSDrawerContentDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TDSDrawerContentDirective.ɵfac = function TDSDrawerContentDirective_Factory(t) { return new (t || TDSDrawerContentDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef)); };
TDSDrawerContentDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSDrawerContentDirective, selectors: [["", "tdsDrawerContent", ""]], exportAs: ["tdsDrawerContent"] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDrawerContentDirective, [{
            type: Directive,
            args: [{
                    selector: '[tdsDrawerContent]',
                    exportAs: 'tdsDrawerContent'
                }]
        }], function () { return [{ type: i0.TemplateRef }]; }, null);
})();

class TDSDrawerRef {
}

const _c0 = ["drawerTemplate"];
const _c1 = function (a0, a1) { return { "pointer-events-auto h-full opacity-100 transition-none   animate-drawer": a0, "pointer-events-none h-0 opacity-0 transition-[opacity,height] duration-[0.3s,0s] ease-[linear,ease] delay-[0s,0.3s]": a1 }; };
function TDSDrawerComponent_ng_template_0_div_1_Template(rf, ctx) {
    if (rf & 1) {
        const _r11 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "div", 13);
        i0.ɵɵlistener("click", function TDSDrawerComponent_ng_template_0_div_1_Template_div_click_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(2); return ctx_r10.maskClick(); });
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const ctx_r2 = i0.ɵɵnextContext(2);
        i0.ɵɵproperty("ngStyle", ctx_r2.maskStyle)("ngClass", i0.ɵɵpureFunction2(2, _c1, ctx_r2.isOpen, !ctx_r2.isOpen));
    }
}
function TDSDrawerComponent_ng_template_0_div_5_div_1_ng_container_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵelement(1, "div", 18);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r14 = i0.ɵɵnextContext(4);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("innerHTML", ctx_r14.title, i0.ɵɵsanitizeHtml);
    }
}
function TDSDrawerComponent_ng_template_0_div_5_div_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 16);
        i0.ɵɵtemplate(1, TDSDrawerComponent_ng_template_0_div_5_div_1_ng_container_1_Template, 2, 1, "ng-container", 17);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const ctx_r12 = i0.ɵɵnextContext(3);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r12.title);
    }
}
function TDSDrawerComponent_ng_template_0_div_5_div_2_ng_container_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵelement(1, "button", 20);
        i0.ɵɵelementContainerEnd();
    }
}
function TDSDrawerComponent_ng_template_0_div_5_div_2_Template(rf, ctx) {
    if (rf & 1) {
        const _r18 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "div", 19);
        i0.ɵɵlistener("click", function TDSDrawerComponent_ng_template_0_div_5_div_2_Template_div_click_0_listener() { i0.ɵɵrestoreView(_r18); const ctx_r17 = i0.ɵɵnextContext(3); return ctx_r17.closeClick(); });
        i0.ɵɵtemplate(1, TDSDrawerComponent_ng_template_0_div_5_div_2_ng_container_1_Template, 2, 0, "ng-container", 17);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const ctx_r13 = i0.ɵɵnextContext(3);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r13.closeIcon);
    }
}
const _c2 = function (a0) { return { "flex items-center justify-between px-4 py-3.5": a0 }; };
function TDSDrawerComponent_ng_template_0_div_5_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 3);
        i0.ɵɵtemplate(1, TDSDrawerComponent_ng_template_0_div_5_div_1_Template, 2, 1, "div", 14);
        i0.ɵɵtemplate(2, TDSDrawerComponent_ng_template_0_div_5_div_2_Template, 2, 1, "div", 15);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const ctx_r3 = i0.ɵɵnextContext(2);
        i0.ɵɵclassProp("tds-drawer-header", !!ctx_r3.title)("tds-drawer-header-no-title", !ctx_r3.title);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(7, _c2, !!ctx_r3.title));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx_r3.title);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx_r3.closable);
    }
}
function TDSDrawerComponent_ng_template_0_ng_template_7_Template(rf, ctx) { }
function TDSDrawerComponent_ng_template_0_ng_container_8_ng_container_1_ng_container_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainer(0);
    }
}
function TDSDrawerComponent_ng_template_0_ng_container_8_ng_container_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtemplate(1, TDSDrawerComponent_ng_template_0_ng_container_8_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 21);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r19 = i0.ɵɵnextContext(3);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngTemplateOutlet", ctx_r19.content)("ngTemplateOutletContext", ctx_r19.templateContext);
    }
}
function TDSDrawerComponent_ng_template_0_ng_container_8_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtemplate(1, TDSDrawerComponent_ng_template_0_ng_container_8_ng_container_1_Template, 2, 2, "ng-container", 11);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r5 = i0.ɵɵnextContext(2);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx_r5.isTemplateRef(ctx_r5.content));
    }
}
function TDSDrawerComponent_ng_template_0_ng_template_9_ng_container_0_ng_template_1_Template(rf, ctx) { }
function TDSDrawerComponent_ng_template_0_ng_template_9_ng_container_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵtemplate(1, TDSDrawerComponent_ng_template_0_ng_template_9_ng_container_0_ng_template_1_Template, 0, 0, "ng-template", 22);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r21 = i0.ɵɵnextContext(3);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngTemplateOutlet", ctx_r21.contentFromContentChild);
    }
}
function TDSDrawerComponent_ng_template_0_ng_template_9_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵtemplate(0, TDSDrawerComponent_ng_template_0_ng_template_9_ng_container_0_Template, 2, 1, "ng-container", 11);
    }
    if (rf & 2) {
        const ctx_r7 = i0.ɵɵnextContext(2);
        i0.ɵɵproperty("ngIf", ctx_r7.contentFromContentChild && (ctx_r7.isOpen || ctx_r7.inAnimation));
    }
}
function TDSDrawerComponent_ng_template_0_ng_content_11_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵprojection(0, 0, ["*ngIf", "!(content || contentFromContentChild)"]);
    }
}
function TDSDrawerComponent_ng_template_0_div_12_ng_container_1_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementContainerStart(0);
        i0.ɵɵelement(1, "div", 24);
        i0.ɵɵelementContainerEnd();
    }
    if (rf & 2) {
        const ctx_r23 = i0.ɵɵnextContext(3);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("innerHTML", ctx_r23.footer, i0.ɵɵsanitizeHtml);
    }
}
function TDSDrawerComponent_ng_template_0_div_12_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 23);
        i0.ɵɵtemplate(1, TDSDrawerComponent_ng_template_0_div_12_ng_container_1_Template, 2, 1, "ng-container", 17);
        i0.ɵɵelementEnd();
    }
    if (rf & 2) {
        const ctx_r9 = i0.ɵɵnextContext(2);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r9.footer);
    }
}
const _c3 = function (a0) { return { "tds-drawer-open delay-[0s] duration-300 transition-transform w-full": a0 }; };
const _c4 = function (a0) { return { "top-0": a0 }; };
const _c5 = function (a0) { return { "h-full": a0 }; };
function TDSDrawerComponent_ng_template_0_Template(rf, ctx) {
    if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 1);
        i0.ɵɵtemplate(1, TDSDrawerComponent_ng_template_0_div_1_Template, 1, 5, "div", 2);
        i0.ɵɵelementStart(2, "div", 3)(3, "div", 4)(4, "div", 5);
        i0.ɵɵtemplate(5, TDSDrawerComponent_ng_template_0_div_5_Template, 3, 9, "div", 6);
        i0.ɵɵelementStart(6, "div", 7);
        i0.ɵɵtemplate(7, TDSDrawerComponent_ng_template_0_ng_template_7_Template, 0, 0, "ng-template", 8);
        i0.ɵɵtemplate(8, TDSDrawerComponent_ng_template_0_ng_container_8_Template, 2, 1, "ng-container", 9);
        i0.ɵɵtemplate(9, TDSDrawerComponent_ng_template_0_ng_template_9_Template, 1, 1, "ng-template", null, 10, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtemplate(11, TDSDrawerComponent_ng_template_0_ng_content_11_Template, 1, 0, "ng-content", 11);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(12, TDSDrawerComponent_ng_template_0_div_12_Template, 2, 1, "div", 12);
        i0.ɵɵelementEnd()()()();
    }
    if (rf & 2) {
        const _r6 = i0.ɵɵreference(10);
        const ctx_r1 = i0.ɵɵnextContext();
        i0.ɵɵstyleProp("transform", ctx_r1.offsetTransform)("transition", ctx_r1.placementChanging ? "none" : null)("z-index", ctx_r1.zIndex);
        i0.ɵɵclassProp("tds-drawer-rtl", ctx_r1.dir === "rtl")("no-mask", !ctx_r1.mask)("tds-drawer-top", ctx_r1.placement === "top")("tds-drawer-bottom", ctx_r1.placement === "bottom")("tds-drawer-right", ctx_r1.placement === "right")("right-0", ctx_r1.placement === "right")("top-0", ctx_r1.isLeftOrRight)("tds-drawer-left", ctx_r1.placement === "left")("left-0", ctx_r1.placement === "left");
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(53, _c3, ctx_r1.isOpen));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx_r1.mask);
        i0.ɵɵadvance(1);
        i0.ɵɵclassMapInterpolate1("tds-drawer-content-wrapper absolute h-full transition-[transform,box-shadow] duration-[0.3s,0.3s] ease-[cubic-bezier(0.23, 1, 0.32, 1), cubic-bezier(0.23, 1, 0.32, 1)] delay-[0s,0s] ", ctx_r1.wrapClassName, "");
        i0.ɵɵstyleProp("width", ctx_r1.width)("height", ctx_r1.height)("transform", ctx_r1.transform)("transition", ctx_r1.placementChanging ? "none" : null);
        i0.ɵɵclassProp("right-0", ctx_r1.placement === "right")("left-0", ctx_r1.placement === "left")("top-0", ctx_r1.placement === "top")("bottom-0", ctx_r1.placement === "bottom");
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(55, _c4, ctx_r1.isLeftOrRight));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(57, _c5, ctx_r1.isLeftOrRight));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx_r1.title || ctx_r1.closable);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngStyle", ctx_r1.bodyStyle);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx_r1.content)("ngIfElse", _r6);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(ctx_r1.content || ctx_r1.contentFromContentChild));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx_r1.footer);
    }
}
const _c6 = ["*"];
const DRAWER_ANIMATE_DURATION = 300;
const TDS_CONFIG_MODULE_NAME = 'drawer';
class TDSDrawerComponent extends TDSDrawerRef {
    constructor(cdr, 
    // tslint:disable-next-line:no-any
    document, renderer, overlay, injector, changeDetectorRef, focusTrapFactory, viewContainerRef, overlayKeyboardDispatcher, directionality) {
        super();
        this.cdr = cdr;
        this.document = document;
        this.renderer = renderer;
        this.overlay = overlay;
        this.injector = injector;
        this.changeDetectorRef = changeDetectorRef;
        this.focusTrapFactory = focusTrapFactory;
        this.viewContainerRef = viewContainerRef;
        this.overlayKeyboardDispatcher = overlayKeyboardDispatcher;
        this.directionality = directionality;
        this.size = null;
        this.closeIcon = 'close';
        this.closable = true;
        this.maskClosable = true;
        this.mask = true;
        this.closeOnNavigation = true;
        this.noAnimation = false;
        this.keyboard = true;
        this.placement = 'right';
        this.maskStyle = {};
        this.bodyStyle = {};
        this.zIndex = 1000;
        this.offsetX = 0;
        this.offsetY = 0;
        this.componentInstance = null;
        this._width = 400;
        this._height = 400;
        this.onViewInit = new EventEmitter();
        this.onClose = new EventEmitter();
        this.visibleChange = new EventEmitter();
        this.destroy$ = new Subject();
        this.placementChanging = false;
        this.placementChangeTimeoutId = -1;
        this.isOpen = false;
        this.inAnimation = false;
        this.templateContext = {
            $implicit: undefined,
            drawerRef: this
        };
        this.onAfterOpen = new Subject();
        this.onAfterClose = new Subject();
        // from service config
        this.direction = undefined;
        this.dir = 'ltr';
    }
    set width(val) {
        this._width = val;
    }
    set height(val) {
        this._height = val;
    }
    get width() {
        return this.isLeftOrRight ? toCssPixel(this.getWidthBySize()) : null;
    }
    get height() {
        return !this.isLeftOrRight ? toCssPixel(this.getHeightBySize()) : null;
    }
    getWidthBySize() {
        if (TDSHelperObject.hasValue(this.size)) {
            let result = 400;
            switch (this.size) {
                case "sm":
                    result = 320;
                    break;
                case "lg":
                    result = 640;
                    break;
                case "xl":
                    result = 780;
                    break;
                //md
                default:
                    result = 400;
                    break;
            }
            return result;
        }
        else {
            return this._width;
        }
    }
    getHeightBySize() {
        if (TDSHelperObject.hasValue(this.size)) {
            let result = 400;
            switch (this.size) {
                case "sm":
                    result = 320;
                    break;
                case "lg":
                    result = 640;
                    break;
                //md
                default:
                    result = 400;
                    break;
            }
            return result;
        }
        else {
            return this._height;
        }
    }
    set visible(value) {
        this.isOpen = value;
    }
    get visible() {
        return this.isOpen;
    }
    get offsetTransform() {
        if (!this.isOpen || this.offsetX + this.offsetY === 0) {
            return null;
        }
        switch (this.placement) {
            case 'left':
                return `translateX(${this.offsetX}px)`;
            case 'right':
                return `translateX(-${this.offsetX}px)`;
            case 'top':
                return `translateY(${this.offsetY}px)`;
            case 'bottom':
                return `translateY(-${this.offsetY}px)`;
        }
    }
    get transform() {
        if (this.isOpen) {
            return null;
        }
        switch (this.placement) {
            case 'left':
                return `translateX(-100%)`;
            case 'right':
                return `translateX(100%)`;
            case 'top':
                return `translateY(-100%)`;
            case 'bottom':
                return `translateY(100%)`;
        }
    }
    get isLeftOrRight() {
        return this.placement === 'left' || this.placement === 'right';
    }
    get afterOpen() {
        return this.onAfterOpen.asObservable();
    }
    get afterClose() {
        return this.onAfterClose.asObservable();
    }
    isTemplateRef(value) {
        return value instanceof TemplateRef;
    }
    ngOnInit() {
        var _a;
        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
        this.dir = this.direction || this.directionality.value;
        this.attachOverlay();
        this.updateOverlayStyle();
        this.updateBodyOverflow();
        this.templateContext = { $implicit: this.contentParams, drawerRef: this };
        this.changeDetectorRef.detectChanges();
    }
    ngAfterViewInit() {
        this.attachBodyContent();
        setTimeout(() => {
            this.onViewInit.emit();
        });
    }
    ngAfterContentInit() {
        if (!(this.contentFromContentChild || this.content)) {
            console.warn('Usage `<ng-content></ng-content>` is deprecated, which will be removed in 12.0.0. Please instead use `<ng-template tdsDrawerContent></ng-template>` to declare the content of the drawer.');
        }
    }
    ngOnChanges(changes) {
        const { placement, visible } = changes;
        if (visible) {
            const value = changes.visible.currentValue;
            if (value) {
                this.open();
            }
            else {
                this.close();
            }
        }
        if (placement && !placement.isFirstChange()) {
            this.triggerPlacementChangeCycleOnce();
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        clearTimeout(this.placementChangeTimeoutId);
        this.disposeOverlay();
    }
    getAnimationDuration() {
        return this.noAnimation ? 0 : DRAWER_ANIMATE_DURATION;
    }
    // Disable the transition animation temporarily when the placement changing
    triggerPlacementChangeCycleOnce() {
        if (!this.noAnimation) {
            this.placementChanging = true;
            this.changeDetectorRef.markForCheck();
            clearTimeout(this.placementChangeTimeoutId);
            this.placementChangeTimeoutId = setTimeout(() => {
                this.placementChanging = false;
                this.changeDetectorRef.markForCheck();
            }, this.getAnimationDuration());
        }
    }
    close(result) {
        this.isOpen = false;
        this.inAnimation = true;
        this.visibleChange.emit(false);
        this.updateOverlayStyle();
        this.overlayKeyboardDispatcher.remove(this.overlayRef);
        this.changeDetectorRef.detectChanges();
        setTimeout(() => {
            this.updateBodyOverflow();
            this.restoreFocus();
            this.inAnimation = false;
            this.onAfterClose.next(result);
            this.onAfterClose.complete();
            this.componentInstance = null;
        }, this.getAnimationDuration());
    }
    open() {
        this.attachOverlay();
        this.isOpen = true;
        this.inAnimation = true;
        this.visibleChange.emit(true);
        this.overlayKeyboardDispatcher.add(this.overlayRef);
        this.updateOverlayStyle();
        this.updateBodyOverflow();
        this.savePreviouslyFocusedElement();
        this.trapFocus();
        this.changeDetectorRef.detectChanges();
        setTimeout(() => {
            this.inAnimation = false;
            this.changeDetectorRef.detectChanges();
            this.onAfterOpen.next();
        }, this.getAnimationDuration());
    }
    getContentComponent() {
        return this.componentInstance;
    }
    closeClick() {
        this.onClose.emit();
    }
    maskClick() {
        if (this.maskClosable && this.mask) {
            this.onClose.emit();
        }
    }
    attachBodyContent() {
        this.bodyPortalOutlet.dispose();
        if (this.content instanceof Type) {
            const childInjector = Injector.create({
                parent: this.injector,
                providers: [{ provide: TDSDrawerRef, useValue: this }]
            });
            const componentPortal = new ComponentPortal(this.content, null, childInjector);
            const componentRef = this.bodyPortalOutlet.attachComponentPortal(componentPortal);
            this.componentInstance = componentRef.instance;
            Object.assign(componentRef.instance, this.contentParams);
            componentRef.changeDetectorRef.detectChanges();
        }
    }
    attachOverlay() {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.drawerTemplate, this.viewContainerRef);
            this.overlayRef = this.overlay.create(this.getOverlayConfig());
        }
        if (this.overlayRef && !this.overlayRef.hasAttached()) {
            this.overlayRef.attach(this.portal);
            this.overlayRef.keydownEvents()
                .pipe(takeUntil(this.destroy$))
                .subscribe((event) => {
                if (event.keyCode === ESCAPE && this.isOpen && this.keyboard) {
                    this.onClose.emit();
                }
            });
            this.overlayRef
                .detachments()
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => {
                this.disposeOverlay();
            });
        }
    }
    disposeOverlay() {
        var _a;
        (_a = this.overlayRef) === null || _a === void 0 ? void 0 : _a.dispose();
        this.overlayRef = null;
    }
    getOverlayConfig() {
        return new OverlayConfig({
            disposeOnNavigation: this.closeOnNavigation,
            positionStrategy: this.overlay.position().global(),
            scrollStrategy: this.overlay.scrollStrategies.block()
        });
    }
    updateOverlayStyle() {
        if (this.overlayRef && this.overlayRef.overlayElement) {
            this.renderer.setStyle(this.overlayRef.overlayElement, 'pointer-events', this.isOpen ? 'auto' : 'none');
        }
    }
    updateBodyOverflow() {
        if (this.overlayRef) {
            if (this.isOpen) {
                this.overlayRef.getConfig().scrollStrategy.enable();
            }
            else {
                this.overlayRef.getConfig().scrollStrategy.disable();
            }
        }
    }
    savePreviouslyFocusedElement() {
        if (this.document && !this.previouslyFocusedElement) {
            this.previouslyFocusedElement = this.document.activeElement;
            // We need the extra check, because IE's svg element has no blur method.
            if (this.previouslyFocusedElement && typeof this.previouslyFocusedElement.blur === 'function') {
                this.previouslyFocusedElement.blur();
            }
        }
    }
    trapFocus() {
        if (!this.focusTrap && this.overlayRef && this.overlayRef.overlayElement) {
            this.focusTrap = this.focusTrapFactory.create(this.overlayRef.overlayElement);
            this.focusTrap.focusInitialElement();
        }
    }
    restoreFocus() {
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (this.previouslyFocusedElement && typeof this.previouslyFocusedElement.focus === 'function') {
            this.previouslyFocusedElement.focus();
        }
        if (this.focusTrap) {
            this.focusTrap.destroy();
        }
    }
}
TDSDrawerComponent.ɵfac = function TDSDrawerComponent_Factory(t) { return new (t || TDSDrawerComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(DOCUMENT, 8), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.Overlay), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.FocusTrapFactory), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i1.OverlayKeyboardDispatcher), i0.ɵɵdirectiveInject(i3.Directionality, 8)); };
TDSDrawerComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSDrawerComponent, selectors: [["tds-drawer"]], contentQueries: function TDSDrawerComponent_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
            i0.ɵɵcontentQuery(dirIndex, TDSDrawerContentDirective, 7, TemplateRef);
        }
        if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentFromContentChild = _t.first);
        }
    }, viewQuery: function TDSDrawerComponent_Query(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵviewQuery(_c0, 7);
            i0.ɵɵviewQuery(CdkPortalOutlet, 5);
        }
        if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.drawerTemplate = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.bodyPortalOutlet = _t.first);
        }
    }, inputs: { size: "size", content: "content", closeIcon: "closeIcon", closable: "closable", maskClosable: "maskClosable", mask: "mask", closeOnNavigation: "closeOnNavigation", noAnimation: "noAnimation", keyboard: "keyboard", title: "title", footer: "footer", placement: "placement", maskStyle: "maskStyle", bodyStyle: "bodyStyle", wrapClassName: "wrapClassName", zIndex: "zIndex", offsetX: "offsetX", offsetY: "offsetY", width: "width", height: "height", visible: "visible" }, outputs: { onViewInit: "onViewInit", onClose: "onClose", visibleChange: "visibleChange" }, exportAs: ["tdsDrawer"], features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c6, decls: 2, vars: 0, consts: [["drawerTemplate", ""], [1, "tds-drawer", 3, "ngClass"], ["class", "tds-drawer-mask absolute top-0 left-0  w-full bg-black bg-opacity-40  ", 3, "ngStyle", "ngClass", "click", 4, "ngIf"], [3, "ngClass"], [1, "tds-drawer-content", "bg-white", "dark:bg-d-neutral-3-200", "h-full", "w-full", "relative", "overflow-auto", "border-0", "z-10", "text-neutral-1-900", "dark:text-d-neutral-1-900"], [1, "tds-drawer-wrapper-body", "flex", "flex-col", "w-full", 3, "ngClass"], [3, "tds-drawer-header", "tds-drawer-header-no-title", "ngClass", 4, "ngIf"], [1, "tds-drawer-body", "flex-auto", "w-full", "p-4", 3, "ngStyle"], ["cdkPortalOutlet", ""], [4, "ngIf", "ngIfElse"], ["contentElseTemp", ""], [4, "ngIf"], ["class", "tds-drawer-footer w-full ", 4, "ngIf"], [1, "tds-drawer-mask", "absolute", "top-0", "left-0", "w-full", "bg-black", "bg-opacity-40", 3, "ngStyle", "ngClass", "click"], ["class", "tds-drawer-title flex-auto", 4, "ngIf"], ["aria-label", "Close", "class", "tds-drawer-close text-neutral-1-500 dark:text-d-neutral-1-500 focus:outline-none font-semibold rounded-md box-border", "style", "--scroll-bar: 0px;", 3, "click", 4, "ngIf"], [1, "tds-drawer-title", "flex-auto"], [4, "tdsStringTemplateOutlet"], [1, "break-words", "text-header-1", "font-semibold", 3, "innerHTML"], ["aria-label", "Close", 1, "tds-drawer-close", "text-neutral-1-500", "dark:text-d-neutral-1-500", "focus:outline-none", "font-semibold", "rounded-md", "box-border", 2, "--scroll-bar", "0px", 3, "click"], ["tds-button-close", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngTemplateOutlet"], [1, "tds-drawer-footer", "w-full"], [1, "w-full", "p-4", 3, "innerHTML"]], template: function TDSDrawerComponent_Template(rf, ctx) {
        if (rf & 1) {
            i0.ɵɵprojectionDef();
            i0.ɵɵtemplate(0, TDSDrawerComponent_ng_template_0_Template, 13, 59, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
        }
    }, directives: [i4.NgClass, i4.NgIf, i4.NgStyle, i5.TDSStringTemplateOutletDirective, i6.TDSButtonCloseComponent, i7.CdkPortalOutlet, i4.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSDrawerComponent.prototype, "closable", void 0);
__decorate([
    InputBoolean()
], TDSDrawerComponent.prototype, "maskClosable", void 0);
__decorate([
    InputBoolean()
], TDSDrawerComponent.prototype, "mask", void 0);
__decorate([
    InputBoolean()
], TDSDrawerComponent.prototype, "closeOnNavigation", void 0);
__decorate([
    InputBoolean()
], TDSDrawerComponent.prototype, "noAnimation", void 0);
__decorate([
    InputBoolean()
], TDSDrawerComponent.prototype, "keyboard", void 0);
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDrawerComponent, [{
            type: Component,
            args: [{
                    selector: 'tds-drawer',
                    exportAs: 'tdsDrawer',
                    template: `
    <ng-template #drawerTemplate>
      <div
        class="tds-drawer "
        [class.tds-drawer-rtl]="dir === 'rtl'"
        [class.no-mask]="!mask"
        [class.tds-drawer-top]="placement === 'top'"
        [class.tds-drawer-bottom]="placement === 'bottom'"
        [class.tds-drawer-right]="placement === 'right'"
        [class.right-0]="placement === 'right'"
        [class.top-0]="isLeftOrRight"
        [class.tds-drawer-left]="placement === 'left'"
        [class.left-0]="placement === 'left'"
        [style.transform]="offsetTransform"
        [style.transition]="placementChanging ? 'none' : null"
        [style.zIndex]="zIndex"
        [ngClass]="{'tds-drawer-open delay-[0s] duration-300 transition-transform w-full':isOpen}"
      >
        <div class="tds-drawer-mask absolute top-0 left-0  w-full bg-black bg-opacity-40  " (click)="maskClick()" *ngIf="mask" [ngStyle]="maskStyle"
        [ngClass]="{'pointer-events-auto h-full opacity-100 transition-none   animate-drawer':isOpen,'pointer-events-none h-0 opacity-0 transition-[opacity,height] duration-[0.3s,0s] ease-[linear,ease] delay-[0s,0.3s]':!isOpen}"
        ></div>
        <div
          class="tds-drawer-content-wrapper absolute h-full transition-[transform,box-shadow] duration-[0.3s,0.3s] ease-[cubic-bezier(0.23, 1, 0.32, 1), cubic-bezier(0.23, 1, 0.32, 1)] delay-[0s,0s] {{ wrapClassName }}"
          [ngClass]="{'top-0':isLeftOrRight}"
          [class.right-0]="placement === 'right'"         
          [class.left-0]="placement === 'left'"
          [class.top-0]="placement === 'top'"
          [class.bottom-0]="placement === 'bottom'"
          [style.width]="width"
          [style.height]="height"
          [style.transform]="transform"
          [style.transition]="placementChanging ? 'none' : null"
        >
          <div class="tds-drawer-content  bg-white dark:bg-d-neutral-3-200 h-full w-full relative overflow-auto border-0 z-10 text-neutral-1-900 dark:text-d-neutral-1-900 ">
            <div class="tds-drawer-wrapper-body flex flex-col  w-full" [ngClass]="{'h-full':isLeftOrRight}">
              <div *ngIf="title || closable" 
              [class.tds-drawer-header]="!!title"
               [class.tds-drawer-header-no-title]="!title" 
               [ngClass]="{'flex items-center justify-between px-4 py-3.5':!!title}"
               >
                <div *ngIf="title" class="tds-drawer-title flex-auto">
                  <ng-container *tdsStringTemplateOutlet="title">
                    <div class="break-words text-header-1 font-semibold  " [innerHTML]="title"></div>
                  </ng-container>
                </div>
                <div *ngIf="closable" (click)="closeClick()" aria-label="Close" class="tds-drawer-close text-neutral-1-500 dark:text-d-neutral-1-500 focus:outline-none font-semibold rounded-md box-border" style="--scroll-bar: 0px;">
                  <ng-container *tdsStringTemplateOutlet="closeIcon; let closeIcon">
                    <button tds-button-close></button>
                  </ng-container>
                </div>
              </div>
              <div class="tds-drawer-body flex-auto w-full p-4" [ngStyle]="bodyStyle">
                <ng-template cdkPortalOutlet></ng-template>
                <ng-container *ngIf="content; else contentElseTemp">
                  <ng-container *ngIf="isTemplateRef(content)">
                    <ng-container *ngTemplateOutlet="$any(content); context: templateContext"></ng-container>
                  </ng-container>
                </ng-container>
                <ng-template #contentElseTemp>
                  <ng-container *ngIf="contentFromContentChild && (isOpen || inAnimation)">
                    <ng-template [ngTemplateOutlet]="contentFromContentChild"></ng-template>
                  </ng-container>
                </ng-template>
                <ng-content *ngIf="!(content || contentFromContentChild)"></ng-content>
              </div>
              <div *ngIf="footer" class="tds-drawer-footer w-full ">
                <ng-container *tdsStringTemplateOutlet="footer">
                  <div class="w-full p-4" [innerHTML]="footer"></div>
                </ng-container>
              </div>
            </div>
          </div>
        </div>
      </div>
    </ng-template>
  `,
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], function () {
        return [{ type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [DOCUMENT]
                    }] }, { type: i0.Renderer2 }, { type: i1.Overlay }, { type: i0.Injector }, { type: i0.ChangeDetectorRef }, { type: i2.FocusTrapFactory }, { type: i0.ViewContainerRef }, { type: i1.OverlayKeyboardDispatcher }, { type: i3.Directionality, decorators: [{
                        type: Optional
                    }] }];
    }, { size: [{
                type: Input
            }], content: [{
                type: Input
            }], closeIcon: [{
                type: Input
            }], closable: [{
                type: Input
            }], maskClosable: [{
                type: Input
            }], mask: [{
                type: Input
            }], closeOnNavigation: [{
                type: Input
            }], noAnimation: [{
                type: Input
            }], keyboard: [{
                type: Input
            }], title: [{
                type: Input
            }], footer: [{
                type: Input
            }], placement: [{
                type: Input
            }], maskStyle: [{
                type: Input
            }], bodyStyle: [{
                type: Input
            }], wrapClassName: [{
                type: Input
            }], zIndex: [{
                type: Input
            }], offsetX: [{
                type: Input
            }], offsetY: [{
                type: Input
            }], width: [{
                type: Input
            }], height: [{
                type: Input
            }], visible: [{
                type: Input
            }], onViewInit: [{
                type: Output
            }], onClose: [{
                type: Output
            }], visibleChange: [{
                type: Output
            }], drawerTemplate: [{
                type: ViewChild,
                args: ['drawerTemplate', { static: true }]
            }], bodyPortalOutlet: [{
                type: ViewChild,
                args: [CdkPortalOutlet, { static: false }]
            }], contentFromContentChild: [{
                type: ContentChild,
                args: [TDSDrawerContentDirective, { static: true, read: TemplateRef }]
            }] });
})();

class TDSDrawerServiceModule {
}
TDSDrawerServiceModule.ɵfac = function TDSDrawerServiceModule_Factory(t) { return new (t || TDSDrawerServiceModule)(); };
TDSDrawerServiceModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSDrawerServiceModule });
TDSDrawerServiceModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({});
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDrawerServiceModule, [{
            type: NgModule
        }], null, null);
})();

class TDSDrawerModule {
}
TDSDrawerModule.ɵfac = function TDSDrawerModule_Factory(t) { return new (t || TDSDrawerModule)(); };
TDSDrawerModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSDrawerModule });
TDSDrawerModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            BidiModule,
            CommonModule,
            OverlayModule,
            PortalModule,
            TDSOutletModule,
            TDSDrawerServiceModule,
            TDSButtonModule
        ]] });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDrawerModule, [{
            type: NgModule,
            args: [{
                    imports: [
                        BidiModule,
                        CommonModule,
                        OverlayModule,
                        PortalModule,
                        TDSOutletModule,
                        TDSDrawerServiceModule,
                        TDSButtonModule
                    ],
                    exports: [TDSDrawerComponent, TDSDrawerContentDirective],
                    declarations: [TDSDrawerComponent, TDSDrawerContentDirective]
                }]
        }], null, null);
})();
(function () {
    (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSDrawerModule, { declarations: [TDSDrawerComponent, TDSDrawerContentDirective], imports: [BidiModule,
            CommonModule,
            OverlayModule,
            PortalModule,
            TDSOutletModule,
            TDSDrawerServiceModule,
            TDSButtonModule], exports: [TDSDrawerComponent, TDSDrawerContentDirective] });
})();

class DrawerBuilderForService {
    constructor(overlay, options) {
        this.overlay = overlay;
        this.options = options;
        this.unsubscribe$ = new Subject();
        /** pick {@link TDSDrawerOptions.onCancel} and omit this option */
        const _a = this.options, { onCancel } = _a, componentOption = __rest(_a, ["onCancel"]);
        this.overlayRef = this.overlay.create();
        this.drawerRef = this.overlayRef.attach(new ComponentPortal(TDSDrawerComponent)).instance;
        this.updateOptions(componentOption);
        // Prevent repeatedly open drawer when tap focus element.
        this.drawerRef.savePreviouslyFocusedElement();
        this.drawerRef.onViewInit.pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
            this.drawerRef.open();
        });
        this.drawerRef.onClose.subscribe(() => {
            if (onCancel) {
                onCancel().then(canClose => {
                    if (canClose !== false) {
                        this.drawerRef.close();
                    }
                });
            }
            else {
                this.drawerRef.close();
            }
        });
        this.drawerRef.afterClose.pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
            this.overlayRef.dispose();
            this.drawerRef = null;
            this.unsubscribe$.next();
            this.unsubscribe$.complete();
        });
    }
    getInstance() {
        return this.drawerRef;
    }
    updateOptions(options) {
        Object.assign(this.drawerRef, options);
    }
}
class TDSDrawerService {
    constructor(overlay) {
        this.overlay = overlay;
    }
    create(options) {
        return new DrawerBuilderForService(this.overlay, options).getInstance();
    }
}
TDSDrawerService.ɵfac = function TDSDrawerService_Factory(t) { return new (t || TDSDrawerService)(i0.ɵɵinject(i1.Overlay)); };
TDSDrawerService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TDSDrawerService, factory: TDSDrawerService.ɵfac, providedIn: TDSDrawerServiceModule });
(function () {
    (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDrawerService, [{
            type: Injectable,
            args: [{ providedIn: TDSDrawerServiceModule }]
        }], function () { return [{ type: i1.Overlay }]; }, null);
})();

/**
 * Generated bundle index. Do not edit.
 */

export { DRAWER_ANIMATE_DURATION, DrawerBuilderForService, TDSDrawerComponent, TDSDrawerContentDirective, TDSDrawerModule, TDSDrawerRef, TDSDrawerService, TDSDrawerServiceModule };
//# sourceMappingURL=tds-ui-drawer.mjs.map
