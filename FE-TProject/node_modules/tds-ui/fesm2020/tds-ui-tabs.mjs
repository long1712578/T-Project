import * as i0 from '@angular/core';
import { Component, Input, Directive, Optional, Inject, EventEmitter, ChangeDetectionStrategy, ViewEncapsulation, Output, ViewChild, ContentChildren, Host, Self, InjectionToken, TemplateRef, ContentChild, QueryList, NgModule } from '@angular/core';
import * as i1 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';
import { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';
import { reqAnimFrame } from 'tds-ui/core/animation';
import * as i7 from '@angular/cdk/a11y';
import { FocusKeyManager, A11yModule } from '@angular/cdk/a11y';
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { hasModifierKey, SPACE, ENTER, DOWN_ARROW, RIGHT_ARROW, UP_ARROW, LEFT_ARROW } from '@angular/cdk/keycodes';
import { fromEvent, Subscription, animationFrameScheduler, asapScheduler, Subject, of, merge } from 'rxjs';
import { takeUntil, auditTime, startWith, first, filter, delay } from 'rxjs/operators';
import * as i1$1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2 from 'tds-ui/dropdown';
import { TDSDropDownModule } from 'tds-ui/dropdown';
import * as i1$2 from '@angular/cdk/overlay';
import * as i2$1 from 'tds-ui/core/resize-observers';
import * as i3 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import { __decorate } from 'tslib';
import * as i1$3 from '@angular/router';
import { NavigationEnd } from '@angular/router';
import { InputBoolean } from 'tds-ui/shared/utility';
import { ObserversModule } from '@angular/cdk/observers';
import { PlatformModule } from '@angular/cdk/platform';
import { CdkScrollableModule } from '@angular/cdk/scrolling';
import * as i1$4 from 'tds-ui/core/config';
import { WithConfig } from 'tds-ui/core/config';
import { wrapIntoObservable } from 'tds-ui/core/util';

function TDSTabAddButtonComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
class TDSTabAddButtonComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.addIcon = 'plus';
        this.element = this.elementRef.nativeElement;
    }
    getElementWidth() {
        return this.element?.offsetWidth || 0;
    }
    getElementHeight() {
        return this.element?.offsetHeight || 0;
    }
}
TDSTabAddButtonComponent.ɵfac = function TDSTabAddButtonComponent_Factory(t) { return new (t || TDSTabAddButtonComponent)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSTabAddButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTabAddButtonComponent, selectors: [["tds-tab-add-button"], ["button", "tds-tab-add-button", ""]], hostAttrs: ["aria-label", "Add tab", "type", "button", 1, "tds-tabs-nav-add"], inputs: { addIcon: "addIcon" }, decls: 1, vars: 1, consts: [[4, "tdsStringTemplateOutlet"]], template: function TDSTabAddButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TDSTabAddButtonComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("tdsStringTemplateOutlet", ctx.addIcon);
    } }, directives: [i1.TDSStringTemplateOutletDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabAddButtonComponent, [{
        type: Component,
        args: [{
                selector: 'tds-tab-add-button, button[tds-tab-add-button]',
                template: `
    <ng-container *tdsStringTemplateOutlet="addIcon; let icon">
     
    </ng-container>
  `,
                host: {
                    class: 'tds-tabs-nav-add',
                    'aria-label': 'Add tab',
                    type: 'button'
                }
            }]
    }], function () { return [{ type: i0.ElementRef }]; }, { addIcon: [{
            type: Input
        }] }); })();

class TDSTabsInkBarDirective {
    constructor(elementRef, ngZone, animationMode) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.animationMode = animationMode;
        this.position = 'horizontal';
        this.animated = true;
    }
    get _animated() {
        return this.animationMode !== 'NoopAnimations' && this.animated;
    }
    alignToElement(element) {
        this.ngZone.runOutsideAngular(() => {
            reqAnimFrame(() => this.setStyles(element));
        });
    }
    setStyles(element) {
        const inkBar = this.elementRef.nativeElement;
        if (this.position === 'horizontal') {
            inkBar.style.top = '';
            inkBar.style.height = '';
            inkBar.style.left = this.getLeftPosition(element);
            inkBar.style.width = this.getElementWidth(element);
        }
        else {
            inkBar.style.left = '';
            inkBar.style.width = '';
            inkBar.style.top = this.getTopPosition(element);
            inkBar.style.height = this.getElementHeight(element);
        }
    }
    getLeftPosition(element) {
        return element ? (element.offsetLeft || 0) + 'px' : '0';
    }
    getElementWidth(element) {
        return element ? (element.offsetWidth || 0) + 'px' : '0';
    }
    getTopPosition(element) {
        return element ? (element.offsetTop || 0) + 'px' : '0';
    }
    getElementHeight(element) {
        return element ? (element.offsetHeight || 0) + 'px' : '0';
    }
}
TDSTabsInkBarDirective.ɵfac = function TDSTabsInkBarDirective_Factory(t) { return new (t || TDSTabsInkBarDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };
TDSTabsInkBarDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSTabsInkBarDirective, selectors: [["tds-tabs-ink-bar"], ["", "tds-tabs-ink-bar", ""]], hostAttrs: [1, "tds-tabs-ink-bar"], hostVars: 2, hostBindings: function TDSTabsInkBarDirective_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("tds-tabs-ink-bar-animated", ctx._animated);
    } }, inputs: { position: "position", animated: "animated" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabsInkBarDirective, [{
        type: Directive,
        args: [{
                selector: 'tds-tabs-ink-bar, [tds-tabs-ink-bar]',
                host: {
                    class: 'tds-tabs-ink-bar',
                    '[class.tds-tabs-ink-bar-animated]': '_animated'
                }
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }]; }, { position: [{
            type: Input
        }], animated: [{
            type: Input
        }] }); })();

class TDSTabNavItemDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.disabled = false;
        this.active = false;
        this.el = elementRef.nativeElement;
        this.parentElement = this.el.parentElement;
    }
    focus() {
        this.el.focus();
    }
    get width() {
        return this.parentElement.offsetWidth;
    }
    get height() {
        return this.parentElement.offsetHeight;
    }
    get left() {
        return this.parentElement.offsetLeft;
    }
    get top() {
        return this.parentElement.offsetTop;
    }
}
TDSTabNavItemDirective.ɵfac = function TDSTabNavItemDirective_Factory(t) { return new (t || TDSTabNavItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSTabNavItemDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSTabNavItemDirective, selectors: [["", "tdsTabNavItem", ""]], inputs: { disabled: "disabled", tab: "tab", active: "active" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabNavItemDirective, [{
        type: Directive,
        args: [{
                selector: '[tdsTabNavItem]'
            }]
    }], function () { return [{ type: i0.ElementRef }]; }, { disabled: [{
            type: Input
        }], tab: [{
            type: Input
        }], active: [{
            type: Input
        }] }); })();

const _c0$4 = function () { return { minWidth: "46px" }; };
function TDSTabNavOperationComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r6 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 5, 6);
    i0.ɵɵlistener("visibleChange", function TDSTabNavOperationComponent_button_0_Template_button_visibleChange_0_listener($event) { i0.ɵɵrestoreView(_r6); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.menuVisChange($event); })("mouseenter", function TDSTabNavOperationComponent_button_0_Template_button_mouseenter_0_listener() { i0.ɵɵrestoreView(_r6); const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.showItems(); });
    i0.ɵɵelement(2, "i", 7);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r1 = i0.ɵɵreference(2);
    i0.ɵɵproperty("tdsDropdownMenu", _r1)("overlayStyle", i0.ɵɵpureFunction0(3, _c0$4))("matchWidthElement", null);
} }
function TDSTabNavOperationComponent_div_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r8 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(item_r8.tab.label);
} }
const _c1$3 = function (a1) { return { visible: false, active: a1 }; };
function TDSTabNavOperationComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 8);
    i0.ɵɵlistener("click", function TDSTabNavOperationComponent_div_4_Template_div_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r12); const item_r8 = restoredCtx.$implicit; const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.onSelect(item_r8); })("contextmenu", function TDSTabNavOperationComponent_div_4_Template_div_contextmenu_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r12); const item_r8 = restoredCtx.$implicit; const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.onContextmenu(item_r8, $event); });
    i0.ɵɵtemplate(1, TDSTabNavOperationComponent_div_4_ng_container_1_Template, 2, 1, "ng-container", 9);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r8 = ctx.$implicit;
    i0.ɵɵclassProp("tds-tabs-dropdown-menu-item-disabled", item_r8.disabled);
    i0.ɵɵproperty("selected", item_r8.active)("disabled", item_r8.disabled);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("tdsStringTemplateOutlet", item_r8.tab.label)("tdsStringTemplateOutletContext", i0.ɵɵpureFunction1(6, _c1$3, item_r8.active));
} }
function TDSTabNavOperationComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r15 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 10);
    i0.ɵɵlistener("click", function TDSTabNavOperationComponent_button_5_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r15); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.addClicked.emit(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("addIcon", ctx_r3.addIcon);
} }
class TDSTabNavOperationComponent {
    constructor(cdr, elementRef) {
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.items = [];
        this.addable = false;
        this.addIcon = 'plus';
        this.hidenNextBtn = false;
        this.nextClicked = new EventEmitter();
        this.addClicked = new EventEmitter();
        this.selected = new EventEmitter();
        this.closeAnimationWaitTimeoutId = -1;
        this.menuOpened = false;
        this.element = this.elementRef.nativeElement;
    }
    onSelect(item) {
        if (!item.disabled) {
            // ignore onCanDeactivate
            item.tab.tabClick.emit();
            this.selected.emit(item);
        }
    }
    onContextmenu(item, e) {
        if (!item.disabled) {
            item.tab.tabContextmenu.emit(e);
        }
    }
    showItems() {
        clearTimeout(this.closeAnimationWaitTimeoutId);
        this.menuOpened = true;
        this.cdr.markForCheck();
    }
    menuVisChange(visible) {
        if (!visible) {
            this.closeAnimationWaitTimeoutId = setTimeout(() => {
                this.menuOpened = false;
                this.cdr.markForCheck();
            }, 150);
        }
    }
    getElementWidth() {
        return this.element?.offsetWidth || 0;
    }
    getElementHeight() {
        return this.element?.offsetHeight || 0;
    }
    ngOnDestroy() {
        clearTimeout(this.closeAnimationWaitTimeoutId);
    }
    onclickNext(e) {
        this.nextClicked.emit();
    }
}
TDSTabNavOperationComponent.ɵfac = function TDSTabNavOperationComponent_Factory(t) { return new (t || TDSTabNavOperationComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSTabNavOperationComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTabNavOperationComponent, selectors: [["tds-tab-nav-operation"]], hostAttrs: [1, "tds-tabs-nav-operations", "flex", "items-stretch"], hostVars: 4, hostBindings: function TDSTabNavOperationComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("tds-tabs-nav-operations-hidden", ctx.items.length === 0)("hidden", ctx.items.length === 0);
    } }, inputs: { items: "items", addable: "addable", addIcon: "addIcon", hidenNextBtn: "hidenNextBtn" }, outputs: { nextClicked: "nextClicked", addClicked: "addClicked", selected: "selected" }, exportAs: ["tdsTabNavOperation"], decls: 6, vars: 3, consts: [["tds-dropdown", "", "class", "tds-tabs-nav-more px-2 py-4", "type", "button", "tabindex", "-1", "aria-hidden", "true", "overlayClassName", "tds-tabs-dropdown", "style", "box-shadow:-12px 0 8px -4px rgb(0 0 0 / 8%)", 3, "tdsDropdownMenu", "overlayStyle", "matchWidthElement", "visibleChange", "mouseenter", 4, "ngIf"], ["menu", "tdsDropdownMenu"], [1, "w-full", "py-2", "overflow-y-auto", "tds-custom-scroll", "bg-white", "dark:bg-d-neutral-3-200", "shadow-1-lg", 2, "max-height", "200px", "min-width", "150px"], ["tds-dropdown-item", "", "class", "tds-tabs-dropdown-menu-item", 3, "tds-tabs-dropdown-menu-item-disabled", "selected", "disabled", "click", "contextmenu", 4, "ngFor", "ngForOf"], ["tds-tab-add-button", "", 3, "addIcon", "click", 4, "ngIf"], ["tds-dropdown", "", "type", "button", "tabindex", "-1", "aria-hidden", "true", "overlayClassName", "tds-tabs-dropdown", 1, "tds-tabs-nav-more", "px-2", "py-4", 2, "box-shadow", "-12px 0 8px -4px rgb(0 0 0 / 8%)", 3, "tdsDropdownMenu", "overlayStyle", "matchWidthElement", "visibleChange", "mouseenter"], ["dropdownTrigger", "tdsDropdown"], [1, "tdsi-three-dots-horizon-fill"], ["tds-dropdown-item", "", 1, "tds-tabs-dropdown-menu-item", 3, "selected", "disabled", "click", "contextmenu"], [4, "tdsStringTemplateOutlet", "tdsStringTemplateOutletContext"], ["tds-tab-add-button", "", 3, "addIcon", "click"]], template: function TDSTabNavOperationComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TDSTabNavOperationComponent_button_0_Template, 3, 4, "button", 0);
        i0.ɵɵelementStart(1, "tds-dropdown-menu", null, 1)(3, "div", 2);
        i0.ɵɵtemplate(4, TDSTabNavOperationComponent_div_4_Template, 2, 8, "div", 3);
        i0.ɵɵelementEnd()();
        i0.ɵɵtemplate(5, TDSTabNavOperationComponent_button_5_Template, 1, 1, "button", 4);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", !ctx.hidenNextBtn);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngForOf", ctx.items);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.addable);
    } }, directives: [i1$1.NgIf, i2.TDSDropDownDirective, i2.TDSDropdownMenuComponent, i1$1.NgForOf, i2.TDSDropDownItemDirective, i1.TDSStringTemplateOutletDirective, TDSTabAddButtonComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabNavOperationComponent, [{
        type: Component,
        args: [{ selector: 'tds-tab-nav-operation', exportAs: 'tdsTabNavOperation', preserveWhitespaces: false, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, host: {
                    class: 'tds-tabs-nav-operations flex items-stretch',
                    '[class.tds-tabs-nav-operations-hidden]': 'items.length === 0',
                    '[class.hidden]': 'items.length === 0'
                }, template: "<button *ngIf=\"!hidenNextBtn\" tds-dropdown class=\"tds-tabs-nav-more px-2 py-4\" type=\"button\" tabindex=\"-1\"\r\n  aria-hidden=\"true\" overlayClassName=\"tds-tabs-dropdown\" #dropdownTrigger=\"tdsDropdown\" [tdsDropdownMenu]=\"menu\"\r\n  [overlayStyle]=\"{ minWidth: '46px' }\" [matchWidthElement]=\"null\" (visibleChange)=\"menuVisChange($event)\"\r\n  (mouseenter)=\"showItems()\" style=\"box-shadow:-12px 0 8px -4px rgb(0 0 0 / 8%)\">\r\n  <i class='tdsi-three-dots-horizon-fill'></i>\r\n</button>\r\n<tds-dropdown-menu #menu=\"tdsDropdownMenu\">\r\n  <div class=\"w-full py-2  overflow-y-auto tds-custom-scroll bg-white dark:bg-d-neutral-3-200 shadow-1-lg\"\r\n    style=\"max-height: 200px;min-width: 150px\">\r\n    <div tds-dropdown-item *ngFor=\"let item of items\" class=\"tds-tabs-dropdown-menu-item\"\r\n      [class.tds-tabs-dropdown-menu-item-disabled]=\"item.disabled\" [selected]=\"item.active\" [disabled]=\"item.disabled\"\r\n      (click)=\"onSelect(item)\" (contextmenu)=\"onContextmenu(item, $event)\">\r\n      <ng-container *tdsStringTemplateOutlet=\"item.tab.label; context: { visible: false ,active:item.active }\">{{\r\n        item.tab.label }}</ng-container>\r\n    </div>\r\n  </div>\r\n</tds-dropdown-menu>\r\n<button *ngIf=\"addable\" tds-tab-add-button [addIcon]=\"addIcon\" (click)=\"addClicked.emit()\"></button>" }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, { items: [{
            type: Input
        }], addable: [{
            type: Input
        }], addIcon: [{
            type: Input
        }], hidenNextBtn: [{
            type: Input
        }], nextClicked: [{
            type: Output
        }], addClicked: [{
            type: Output
        }], selected: [{
            type: Output
        }] }); })();

const MIN_SWIPE_DISTANCE = 0.1;
const STOP_SWIPE_DISTANCE = 0.01;
const REFRESH_INTERVAL = 20;
const SPEED_OFF_MULTIPLE = 0.995 ** REFRESH_INTERVAL;
class TDSTabScrollListDirective {
    constructor(ngZone, elementRef) {
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.lastWheelDirection = null;
        this.lastWheelTimestamp = 0;
        this.lastTimestamp = 0;
        this.lastTimeDiff = 0;
        this.lastMixedWheel = 0;
        this.lastWheelPrevent = false;
        this.touchPosition = null;
        this.lastOffset = null;
        this.motion = -1;
        this.unsubscribe = () => void 0;
        this.offsetChange = new EventEmitter();
        this.tabScroll = new EventEmitter();
        this.onTouchEnd = (e) => {
            if (!this.touchPosition) {
                return;
            }
            const lastOffset = this.lastOffset;
            const lastTimeDiff = this.lastTimeDiff;
            this.lastOffset = this.touchPosition = null;
            if (lastOffset) {
                const distanceX = lastOffset.x / lastTimeDiff;
                const distanceY = lastOffset.y / lastTimeDiff;
                const absX = Math.abs(distanceX);
                const absY = Math.abs(distanceY);
                // Skip swipe if low distance
                if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) {
                    return;
                }
                let currentX = distanceX;
                let currentY = distanceY;
                this.motion = window.setInterval(() => {
                    if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
                        window.clearInterval(this.motion);
                        return;
                    }
                    currentX *= SPEED_OFF_MULTIPLE;
                    currentY *= SPEED_OFF_MULTIPLE;
                    this.onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL, e);
                }, REFRESH_INTERVAL);
            }
        };
        this.onTouchMove = (e) => {
            if (!this.touchPosition) {
                return;
            }
            e.preventDefault();
            const { screenX, screenY } = e.touches[0];
            const offsetX = screenX - this.touchPosition.x;
            const offsetY = screenY - this.touchPosition.y;
            this.onOffset(offsetX, offsetY, e);
            const now = Date.now();
            this.lastTimeDiff = now - this.lastTimestamp;
            this.lastTimestamp = now;
            this.lastOffset = { x: offsetX, y: offsetY };
            this.touchPosition = { x: screenX, y: screenY };
        };
        this.onTouchStart = (e) => {
            const { screenX, screenY } = e.touches[0];
            this.touchPosition = { x: screenX, y: screenY };
            window.clearInterval(this.motion);
        };
        this.onWheel = (e) => {
            const { deltaX, deltaY } = e;
            let mixed;
            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);
            if (absX === absY) {
                mixed = this.lastWheelDirection === 'x' ? deltaX : deltaY;
            }
            else if (absX > absY) {
                mixed = deltaX;
                this.lastWheelDirection = 'x';
            }
            else {
                mixed = deltaY;
                this.lastWheelDirection = 'y';
            }
            // Optimize mac touch scroll
            const now = Date.now();
            const absMixed = Math.abs(mixed);
            if (now - this.lastWheelTimestamp > 100 || absMixed - this.lastMixedWheel > 10) {
                this.lastWheelPrevent = false;
            }
            this.onOffset(-mixed, -mixed, e);
            if (e.defaultPrevented || this.lastWheelPrevent) {
                this.lastWheelPrevent = true;
            }
            this.lastWheelTimestamp = now;
            this.lastMixedWheel = absMixed;
        };
    }
    ngOnInit() {
        this.unsubscribe = this.ngZone.runOutsideAngular(() => {
            const el = this.elementRef.nativeElement;
            const wheel$ = fromEvent(el, 'wheel');
            const touchstart$ = fromEvent(el, 'touchstart');
            const touchmove$ = fromEvent(el, 'touchmove');
            const touchend$ = fromEvent(el, 'touchend');
            const subscription = new Subscription();
            subscription.add(this.subscribeWrap('wheel', wheel$, this.onWheel));
            subscription.add(this.subscribeWrap('touchstart', touchstart$, this.onTouchStart));
            subscription.add(this.subscribeWrap('touchmove', touchmove$, this.onTouchMove));
            subscription.add(this.subscribeWrap('touchend', touchend$, this.onTouchEnd));
            return () => {
                subscription.unsubscribe();
            };
        });
    }
    subscribeWrap(type, observable, handler) {
        return observable.subscribe(event => {
            this.tabScroll.emit({
                type,
                event
            });
            if (!event.defaultPrevented) {
                handler(event);
            }
        });
    }
    onOffset(x, y, event) {
        this.ngZone.run(() => {
            this.offsetChange.emit({
                x,
                y,
                event
            });
        });
    }
    ngOnDestroy() {
        this.unsubscribe();
    }
}
TDSTabScrollListDirective.ɵfac = function TDSTabScrollListDirective_Factory(t) { return new (t || TDSTabScrollListDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSTabScrollListDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSTabScrollListDirective, selectors: [["", "tdsTabScrollList", ""]], outputs: { offsetChange: "offsetChange", tabScroll: "tabScroll" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabScrollListDirective, [{
        type: Directive,
        args: [{
                selector: '[tdsTabScrollList]'
            }]
    }], function () { return [{ type: i0.NgZone }, { type: i0.ElementRef }]; }, { offsetChange: [{
            type: Output
        }], tabScroll: [{
            type: Output
        }] }); })();

const _c0$3 = ["navWarp"];
const _c1$2 = ["navList"];
function TDSTabNavBarComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 8);
    i0.ɵɵlistener("click", function TDSTabNavBarComponent_button_5_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.addClicked.emit(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("addIcon", ctx_r2.addIcon);
} }
function TDSTabNavBarComponent_div_8_ng_template_1_Template(rf, ctx) { }
function TDSTabNavBarComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵtemplate(1, TDSTabNavBarComponent_div_8_ng_template_1_Template, 0, 0, "ng-template", 10);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r3.extraTemplate);
} }
const _c2$2 = ["*"];
const RESIZE_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;
const CSS_TRANSFORM_TIME = 150;
class TDSTabNavBarComponent {
    constructor(cdr, ngZone, viewportRuler, tdsResizeObserver, dir) {
        this.cdr = cdr;
        this.ngZone = ngZone;
        this.viewportRuler = viewportRuler;
        this.tdsResizeObserver = tdsResizeObserver;
        this.dir = dir;
        // static ngAcceptInputType_selectedIndex: NumberInput;
        this.indexFocused = new EventEmitter();
        this.selectFocusedIndex = new EventEmitter();
        this.addClicked = new EventEmitter();
        this.tabScroll = new EventEmitter();
        this.position = 'horizontal';
        this.tabPosition = 'top';
        this.addable = false;
        this.hideBar = false;
        this.hidenNextBtn = false;
        this.addIcon = 'plus';
        this.inkBarAnimated = true;
        this.translate = null;
        this.transformX = 0;
        this.transformY = 0;
        this.pingLeft = false;
        this.pingRight = false;
        this.pingTop = false;
        this.pingBottom = false;
        this.hiddenItems = [];
        this.destroy$ = new Subject();
        this._selectedIndex = 0;
        this.wrapperWidth = 0;
        this.wrapperHeight = 0;
        this.scrollListWidth = 0;
        this.scrollListHeight = 0;
        this.operationWidth = 0;
        this.operationHeight = 0;
        this.addButtonWidth = 0;
        this.addButtonHeight = 0;
        this.selectedIndexChanged = false;
        this.lockAnimationTimeoutId = -1;
        this.cssTransformTimeWaitingId = -1;
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(value) {
        const newValue = coerceNumberProperty(value);
        if (this._selectedIndex !== newValue) {
            this._selectedIndex = value;
            this.selectedIndexChanged = true;
            if (this.keyManager) {
                this.keyManager.updateActiveItem(value);
            }
        }
    }
    /** Tracks which element has focus; used for keyboard navigation */
    get focusIndex() {
        return this.keyManager ? this.keyManager.activeItemIndex : 0;
    }
    /** When the focus index is set, we must manually send focus to the correct label */
    set focusIndex(value) {
        if (!this.isValidIndex(value) || this.focusIndex === value || !this.keyManager) {
            return;
        }
        this.keyManager.setActiveItem(value);
    }
    get showAddButton() {
        return this.hiddenItems.length === 0 && this.addable;
    }
    ngOnInit() { }
    ngAfterViewInit() {
        const dirChange = this.dir ? this.dir.change : of(null);
        const resize = this.viewportRuler.change(150);
        const realign = () => {
            this.updateScrollListPosition();
            this.alignInkBarToSelectedTab();
        };
        this.keyManager = new FocusKeyManager(this.items)
            .withHorizontalOrientation(this.getLayoutDirection())
            .withWrap();
        this.keyManager.updateActiveItem(this.selectedIndex);
        reqAnimFrame(realign);
        merge(this.tdsResizeObserver.observe(this.navWarpRef), this.tdsResizeObserver.observe(this.navListRef))
            .pipe(takeUntil(this.destroy$), auditTime(16, RESIZE_SCHEDULER))
            .subscribe(() => {
            realign();
        });
        merge(dirChange, resize, this.items.changes)
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => {
            Promise.resolve().then(realign);
            this.keyManager.withHorizontalOrientation(this.getLayoutDirection());
        });
        this.keyManager.change.pipe(takeUntil(this.destroy$)).subscribe(newFocusIndex => {
            this.indexFocused.emit(newFocusIndex);
            this.setTabFocus(newFocusIndex);
            this.scrollToTab(this.keyManager.activeItem);
        });
    }
    ngAfterContentChecked() {
        if (this.selectedIndexChanged) {
            this.updateScrollListPosition();
            this.alignInkBarToSelectedTab();
            this.selectedIndexChanged = false;
            this.cdr.markForCheck();
        }
    }
    ngOnDestroy() {
        clearTimeout(this.lockAnimationTimeoutId);
        clearTimeout(this.cssTransformTimeWaitingId);
        this.destroy$.next();
        this.destroy$.complete();
    }
    onSelectedFromMenu(tab) {
        const tabIndex = this.items.toArray().findIndex(e => e === tab);
        if (tabIndex !== -1) {
            this.keyManager.updateActiveItem(tabIndex);
            if (this.focusIndex !== this.selectedIndex) {
                this.selectFocusedIndex.emit(this.focusIndex);
                this.scrollToTab(tab);
            }
        }
    }
    onOffsetChange(e) {
        if (this.position === 'horizontal') {
            if (this.lockAnimationTimeoutId === -1) {
                if (this.transformX >= 0 && e.x > 0) {
                    return;
                }
                if (this.transformX <= this.wrapperWidth - this.scrollListWidth && e.x < 0) {
                    return;
                }
            }
            e.event.preventDefault();
            this.transformX = this.clampTransformX(this.transformX + e.x);
            this.setTransform(this.transformX, 0);
        }
        else {
            if (this.lockAnimationTimeoutId === -1) {
                if (this.transformY >= 0 && e.y > 0) {
                    return;
                }
                if (this.transformY <= this.wrapperHeight - this.scrollListHeight && e.y < 0) {
                    return;
                }
            }
            e.event.preventDefault();
            this.transformY = this.clampTransformY(this.transformY + e.y);
            this.setTransform(0, this.transformY);
        }
        this.lockAnimation();
        this.setVisibleRange();
        this.setPingStatus();
    }
    handleKeydown(event) {
        const inNavigationList = this.navWarpRef.nativeElement.contains(event.target);
        if (hasModifierKey(event) || !inNavigationList) {
            return;
        }
        switch (event.keyCode) {
            case LEFT_ARROW:
            case UP_ARROW:
            case RIGHT_ARROW:
            case DOWN_ARROW:
                this.lockAnimation();
                this.keyManager.onKeydown(event);
                break;
            case ENTER:
            case SPACE:
                if (this.focusIndex !== this.selectedIndex) {
                    this.selectFocusedIndex.emit(this.focusIndex);
                }
                break;
            default:
                this.keyManager.onKeydown(event);
        }
    }
    onNextTab() {
        const tabIndex = this.selectedIndex + 1; //this.items.toArray().findIndex(e => e === tab);
        if (tabIndex < this.items.toArray().length) {
            this.keyManager.updateActiveItem(tabIndex);
            if (this.focusIndex !== this.selectedIndex) {
                this.selectFocusedIndex.emit(this.focusIndex);
                this.scrollToTab(this.items.toArray()[tabIndex]);
            }
        }
    }
    onPrevTab() {
        const tabIndex = this.selectedIndex - 1;
        if (tabIndex > -1) {
            this.keyManager.updateActiveItem(tabIndex);
            if (this.focusIndex !== this.selectedIndex) {
                this.selectFocusedIndex.emit(this.focusIndex);
                this.scrollToTab(this.items.toArray()[tabIndex]);
            }
        }
    }
    get showNextTab() {
        if (this.hiddenItems.length == 0) {
            return false;
        }
        const index = this.items.toArray().findIndex(e => e === this.hiddenItems[this.hiddenItems.length - 1]);
        return !(index > -1 && index < this.items.toArray().length - 1);
    }
    get showPrevTab() {
        if (this.hiddenItems.length == 0) {
            return false;
        }
        const index = this.items.toArray().findIndex(e => e === this.hiddenItems[0]);
        return index <= 0;
    }
    get showDropdownTab() {
        return this.items.toArray().length >= 10;
    }
    isValidIndex(index) {
        if (!this.items) {
            return true;
        }
        const tab = this.items ? this.items.toArray()[index] : null;
        return !!tab && !tab.disabled;
    }
    scrollToTab(tab) {
        if (!this.items.find(e => e === tab)) {
            return;
        }
        const tabs = this.items.toArray();
        if (this.position === 'horizontal') {
            let newTransform = this.transformX;
            if (this.getLayoutDirection() === 'rtl') {
                const right = tabs[0].left + tabs[0].width - tab.left - tab.width;
                if (right < this.transformX) {
                    newTransform = right;
                }
                else if (right + tab.width > this.transformX + this.wrapperWidth) {
                    newTransform = right + tab.width - this.wrapperWidth;
                }
            }
            else if (tab.left < -this.transformX) {
                newTransform = -tab.left;
            }
            else if (tab.left + tab.width > -this.transformX + this.wrapperWidth) {
                newTransform = -(tab.left + tab.width - this.wrapperWidth);
            }
            this.transformX = newTransform;
            this.transformY = 0;
            this.setTransform(newTransform, 0);
        }
        else {
            let newTransform = this.transformY;
            if (tab.top < -this.transformY) {
                newTransform = -tab.top;
            }
            else if (tab.top + tab.height > -this.transformY + this.wrapperHeight) {
                newTransform = -(tab.top + tab.height - this.wrapperHeight);
            }
            this.transformY = newTransform;
            this.transformX = 0;
            this.setTransform(0, newTransform);
        }
        clearTimeout(this.cssTransformTimeWaitingId);
        this.cssTransformTimeWaitingId = setTimeout(() => {
            this.setVisibleRange();
        }, CSS_TRANSFORM_TIME);
    }
    lockAnimation() {
        if (this.lockAnimationTimeoutId === -1) {
            this.ngZone.runOutsideAngular(() => {
                this.navListRef.nativeElement.style.transition = 'none';
                this.lockAnimationTimeoutId = setTimeout(() => {
                    this.navListRef.nativeElement.style.transition = '';
                    this.lockAnimationTimeoutId = -1;
                }, CSS_TRANSFORM_TIME);
            });
        }
    }
    setTransform(x, y) {
        this.navListRef.nativeElement.style.transform = `translate(${x}px, ${y}px)`;
    }
    clampTransformX(transform) {
        const scrollWidth = this.wrapperWidth - this.scrollListWidth;
        if (this.getLayoutDirection() === 'rtl') {
            return Math.max(Math.min(scrollWidth, transform), 0);
        }
        else {
            return Math.min(Math.max(scrollWidth, transform), 0);
        }
    }
    clampTransformY(transform) {
        return Math.min(Math.max(this.wrapperHeight - this.scrollListHeight, transform), 0);
    }
    updateScrollListPosition() {
        this.resetSizes();
        this.transformX = this.clampTransformX(this.transformX);
        this.transformY = this.clampTransformY(this.transformY);
        this.setVisibleRange();
        this.setPingStatus();
        if (this.keyManager) {
            this.keyManager.updateActiveItem(this.keyManager.activeItemIndex);
            if (this.keyManager.activeItem) {
                this.scrollToTab(this.keyManager.activeItem);
            }
        }
    }
    resetSizes() {
        this.addButtonWidth = this.addBtnRef ? this.addBtnRef.getElementWidth() : 0;
        this.addButtonHeight = this.addBtnRef ? this.addBtnRef.getElementHeight() : 0;
        this.operationWidth = this.operationRef.getElementWidth();
        this.operationHeight = this.operationRef.getElementHeight();
        this.wrapperWidth = this.navWarpRef.nativeElement.offsetWidth || 0;
        this.wrapperHeight = this.navWarpRef.nativeElement.offsetHeight || 0;
        this.scrollListHeight = this.navListRef.nativeElement.offsetHeight || 0;
        this.scrollListWidth = this.navListRef.nativeElement.offsetWidth || 0;
    }
    alignInkBarToSelectedTab() {
        const selectedItem = this.items && this.items.length ? this.items.toArray()[this.selectedIndex] : null;
        const selectedItemElement = selectedItem ? selectedItem.elementRef.nativeElement : null;
        if (selectedItemElement) {
            /**
             * .tds-tabs-nav-list - Target offset parent element
             *   └──.tds-tabs-tab
             *        └──.tds-tabs-tab-btn - Currently focused element
             */
            this.inkBar.alignToElement(selectedItemElement.parentElement);
        }
    }
    setPingStatus() {
        const ping = {
            top: false,
            right: false,
            bottom: false,
            left: false
        };
        const navWarp = this.navWarpRef.nativeElement;
        if (this.position === 'horizontal') {
            if (this.getLayoutDirection() === 'rtl') {
                ping.right = this.transformX > 0;
                ping.left = this.transformX + this.wrapperWidth < this.scrollListWidth;
            }
            else {
                ping.left = this.transformX < 0;
                ping.right = -this.transformX + this.wrapperWidth < this.scrollListWidth;
            }
        }
        else {
            ping.top = this.transformY < 0;
            ping.bottom = -this.transformY + this.wrapperHeight < this.scrollListHeight;
        }
        Object.keys(ping).forEach(pos => {
            const className = `tds-tabs-nav-wrap-ping-${pos}`;
            if (ping[pos]) {
                navWarp.classList.add(className);
            }
            else {
                navWarp.classList.remove(className);
            }
        });
    }
    setVisibleRange() {
        let unit;
        let position;
        let transformSize;
        let basicSize;
        let tabContentSize;
        let addSize;
        const tabs = this.items.toArray();
        const DEFAULT_SIZE = { width: 0, height: 0, left: 0, top: 0, right: 0 };
        const getOffset = (index) => {
            let offset;
            const size = tabs[index] || DEFAULT_SIZE;
            if (position === 'right') {
                offset = tabs[0].left + tabs[0].width - tabs[index].left - tabs[index].width;
            }
            else {
                offset = size[position];
            }
            return offset;
        };
        if (this.position === 'horizontal') {
            unit = 'width';
            basicSize = this.wrapperWidth;
            tabContentSize = this.scrollListWidth - (this.hiddenItems.length ? this.operationWidth : 0);
            addSize = this.addButtonWidth;
            transformSize = Math.abs(this.transformX);
            if (this.getLayoutDirection() === 'rtl') {
                position = 'right';
                this.pingRight = this.transformX > 0;
                this.pingLeft = this.transformX + this.wrapperWidth < this.scrollListWidth;
            }
            else {
                this.pingLeft = this.transformX < 0;
                this.pingRight = -this.transformX + this.wrapperWidth < this.scrollListWidth;
                position = 'left';
            }
        }
        else {
            unit = 'height';
            basicSize = this.wrapperHeight;
            tabContentSize = this.scrollListHeight - (this.hiddenItems.length ? this.operationHeight : 0);
            addSize = this.addButtonHeight;
            position = 'top';
            transformSize = -this.transformY;
            this.pingTop = this.transformY < 0;
            this.pingBottom = -this.transformY + this.wrapperHeight < this.scrollListHeight;
        }
        let mergedBasicSize = basicSize;
        if (tabContentSize + addSize > basicSize) {
            mergedBasicSize = basicSize - addSize;
        }
        if (!tabs.length) {
            this.hiddenItems = [];
            this.cdr.markForCheck();
            return;
        }
        const len = tabs.length;
        let endIndex = len;
        for (let i = 0; i < len; i += 1) {
            const offset = getOffset(i);
            const size = tabs[i] || DEFAULT_SIZE;
            if (offset + size[unit] > transformSize + mergedBasicSize) {
                endIndex = i - 1;
                break;
            }
        }
        let startIndex = 0;
        for (let i = len - 1; i >= 0; i -= 1) {
            const offset = getOffset(i);
            if (offset < transformSize) {
                startIndex = i + 1;
                break;
            }
        }
        const startHiddenTabs = tabs.slice(0, startIndex);
        const endHiddenTabs = tabs.slice(endIndex + 1);
        this.hiddenItems = [...startHiddenTabs, ...endHiddenTabs];
        this.cdr.markForCheck();
    }
    getLayoutDirection() {
        return this.dir && this.dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    setTabFocus(_tabIndex) { }
    ngOnChanges(changes) {
        const { position } = changes;
        // The first will be aligning in ngAfterViewInit
        if (position && !position.isFirstChange()) {
            this.alignInkBarToSelectedTab();
            this.lockAnimation();
            this.updateScrollListPosition();
        }
    }
}
TDSTabNavBarComponent.ɵfac = function TDSTabNavBarComponent_Factory(t) { return new (t || TDSTabNavBarComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$2.ViewportRuler), i0.ɵɵdirectiveInject(i2$1.TDSResizeObserver), i0.ɵɵdirectiveInject(i3.Directionality, 8)); };
TDSTabNavBarComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTabNavBarComponent, selectors: [["tds-tabs-nav"]], contentQueries: function TDSTabNavBarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, TDSTabNavItemDirective, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, viewQuery: function TDSTabNavBarComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$3, 7);
        i0.ɵɵviewQuery(_c1$2, 7);
        i0.ɵɵviewQuery(TDSTabNavOperationComponent, 7);
        i0.ɵɵviewQuery(TDSTabAddButtonComponent, 5);
        i0.ɵɵviewQuery(TDSTabsInkBarDirective, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.navWarpRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.navListRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.operationRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.addBtnRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inkBar = _t.first);
    } }, hostAttrs: ["role", "tablist", 1, "tds-tabs-nav", "relative", "flex", "flex-none", "items-center"], hostBindings: function TDSTabNavBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("keydown", function TDSTabNavBarComponent_keydown_HostBindingHandler($event) { return ctx.handleKeydown($event); });
    } }, inputs: { position: "position", tabPosition: "tabPosition", addable: "addable", hideBar: "hideBar", hidenNextBtn: "hidenNextBtn", addIcon: "addIcon", inkBarAnimated: "inkBarAnimated", extraTemplate: "extraTemplate", selectedIndex: "selectedIndex" }, outputs: { indexFocused: "indexFocused", selectFocusedIndex: "selectFocusedIndex", addClicked: "addClicked", tabScroll: "tabScroll" }, exportAs: ["tdsTabsNav"], features: [i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2$2, decls: 9, vars: 21, consts: [[1, "tds-tabs-nav-wrap", "relative", "flex", "flex-auto", "items-stretch", "overflow-hidden", "whitespace-nowrap", "w-full", 2, "transform", "translate(0)"], ["navWarp", ""], ["tdsTabScrollList", "", 1, "tds-tabs-nav-list", "relative", "flex", "w-full", 3, "offsetChange", "tabScroll"], ["navList", ""], ["tds-tab-add-button", "", 3, "addIcon", "click", 4, "ngIf"], ["tds-tabs-ink-bar", "", 1, "absolute", "pointer-events-none", 3, "hidden", "position", "animated"], [3, "addIcon", "addable", "items", "hidenNextBtn", "nextClicked", "addClicked", "selected"], ["class", "tds-tabs-extra-content", 4, "ngIf"], ["tds-tab-add-button", "", 3, "addIcon", "click"], [1, "tds-tabs-extra-content"], [3, "ngTemplateOutlet"]], template: function TDSTabNavBarComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵelementStart(0, "div", 0, 1)(2, "div", 2, 3);
        i0.ɵɵlistener("offsetChange", function TDSTabNavBarComponent_Template_div_offsetChange_2_listener($event) { return ctx.onOffsetChange($event); })("tabScroll", function TDSTabNavBarComponent_Template_div_tabScroll_2_listener($event) { return ctx.tabScroll.emit($event); });
        i0.ɵɵprojection(4);
        i0.ɵɵtemplate(5, TDSTabNavBarComponent_button_5_Template, 1, 1, "button", 4);
        i0.ɵɵelement(6, "div", 5);
        i0.ɵɵelementEnd()();
        i0.ɵɵelementStart(7, "tds-tab-nav-operation", 6);
        i0.ɵɵlistener("nextClicked", function TDSTabNavBarComponent_Template_tds_tab_nav_operation_nextClicked_7_listener() { return ctx.onNextTab(); })("addClicked", function TDSTabNavBarComponent_Template_tds_tab_nav_operation_addClicked_7_listener() { return ctx.addClicked.emit(); })("selected", function TDSTabNavBarComponent_Template_tds_tab_nav_operation_selected_7_listener($event) { return ctx.onSelectedFromMenu($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(8, TDSTabNavBarComponent_div_8_Template, 2, 1, "div", 7);
    } if (rf & 2) {
        i0.ɵɵstyleProp("box-shadow", ctx.hiddenItems.length > 0 ? "inset 10px 0 8px -8px rgb(0 0 0 / 8%)" : "");
        i0.ɵɵclassProp("tds-tabs-nav-wrap-ping-left", ctx.pingLeft)("tds-tabs-nav-wrap-ping-right", ctx.pingRight)("tds-tabs-nav-wrap-ping-top", ctx.pingTop)("tds-tabs-nav-wrap-ping-bottom", ctx.pingBottom);
        i0.ɵɵadvance(2);
        i0.ɵɵclassProp("flex-col", ctx.position === "vertical");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.showAddButton);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("hidden", ctx.hideBar)("position", ctx.position)("animated", ctx.inkBarAnimated);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("addIcon", ctx.addIcon)("addable", ctx.addable)("items", ctx.hiddenItems)("hidenNextBtn", ctx.hidenNextBtn);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.extraTemplate);
    } }, directives: [TDSTabScrollListDirective, i1$1.NgIf, TDSTabAddButtonComponent, TDSTabsInkBarDirective, TDSTabNavOperationComponent, i1$1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabNavBarComponent, [{
        type: Component,
        args: [{ selector: 'tds-tabs-nav', exportAs: 'tdsTabsNav', preserveWhitespaces: false, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, host: {
                    role: 'tablist',
                    class: 'tds-tabs-nav relative flex flex-none items-center',
                    '(keydown)': 'handleKeydown($event)'
                }, template: "\r\n<div class=\"tds-tabs-nav-wrap relative flex flex-auto items-stretch overflow-hidden whitespace-nowrap w-full\"\r\n    [class.tds-tabs-nav-wrap-ping-left]=\"pingLeft\" [class.tds-tabs-nav-wrap-ping-right]=\"pingRight\"\r\n    [class.tds-tabs-nav-wrap-ping-top]=\"pingTop\" [class.tds-tabs-nav-wrap-ping-bottom]=\"pingBottom\"\r\n    style=\"transform: translate(0);\" #navWarp\r\n    [style.boxShadow]=\"hiddenItems.length > 0 ? 'inset 10px 0 8px -8px rgb(0 0 0 / 8%)':'' \"\r\n    >\r\n    <div class=\"tds-tabs-nav-list relative flex w-full\" [class.flex-col]=\"position === 'vertical'\" #navList tdsTabScrollList\r\n        (offsetChange)=\"onOffsetChange($event)\" (tabScroll)=\"tabScroll.emit($event)\">\r\n        <ng-content></ng-content>\r\n        <button *ngIf=\"showAddButton\" tds-tab-add-button [addIcon]=\"addIcon\" (click)=\"addClicked.emit()\"></button>\r\n        <div class='absolute pointer-events-none' tds-tabs-ink-bar [hidden]=\"hideBar\" [position]=\"position\"\r\n            [animated]=\"inkBarAnimated\"></div>\r\n    </div>\r\n</div>\r\n<tds-tab-nav-operation  (nextClicked)=\"onNextTab()\" (addClicked)=\"addClicked.emit()\"\r\n    (selected)=\"onSelectedFromMenu($event)\" [addIcon]=\"addIcon\" [addable]=\"addable\" [items]=\"hiddenItems\" [hidenNextBtn]=\"hidenNextBtn\" >\r\n</tds-tab-nav-operation>\r\n<div class=\"tds-tabs-extra-content\" *ngIf=\"extraTemplate\">\r\n    <ng-template [ngTemplateOutlet]=\"extraTemplate\"></ng-template>\r\n</div>" }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1$2.ViewportRuler }, { type: i2$1.TDSResizeObserver }, { type: i3.Directionality, decorators: [{
                type: Optional
            }] }]; }, { indexFocused: [{
            type: Output
        }], selectFocusedIndex: [{
            type: Output
        }], addClicked: [{
            type: Output
        }], tabScroll: [{
            type: Output
        }], position: [{
            type: Input
        }], tabPosition: [{
            type: Input
        }], addable: [{
            type: Input
        }], hideBar: [{
            type: Input
        }], hidenNextBtn: [{
            type: Input
        }], addIcon: [{
            type: Input
        }], inkBarAnimated: [{
            type: Input
        }], extraTemplate: [{
            type: Input
        }], selectedIndex: [{
            type: Input
        }], navWarpRef: [{
            type: ViewChild,
            args: ['navWarp', { static: true }]
        }], navListRef: [{
            type: ViewChild,
            args: ['navList', { static: true }]
        }], operationRef: [{
            type: ViewChild,
            args: [TDSTabNavOperationComponent, { static: true }]
        }], addBtnRef: [{
            type: ViewChild,
            args: [TDSTabAddButtonComponent, { static: false }]
        }], inkBar: [{
            type: ViewChild,
            args: [TDSTabsInkBarDirective, { static: true }]
        }], items: [{
            type: ContentChildren,
            args: [TDSTabNavItemDirective, { descendants: true }]
        }] }); })();

const _c0$2 = ["tds-tab-body", ""];
function TDSTabBodyComponent_ng_container_0_ng_template_1_Template(rf, ctx) { }
function TDSTabBodyComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, TDSTabBodyComponent_ng_container_0_ng_template_1_Template, 0, 0, "ng-template", 1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r0.content);
} }
class TDSTabBodyComponent {
    constructor() {
        this.content = null;
        this.active = false;
        this.tabPaneAnimated = true;
        this.forceRender = false;
    }
}
TDSTabBodyComponent.ɵfac = function TDSTabBodyComponent_Factory(t) { return new (t || TDSTabBodyComponent)(); };
TDSTabBodyComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTabBodyComponent, selectors: [["", "tds-tab-body", ""]], hostAttrs: [1, "tds-tabs-tabpane", "flex-none", "w-full", "outline-none"], hostVars: 14, hostBindings: function TDSTabBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("tabindex", ctx.active ? 0 : -1)("aria-hidden", !ctx.active);
        i0.ɵɵstyleProp("visibility", ctx.tabPaneAnimated ? ctx.active ? null : "hidden" : null)("height", ctx.tabPaneAnimated ? ctx.active ? null : 0 : null)("overflow-y", ctx.tabPaneAnimated ? ctx.active ? null : "none" : null)("display", !ctx.tabPaneAnimated ? ctx.active ? null : "none" : null);
        i0.ɵɵclassProp("tds-tabs-tabpane-active", ctx.active)("m-0", ctx.active);
    } }, inputs: { content: "content", active: "active", tabPaneAnimated: "tabPaneAnimated", forceRender: "forceRender" }, exportAs: ["tdsTabBody"], attrs: _c0$2, decls: 1, vars: 1, consts: [[4, "ngIf"], [3, "ngTemplateOutlet"]], template: function TDSTabBodyComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TDSTabBodyComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.active || ctx.forceRender);
    } }, directives: [i1$1.NgIf, i1$1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabBodyComponent, [{
        type: Component,
        args: [{
                selector: '[tds-tab-body]',
                exportAs: 'tdsTabBody',
                preserveWhitespaces: false,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <ng-container *ngIf="active || forceRender">
      <ng-template [ngTemplateOutlet]="content"></ng-template>
    </ng-container>
  `,
                host: {
                    class: 'tds-tabs-tabpane flex-none w-full outline-none',
                    '[class.tds-tabs-tabpane-active]': 'active',
                    '[class.m-0]': 'active',
                    '[attr.tabindex]': 'active ? 0 : -1',
                    '[attr.aria-hidden]': '!active',
                    '[style.visibility]': 'tabPaneAnimated ? active ? null : "hidden" : null',
                    '[style.height]': 'tabPaneAnimated ? active ? null : 0 : null',
                    '[style.overflow-y]': 'tabPaneAnimated ? active ? null : "none" : null',
                    '[style.display]': '!tabPaneAnimated ? active ? null : "none" : null'
                }
            }]
    }], null, { content: [{
            type: Input
        }], active: [{
            type: Input
        }], tabPaneAnimated: [{
            type: Input
        }], forceRender: [{
            type: Input
        }] }); })();

function TDSTabCloseButtonComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
class TDSTabCloseButtonComponent {
    constructor() {
        this.closeIcon = 'close';
    }
}
TDSTabCloseButtonComponent.ɵfac = function TDSTabCloseButtonComponent_Factory(t) { return new (t || TDSTabCloseButtonComponent)(); };
TDSTabCloseButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTabCloseButtonComponent, selectors: [["tds-tab-close-button"], ["button", "tds-tab-close-button", ""]], hostAttrs: ["aria-label", "Close tab", "type", "button", 1, "tds-tabs-tab-remove"], inputs: { closeIcon: "closeIcon" }, decls: 1, vars: 1, consts: [[4, "tdsStringTemplateOutlet"]], template: function TDSTabCloseButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TDSTabCloseButtonComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("tdsStringTemplateOutlet", ctx.closeIcon);
    } }, directives: [i1.TDSStringTemplateOutletDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabCloseButtonComponent, [{
        type: Component,
        args: [{
                selector: 'tds-tab-close-button, button[tds-tab-close-button]',
                template: `
    <ng-container *tdsStringTemplateOutlet="closeIcon; let icon">
      <!-- <i nz-icon [type]="icon" nzTheme="outline"></i> -->
    </ng-container>
  `,
                host: {
                    class: 'tds-tabs-tab-remove',
                    'aria-label': 'Close tab',
                    type: 'button'
                }
            }]
    }], function () { return []; }, { closeIcon: [{
            type: Input
        }] }); })();

/**
 * Fix https://github.com/angular/angular/issues/8563
 */
class TDSTabLinkTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TDSTabLinkTemplateDirective.ɵfac = function TDSTabLinkTemplateDirective_Factory(t) { return new (t || TDSTabLinkTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef, 1)); };
TDSTabLinkTemplateDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSTabLinkTemplateDirective, selectors: [["ng-template", "tdsTabLink", ""]], exportAs: ["tdsTabLinkTemplate"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabLinkTemplateDirective, [{
        type: Directive,
        args: [{
                selector: 'ng-template[tdsTabLink]',
                exportAs: 'tdsTabLinkTemplate'
            }]
    }], function () { return [{ type: i0.TemplateRef, decorators: [{
                type: Host
            }] }]; }, null); })();
/**
 * This component is for catching `routerLink` directive.
 */
class TDSTabLinkDirective {
    constructor(elementRef, routerLink, routerLinkWithHref) {
        this.elementRef = elementRef;
        this.routerLink = routerLink;
        this.routerLinkWithHref = routerLinkWithHref;
    }
}
TDSTabLinkDirective.ɵfac = function TDSTabLinkDirective_Factory(t) { return new (t || TDSTabLinkDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$3.RouterLink, 10), i0.ɵɵdirectiveInject(i1$3.RouterLinkWithHref, 10)); };
TDSTabLinkDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSTabLinkDirective, selectors: [["a", "tds-tab-link", ""]], exportAs: ["tdsTabLink"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabLinkDirective, [{
        type: Directive,
        args: [{
                selector: 'a[tds-tab-link]',
                exportAs: 'tdsTabLink'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i1$3.RouterLink, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i1$3.RouterLinkWithHref, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }]; }, null); })();

/** Decorates the `ng-template` tags and reads out the template from it. */
class TDSTabDirective {
}
TDSTabDirective.ɵfac = function TDSTabDirective_Factory(t) { return new (t || TDSTabDirective)(); };
TDSTabDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSTabDirective, selectors: [["", "tds-tab", ""]], exportAs: ["tdsTab"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabDirective, [{
        type: Directive,
        args: [{
                selector: '[tds-tab]',
                exportAs: 'tdsTab'
            }]
    }], null, null); })();

const _c0$1 = ["contentTemplate"];
function TDSTabComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵprojection(0);
} }
function TDSTabComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵprojection(0, 1);
} }
const _c1$1 = [[["", "tds-tab-link", ""]], "*"];
const _c2$1 = ["[tds-tab-link]", "*"];
/**
 * Used to provide a tab set to a tab without causing a circular dependency.
 */
const TDS_TAB_SET = new InjectionToken('TDS_TAB_SET');
class TDSTabComponent {
    constructor(closestTabSet) {
        this.closestTabSet = closestTabSet;
        this.title = '';
        this.closable = false;
        this.closeIcon = 'close';
        this.disabled = false;
        this.forceRender = false;
        this.clsContent = "p-4 w-full h-full";
        this.tabSelect = new EventEmitter();
        this.tabDeselect = new EventEmitter();
        this.tabClick = new EventEmitter();
        this.tabContextmenu = new EventEmitter();
        this.template = null;
        this.isActive = false;
        this.position = null;
        this.origin = null;
        this.stateChanges = new Subject();
    }
    get content() {
        return this.template || this.contentTemplate;
    }
    get label() {
        return this.title || this.tabLinkTemplateDirective?.templateRef;
    }
    ngOnChanges(changes) {
        const { title, disabled, forceRender } = changes;
        if (title || disabled || forceRender) {
            this.stateChanges.next();
        }
    }
    ngOnDestroy() {
        this.stateChanges.complete();
    }
}
TDSTabComponent.ɵfac = function TDSTabComponent_Factory(t) { return new (t || TDSTabComponent)(i0.ɵɵdirectiveInject(TDS_TAB_SET)); };
TDSTabComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTabComponent, selectors: [["tds-tab"]], contentQueries: function TDSTabComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, TDSTabLinkTemplateDirective, 5);
        i0.ɵɵcontentQuery(dirIndex, TDSTabDirective, 5, TemplateRef);
        i0.ɵɵcontentQuery(dirIndex, TDSTabLinkDirective, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabLinkTemplateDirective = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.linkDirective = _t.first);
    } }, viewQuery: function TDSTabComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$1, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    } }, inputs: { title: "title", closable: "closable", closeIcon: "closeIcon", disabled: "disabled", forceRender: "forceRender", clsContent: "clsContent" }, outputs: { tabSelect: "tabSelect", tabDeselect: "tabDeselect", tabClick: "tabClick", tabContextmenu: "tabContextmenu" }, exportAs: ["tdsTab"], features: [i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2$1, decls: 4, vars: 0, consts: [["tabLinkTemplate", ""], ["contentTemplate", ""]], template: function TDSTabComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c1$1);
        i0.ɵɵtemplate(0, TDSTabComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtemplate(2, TDSTabComponent_ng_template_2_Template, 1, 0, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
    } }, encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSTabComponent.prototype, "closable", void 0);
__decorate([
    InputBoolean()
], TDSTabComponent.prototype, "disabled", void 0);
__decorate([
    InputBoolean()
], TDSTabComponent.prototype, "forceRender", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabComponent, [{
        type: Component,
        args: [{
                selector: 'tds-tab',
                exportAs: 'tdsTab',
                preserveWhitespaces: false,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <ng-template #tabLinkTemplate>
      <ng-content select="[tds-tab-link]"></ng-content>
    </ng-template>
    <ng-template #contentTemplate>
      <ng-content></ng-content>
    </ng-template>
  `
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [TDS_TAB_SET]
            }] }]; }, { title: [{
            type: Input
        }], closable: [{
            type: Input
        }], closeIcon: [{
            type: Input
        }], disabled: [{
            type: Input
        }], forceRender: [{
            type: Input
        }], clsContent: [{
            type: Input
        }], tabSelect: [{
            type: Output
        }], tabDeselect: [{
            type: Output
        }], tabClick: [{
            type: Output
        }], tabContextmenu: [{
            type: Output
        }], tabLinkTemplateDirective: [{
            type: ContentChild,
            args: [TDSTabLinkTemplateDirective, { static: false }]
        }], template: [{
            type: ContentChild,
            args: [TDSTabDirective, { static: false, read: TemplateRef }]
        }], linkDirective: [{
            type: ContentChild,
            args: [TDSTabLinkDirective, { static: false }]
        }], contentTemplate: [{
            type: ViewChild,
            args: ['contentTemplate', { static: true }]
        }] }); })();

class TDSTabChangeEvent {
}

function TDSTabSetComponent_tds_tabs_nav_0_div_1_ng_container_2_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 11);
    i0.ɵɵlistener("click", function TDSTabSetComponent_tds_tabs_nav_0_div_1_ng_container_2_button_3_Template_button_click_0_listener($event) { i0.ɵɵrestoreView(_r9); const i_r4 = i0.ɵɵnextContext(2).index; const ctx_r7 = i0.ɵɵnextContext(2); return ctx_r7._onClose(i_r4, $event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r3 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵproperty("closeIcon", tab_r3.closeIcon);
} }
const _c0 = function (a0, a1, a2, a3, a4) { return { "border-b-3": a0, "border-l-3": a1, "tds-tabs-tab-active  border-primary-1": a2, "border-transparent": a3, "cursor-pointer hover:border-primary-1 ": a4 }; };
function TDSTabSetComponent_tds_tabs_nav_0_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div", 9);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(3, TDSTabSetComponent_tds_tabs_nav_0_div_1_ng_container_2_button_3_Template, 1, 1, "button", 10);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext();
    const i_r4 = ctx_r11.index;
    const tab_r3 = ctx_r11.$implicit;
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction5(3, _c0, ctx_r5.position === "horizontal", ctx_r5.tabPosition === "right" || ctx_r5.tabPosition === "left", ctx_r5.selectedIndex === i_r4, ctx_r5.selectedIndex !== i_r4, !tab_r3.disabled));
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", tab_r3.label, " ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", tab_r3.closable && ctx_r5.closable && !tab_r3.disabled);
} }
const _c1 = function (a0, a1, a2) { return { "text-neutral-1-900 dark:text-d-neutral-1-900": a0, "text-neutral-1-400 dark:text-d-neutral-1-400 hover:text-neutral-1-900 dark:hover:text-d-neutral-1-900": a1, "text-neutral-1-300 dark:text-d-neutral-1-300": a2 }; };
const _c2 = function (a1) { return { visible: true, active: a1 }; };
function TDSTabSetComponent_tds_tabs_nav_0_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 6);
    i0.ɵɵlistener("click", function TDSTabSetComponent_tds_tabs_nav_0_div_1_Template_div_click_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r13); const tab_r3 = restoredCtx.$implicit; const i_r4 = restoredCtx.index; const ctx_r12 = i0.ɵɵnextContext(2); return ctx_r12.clickNavItem(tab_r3, i_r4, $event); })("contextmenu", function TDSTabSetComponent_tds_tabs_nav_0_div_1_Template_div_contextmenu_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r13); const tab_r3 = restoredCtx.$implicit; const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.contextmenuNavItem(tab_r3, $event); });
    i0.ɵɵelementStart(1, "div", 7);
    i0.ɵɵtemplate(2, TDSTabSetComponent_tds_tabs_nav_0_div_1_ng_container_2_Template, 4, 9, "ng-container", 8);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const tab_r3 = ctx.$implicit;
    const i_r4 = ctx.index;
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("margin-right", ctx_r2.position === "horizontal" ? ctx_r2.tabBarGutter : null, "px")("margin-bottom", ctx_r2.position === "vertical" ? ctx_r2.tabBarGutter : null, "px");
    i0.ɵɵclassProp("tds-tabs-tab-disabled", tab_r3.disabled);
    i0.ɵɵproperty("ngClass", ctx_r2.clsTab);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("disabled", tab_r3.disabled)("tab", tab_r3)("active", ctx_r2.selectedIndex === i_r4)("ngClass", i0.ɵɵpureFunction3(17, _c1, !tab_r3.disabled && ctx_r2.selectedIndex === i_r4, !tab_r3.disabled && ctx_r2.selectedIndex !== i_r4, tab_r3.disabled));
    i0.ɵɵattribute("tabIndex", ctx_r2.getTabIndex(tab_r3, i_r4))("aria-disabled", tab_r3.disabled)("aria-selected", ctx_r2.selectedIndex === i_r4 && !ctx_r2.hideAll)("aria-controls", ctx_r2.getTabContentId(i_r4));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("tdsStringTemplateOutlet", tab_r3.label)("tdsStringTemplateOutletContext", i0.ɵɵpureFunction1(21, _c2, ctx_r2.selectedIndex === i_r4));
} }
function TDSTabSetComponent_tds_tabs_nav_0_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "tds-tabs-nav", 4);
    i0.ɵɵlistener("tabScroll", function TDSTabSetComponent_tds_tabs_nav_0_Template_tds_tabs_nav_tabScroll_0_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.tabListScroll.emit($event); })("selectFocusedIndex", function TDSTabSetComponent_tds_tabs_nav_0_Template_tds_tabs_nav_selectFocusedIndex_0_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r17 = i0.ɵɵnextContext(); return ctx_r17.setSelectedIndex($event); })("addClicked", function TDSTabSetComponent_tds_tabs_nav_0_Template_tds_tabs_nav_addClicked_0_listener() { i0.ɵɵrestoreView(_r16); const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18._onAdd(); });
    i0.ɵɵtemplate(1, TDSTabSetComponent_tds_tabs_nav_0_div_1_Template, 3, 23, "div", 5);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r0.clsTab);
    i0.ɵɵproperty("ngStyle", ctx_r0.tabBarStyle)("selectedIndex", ctx_r0.selectedIndex || 0)("inkBarAnimated", ctx_r0.inkBarAnimated)("addable", ctx_r0.addable)("addIcon", ctx_r0.addIcon)("hideBar", ctx_r0.hideAll)("position", ctx_r0.position)("tabPosition", ctx_r0.tabPosition)("extraTemplate", ctx_r0.tabBarExtraContent)("hidenNextBtn", ctx_r0.hidenNextBtn);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r0.tabs);
} }
function TDSTabSetComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 12);
} if (rf & 2) {
    const tab_r19 = ctx.$implicit;
    const i_r20 = ctx.index;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("active", ctx_r1.selectedIndex == i_r20 && !ctx_r1.hideAll)("content", tab_r19.content)("forceRender", tab_r19.forceRender)("tabPaneAnimated", ctx_r1.tabPaneAnimated)("ngClass", tab_r19.clsContent);
} }
const TDS_CONFIG_MODULE_NAME = 'tabs';
let nextId = 0;
class TDSTabSetComponent {
    constructor(tdsConfigService, cdr, directionality, router) {
        this.tdsConfigService = tdsConfigService;
        this.cdr = cdr;
        this.directionality = directionality;
        this.router = router;
        this.tabPosition = 'top';
        this.onCanDeactivate = null;
        this.addIcon = 'plus';
        this.tabBarStyle = null;
        this.type = 'line';
        this.size = 'default';
        this.animated = false;
        this.tabBarGutter = undefined;
        this.hideAdd = false;
        this.centered = false;
        this.hideAll = false;
        this.linkRouter = false;
        this.linkExact = true;
        this.hidenNextBtn = false;
        this.clsTab = 'px-4';
        this.selectChange = new EventEmitter(true);
        this.selectedIndexChange = new EventEmitter();
        this.tabListScroll = new EventEmitter();
        this.close = new EventEmitter();
        this.add = new EventEmitter();
        // Pick up only direct descendants under ivy rendering engine
        // We filter out only the tabs that belong to this tab set in `tabs`.
        this.allTabs = new QueryList();
        // All the direct tabs for this tab set
        this.tabs = new QueryList();
        this.dir = 'ltr';
        this.destroy$ = new Subject();
        this.indexToSelect = 0;
        this._selectedIndex = null;
        this.tabLabelSubscription = Subscription.EMPTY;
        this.tabsSubscription = Subscription.EMPTY;
        this.canDeactivateSubscription = Subscription.EMPTY;
        this.tabSetId = nextId++;
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(value) {
        this.indexToSelect = coerceNumberProperty(value, null);
    }
    get position() {
        return ['top', 'bottom'].indexOf(this.tabPosition) === -1 ? 'vertical' : 'horizontal';
    }
    get addable() {
        return this.type === 'editable-card' && !this.hideAdd;
    }
    get closable() {
        return this.type === 'editable-card';
    }
    get line() {
        return this.type === 'line';
    }
    get inkBarAnimated() {
        return this.line && (typeof this.animated === 'boolean' ? this.animated : this.animated.inkBar);
    }
    get tabPaneAnimated() {
        return false;
        // (
        //   this.position === 'horizontal' && this.line && (typeof this.animated === 'boolean' ? this.animated : this.animated.tabPane)
        // );
    }
    ngOnInit() {
        this.dir = this.directionality.value;
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.tabs.destroy();
        this.tabLabelSubscription.unsubscribe();
        this.tabsSubscription.unsubscribe();
        this.canDeactivateSubscription.unsubscribe();
    }
    ngAfterContentInit() {
        Promise.resolve().then(() => {
            this.setUpRouter();
        });
        this.subscribeToTabLabels();
        this.subscribeToAllTabChanges();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this.tabsSubscription = this.tabs.changes.subscribe(() => {
            const indexToSelect = this.clampTabIndex(this.indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === this._selectedIndex) {
                const tabs = this.tabs.toArray();
                for (let i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        this.indexToSelect = this._selectedIndex = i;
                        break;
                    }
                }
            }
            this.subscribeToTabLabels();
            this.cdr.markForCheck();
        });
    }
    ngAfterContentChecked() {
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        const indexToSelect = (this.indexToSelect = this.clampTabIndex(this.indexToSelect));
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            const isFirstRun = this._selectedIndex == null;
            if (!isFirstRun) {
                this.selectChange.emit(this.createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then(() => {
                this.tabs.forEach((tab, index) => (tab.isActive = index === indexToSelect));
                if (!isFirstRun) {
                    this.selectedIndexChange.emit(indexToSelect);
                }
            });
        }
        // Setup the position for each tab and optionally setup an origin on the next selected tab.
        this.tabs.forEach((tab, index) => {
            tab.position = index - indexToSelect;
            // If there is already a selected tab, then set up an origin for the next selected tab
            // if it doesn't have one already.
            if (this._selectedIndex != null && tab.position === 0 && !tab.origin) {
                tab.origin = indexToSelect - this._selectedIndex;
            }
        });
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this.cdr.markForCheck();
        }
    }
    _onClose(index, e) {
        e.preventDefault();
        e.stopPropagation();
        this.close.emit({ index });
    }
    _onAdd() {
        this.add.emit();
    }
    clampTabIndex(index) {
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    }
    createChangeEvent(index) {
        const event = new TDSTabChangeEvent();
        event.index = index;
        if (this.tabs && this.tabs.length) {
            event.tab = this.tabs.toArray()[index];
            this.tabs.forEach((tab, i) => {
                if (i !== index) {
                    tab.tabDeselect.emit();
                }
            });
            event.tab.tabSelect.emit();
        }
        return event;
    }
    subscribeToTabLabels() {
        if (this.tabLabelSubscription) {
            this.tabLabelSubscription.unsubscribe();
        }
        this.tabLabelSubscription = merge(...this.tabs.map(tab => tab.stateChanges)).subscribe(() => this.cdr.markForCheck());
    }
    subscribeToAllTabChanges() {
        this.allTabs.changes.pipe(startWith(this.allTabs)).subscribe((tabs) => {
            this.tabs.reset(tabs.filter(tab => tab.closestTabSet === this));
            this.tabs.notifyOnChanges();
        });
    }
    canDeactivateFun(pre, next) {
        if (typeof this.onCanDeactivate === 'function') {
            const observable = wrapIntoObservable(this.onCanDeactivate(pre, next));
            return observable.pipe(first(), takeUntil(this.destroy$));
        }
        else {
            return of(true);
        }
    }
    clickNavItem(tab, index, e) {
        if (!tab.disabled) {
            // ignore onCanDeactivate
            tab.tabClick.emit();
            if (!this.isRouterLinkClickEvent(index, e)) {
                this.setSelectedIndex(index);
            }
        }
    }
    isRouterLinkClickEvent(index, event) {
        const target = event.target;
        if (this.linkRouter) {
            return !!this.tabs.toArray()[index]?.linkDirective?.elementRef.nativeElement.contains(target);
        }
        else {
            return false;
        }
    }
    contextmenuNavItem(tab, e) {
        if (!tab.disabled) {
            // ignore onCanDeactivate
            tab.tabContextmenu.emit(e);
        }
    }
    setSelectedIndex(index) {
        this.canDeactivateSubscription.unsubscribe();
        this.canDeactivateSubscription = this.canDeactivateFun(this._selectedIndex, index).subscribe(can => {
            if (can) {
                this.selectedIndex = index;
                this.tabNavBarRef.focusIndex = index;
                this.cdr.markForCheck();
            }
        });
    }
    getTabIndex(tab, index) {
        if (tab.disabled) {
            return null;
        }
        return this._selectedIndex === index ? 0 : -1;
    }
    getTabContentId(i) {
        return `tds-tabs-${this.tabSetId}-tab-${i}`;
    }
    setUpRouter() {
        if (this.linkRouter) {
            if (!this.router) {
                throw new Error(`[TDS] you should import 'RouterModule' if you want to use 'linkRouter'!`);
            }
            this.router.events
                .pipe(takeUntil(this.destroy$), filter(e => e instanceof NavigationEnd), startWith(true), delay(0))
                .subscribe(() => {
                this.updateRouterActive();
                this.cdr.markForCheck();
            });
        }
    }
    updateRouterActive() {
        if (this.router.navigated) {
            const index = this.findShouldActiveTabIndex();
            if (index !== this._selectedIndex) {
                this.setSelectedIndex(index);
            }
            this.hideAll = index === -1;
        }
    }
    findShouldActiveTabIndex() {
        const tabs = this.tabs.toArray();
        const isActive = this.isLinkActive(this.router);
        return tabs.findIndex(tab => {
            const c = tab.linkDirective;
            return c ? isActive(c.routerLink) || isActive(c.routerLinkWithHref) : false;
        });
    }
    isLinkActive(router) {
        return (link) => (link ? router.isActive(link.urlTree, this.linkExact) : false);
    }
    getTabContentMarginValue() {
        return -(this.selectedIndex || 0) * 100;
    }
    getTabContentMarginLeft() {
        if (this.tabPaneAnimated) {
            if (this.dir !== 'rtl') {
                return this.getTabContentMarginValue() + '%';
            }
        }
        return '';
    }
    getTabContentMarginRight() {
        if (this.tabPaneAnimated) {
            if (this.dir === 'rtl') {
                return this.getTabContentMarginValue() + '%';
            }
        }
        return '';
    }
}
TDSTabSetComponent.ɵfac = function TDSTabSetComponent_Factory(t) { return new (t || TDSTabSetComponent)(i0.ɵɵdirectiveInject(i1$4.TDSConfigService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.Directionality, 8), i0.ɵɵdirectiveInject(i1$3.Router, 8)); };
TDSTabSetComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTabSetComponent, selectors: [["tds-tabset"]], contentQueries: function TDSTabSetComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, TDSTabComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.allTabs = _t);
    } }, viewQuery: function TDSTabSetComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(TDSTabNavBarComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabNavBarRef = _t.first);
    } }, hostAttrs: [1, "tds-tabs", "box-border", "m-0", "p-0", "flex", "overflow-hidden", "w-full"], hostVars: 32, hostBindings: function TDSTabSetComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("tds-tabs-card", ctx.type === "card" || ctx.type === "editable-card")("tds-tabs-editable", ctx.type === "editable-card")("tds-tabs-editable-card", ctx.type === "editable-card")("tds-tabs-centered", ctx.centered)("tds-tabs-rtl", ctx.dir === "rtl")("tds-tabs-top", ctx.tabPosition === "top")("flex-col", ctx.tabPosition === "top" || ctx.tabPosition === "bottom")("tds-tabs-bottom", ctx.tabPosition === "bottom")("tds-tabs-left", ctx.tabPosition === "left")("tds-tabs-right", ctx.tabPosition === "right")("flex-row-reverse", ctx.tabPosition === "right")("flex-col-reverse", ctx.tabPosition === "bottom")("py-4", ctx.tabPosition === "right")("tds-tabs-default", ctx.size === "default")("tds-tabs-small", ctx.size === "small")("tds-tabs-large", ctx.size === "large");
    } }, inputs: { selectedIndex: "selectedIndex", tabPosition: "tabPosition", tabBarExtraContent: "tabBarExtraContent", onCanDeactivate: "onCanDeactivate", addIcon: "addIcon", tabBarStyle: "tabBarStyle", type: "type", size: "size", animated: "animated", tabBarGutter: "tabBarGutter", hideAdd: "hideAdd", centered: "centered", hideAll: "hideAll", linkRouter: "linkRouter", linkExact: "linkExact", hidenNextBtn: "hidenNextBtn", clsTab: "clsTab" }, outputs: { selectChange: "selectChange", selectedIndexChange: "selectedIndexChange", tabListScroll: "tabListScroll", close: "close", add: "add" }, exportAs: ["tdsTabset"], features: [i0.ɵɵProvidersFeature([
            {
                provide: TDS_TAB_SET,
                useExisting: TDSTabSetComponent
            }
        ])], decls: 4, vars: 16, consts: [[3, "ngStyle", "selectedIndex", "inkBarAnimated", "addable", "addIcon", "hideBar", "position", "tabPosition", "extraTemplate", "class", "hidenNextBtn", "tabScroll", "selectFocusedIndex", "addClicked", 4, "ngIf"], [1, "tds-tabs-content-holder", "h-full", "w-full"], [1, "tds-tabs-content", "h-full", "w-full"], ["tds-tab-body", "", 3, "active", "content", "forceRender", "tabPaneAnimated", "ngClass", 4, "ngFor", "ngForOf"], [3, "ngStyle", "selectedIndex", "inkBarAnimated", "addable", "addIcon", "hideBar", "position", "tabPosition", "extraTemplate", "hidenNextBtn", "tabScroll", "selectFocusedIndex", "addClicked"], ["class", "tds-tabs-tab relative inline-block outline-none  text-body-2 ", 3, "margin-right", "margin-bottom", "tds-tabs-tab-disabled", "ngClass", "click", "contextmenu", 4, "ngFor", "ngForOf"], [1, "tds-tabs-tab", "relative", "inline-block", "outline-none", "text-body-2", 3, "ngClass", "click", "contextmenu"], ["role", "tab", "tdsTabNavItem", "", "cdkMonitorElementFocus", "", 1, "tds-tabs-tab-btn", "focus:outline-none", "w-full", 3, "disabled", "tab", "active", "ngClass"], [4, "tdsStringTemplateOutlet", "tdsStringTemplateOutletContext"], [1, "px-2", "py-4", "font-semibold", "text-body-2", 3, "ngClass"], ["tds-tab-close-button", "", 3, "closeIcon", "click", 4, "ngIf"], ["tds-tab-close-button", "", 3, "closeIcon", "click"], ["tds-tab-body", "", 3, "active", "content", "forceRender", "tabPaneAnimated", "ngClass"]], template: function TDSTabSetComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TDSTabSetComponent_tds_tabs_nav_0_Template, 2, 13, "tds-tabs-nav", 0);
        i0.ɵɵelementStart(1, "div", 1)(2, "div", 2);
        i0.ɵɵtemplate(3, TDSTabSetComponent_div_3_Template, 1, 5, "div", 3);
        i0.ɵɵelementEnd()();
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.tabs.length);
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("margin-left", ctx.getTabContentMarginLeft())("margin-right", ctx.getTabContentMarginRight());
        i0.ɵɵclassProp("tds-tabs-content-top", ctx.tabPosition === "top")("tds-tabs-content-bottom", ctx.tabPosition === "bottom")("tds-tabs-content-left", ctx.tabPosition === "left")("tds-tabs-content-right", ctx.tabPosition === "right")("tds-tabs-content-animated", ctx.tabPaneAnimated);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.tabs);
    } }, directives: [i1$1.NgIf, TDSTabNavBarComponent, i1$1.NgStyle, i1$1.NgForOf, i1$1.NgClass, TDSTabNavItemDirective, i7.CdkMonitorFocus, i1.TDSStringTemplateOutletDirective, TDSTabCloseButtonComponent, TDSTabBodyComponent], encapsulation: 2 });
__decorate([
    WithConfig()
], TDSTabSetComponent.prototype, "type", void 0);
__decorate([
    WithConfig()
], TDSTabSetComponent.prototype, "size", void 0);
__decorate([
    WithConfig()
], TDSTabSetComponent.prototype, "animated", void 0);
__decorate([
    WithConfig()
], TDSTabSetComponent.prototype, "tabBarGutter", void 0);
__decorate([
    InputBoolean()
], TDSTabSetComponent.prototype, "hideAdd", void 0);
__decorate([
    InputBoolean()
], TDSTabSetComponent.prototype, "centered", void 0);
__decorate([
    InputBoolean()
], TDSTabSetComponent.prototype, "hideAll", void 0);
__decorate([
    InputBoolean()
], TDSTabSetComponent.prototype, "linkRouter", void 0);
__decorate([
    InputBoolean()
], TDSTabSetComponent.prototype, "linkExact", void 0);
__decorate([
    InputBoolean()
], TDSTabSetComponent.prototype, "hidenNextBtn", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabSetComponent, [{
        type: Component,
        args: [{ selector: 'tds-tabset', exportAs: 'tdsTabset', preserveWhitespaces: false, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.Default, providers: [
                    {
                        provide: TDS_TAB_SET,
                        useExisting: TDSTabSetComponent
                    }
                ], host: {
                    class: 'tds-tabs box-border m-0 p-0 flex overflow-hidden w-full ',
                    '[class.tds-tabs-card]': `type === 'card' || type === 'editable-card'`,
                    '[class.tds-tabs-editable]': `type === 'editable-card'`,
                    '[class.tds-tabs-editable-card]': `type === 'editable-card'`,
                    '[class.tds-tabs-centered]': `centered`,
                    '[class.tds-tabs-rtl]': `dir === 'rtl'`,
                    '[class.tds-tabs-top]': `tabPosition === 'top'`,
                    '[class.flex-col]': `tabPosition === 'top' || tabPosition === 'bottom'`,
                    '[class.tds-tabs-bottom]': `tabPosition === 'bottom'`,
                    '[class.tds-tabs-left]': `tabPosition === 'left'`,
                    '[class.tds-tabs-right]': `tabPosition === 'right'`,
                    '[class.flex-row-reverse]': `tabPosition === 'right'`,
                    '[class.flex-col-reverse]': `tabPosition === 'bottom'`,
                    '[class.py-4]': `tabPosition === 'right'`,
                    '[class.tds-tabs-default]': `size === 'default'`,
                    '[class.tds-tabs-small]': `size === 'small'`,
                    '[class.tds-tabs-large]': `size === 'large'`
                }, template: "<tds-tabs-nav *ngIf=\"tabs.length\" [ngStyle]=\"tabBarStyle\" [selectedIndex]=\"selectedIndex || 0\"\r\n    [inkBarAnimated]=\"inkBarAnimated\" [addable]=\"addable\" [addIcon]=\"addIcon\" [hideBar]=\"hideAll\" [position]=\"position\"\r\n    [tabPosition]=\"tabPosition\" [extraTemplate]=\"tabBarExtraContent\" (tabScroll)=\"tabListScroll.emit($event)\"\r\n    (selectFocusedIndex)=\"setSelectedIndex($event)\" (addClicked)=\"_onAdd()\" [class]=\"clsTab\" [hidenNextBtn]=\"hidenNextBtn\">\r\n    <div class=\"tds-tabs-tab relative inline-block outline-none  text-body-2 \"\r\n        [style.margin-right.px]=\"position === 'horizontal' ? tabBarGutter : null\"\r\n        [style.margin-bottom.px]=\"position === 'vertical' ? tabBarGutter : null\"\r\n        [class.tds-tabs-tab-disabled]=\"tab.disabled\" (click)=\"clickNavItem(tab, i, $event)\" [ngClass]=\"clsTab\"\r\n        (contextmenu)=\"contextmenuNavItem(tab, $event)\" *ngFor=\"let tab of tabs; let i = index\">\r\n        <div role=\"tab\" [attr.tabIndex]=\"getTabIndex(tab, i)\" [attr.aria-disabled]=\"tab.disabled\"\r\n            [attr.aria-selected]=\"selectedIndex === i && !hideAll\" [attr.aria-controls]=\"getTabContentId(i)\"\r\n            [disabled]=\"tab.disabled\" [tab]=\"tab\" [active]=\"selectedIndex === i\"\r\n            class=\"tds-tabs-tab-btn focus:outline-none w-full\" tdsTabNavItem cdkMonitorElementFocus [ngClass]=\"{\r\n                'text-neutral-1-900 dark:text-d-neutral-1-900':!tab.disabled && selectedIndex === i,\r\n                    'text-neutral-1-400 dark:text-d-neutral-1-400 hover:text-neutral-1-900 dark:hover:text-d-neutral-1-900':!tab.disabled && selectedIndex !== i,\r\n                    'text-neutral-1-300 dark:text-d-neutral-1-300':tab.disabled\r\n            }\">\r\n            <ng-container *tdsStringTemplateOutlet=\"tab.label; context: { visible: true , active: selectedIndex === i}\">\r\n                <div class=\"px-2 py-4 font-semibold text-body-2\" [ngClass]=\"{\r\n                    'border-b-3':position === 'horizontal',\r\n                    'border-l-3': tabPosition === 'right' || tabPosition === 'left',\r\n                    'tds-tabs-tab-active  border-primary-1':selectedIndex === i,\r\n                    'border-transparent':selectedIndex !== i,\r\n                    'cursor-pointer hover:border-primary-1 ':!tab.disabled\r\n                    \r\n                }\">\r\n                    {{ tab.label }}\r\n                </div>\r\n                <button tds-tab-close-button *ngIf=\"tab.closable && closable && !tab.disabled\"\r\n                    [closeIcon]=\"tab.closeIcon\" (click)=\"_onClose(i, $event)\"></button>\r\n            </ng-container>\r\n\r\n\r\n        </div>\r\n    </div>\r\n</tds-tabs-nav>\r\n<div class=\"tds-tabs-content-holder h-full w-full\">\r\n    <div class=\"tds-tabs-content h-full w-full\" [class.tds-tabs-content-top]=\"tabPosition === 'top'\"\r\n        [class.tds-tabs-content-bottom]=\"tabPosition === 'bottom'\"\r\n        [class.tds-tabs-content-left]=\"tabPosition === 'left'\" [class.tds-tabs-content-right]=\"tabPosition === 'right'\"\r\n        [class.tds-tabs-content-animated]=\"tabPaneAnimated\" [style.margin-left]=\"getTabContentMarginLeft()\"\r\n        [style.margin-right]=\"getTabContentMarginRight()\">\r\n        <div tds-tab-body *ngFor=\"let tab of tabs; let i = index\" [active]=\"selectedIndex == i && !hideAll\"\r\n            [content]=\"tab.content\" [forceRender]=\"tab.forceRender\" [tabPaneAnimated]=\"tabPaneAnimated\"\r\n            [ngClass]=\"tab.clsContent\"></div>\r\n    </div>\r\n</div>" }]
    }], function () { return [{ type: i1$4.TDSConfigService }, { type: i0.ChangeDetectorRef }, { type: i3.Directionality, decorators: [{
                type: Optional
            }] }, { type: i1$3.Router, decorators: [{
                type: Optional
            }] }]; }, { selectedIndex: [{
            type: Input
        }], tabPosition: [{
            type: Input
        }], tabBarExtraContent: [{
            type: Input
        }], onCanDeactivate: [{
            type: Input
        }], addIcon: [{
            type: Input
        }], tabBarStyle: [{
            type: Input
        }], type: [{
            type: Input
        }], size: [{
            type: Input
        }], animated: [{
            type: Input
        }], tabBarGutter: [{
            type: Input
        }], hideAdd: [{
            type: Input
        }], centered: [{
            type: Input
        }], hideAll: [{
            type: Input
        }], linkRouter: [{
            type: Input
        }], linkExact: [{
            type: Input
        }], hidenNextBtn: [{
            type: Input
        }], clsTab: [{
            type: Input
        }], selectChange: [{
            type: Output
        }], selectedIndexChange: [{
            type: Output
        }], tabListScroll: [{
            type: Output
        }], close: [{
            type: Output
        }], add: [{
            type: Output
        }], allTabs: [{
            type: ContentChildren,
            args: [TDSTabComponent, { descendants: true }]
        }], tabNavBarRef: [{
            type: ViewChild,
            args: [TDSTabNavBarComponent, { static: false }]
        }] }); })();

const DIRECTIVES = [
    TDSTabSetComponent,
    TDSTabComponent,
    TDSTabNavBarComponent,
    TDSTabNavItemDirective,
    TDSTabsInkBarDirective,
    TDSTabScrollListDirective,
    TDSTabNavOperationComponent,
    TDSTabAddButtonComponent,
    TDSTabCloseButtonComponent,
    TDSTabDirective,
    TDSTabBodyComponent,
    TDSTabLinkDirective,
    TDSTabLinkTemplateDirective
];
class TDSTabsModule {
}
TDSTabsModule.ɵfac = function TDSTabsModule_Factory(t) { return new (t || TDSTabsModule)(); };
TDSTabsModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSTabsModule });
TDSTabsModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            BidiModule,
            CommonModule,
            ObserversModule,
            TDSOutletModule,
            PlatformModule,
            A11yModule,
            CdkScrollableModule,
            TDSDropDownModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTabsModule, [{
        type: NgModule,
        args: [{
                declarations: [DIRECTIVES],
                exports: [DIRECTIVES],
                imports: [
                    BidiModule,
                    CommonModule,
                    ObserversModule,
                    TDSOutletModule,
                    PlatformModule,
                    A11yModule,
                    CdkScrollableModule,
                    TDSDropDownModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSTabsModule, { declarations: [TDSTabSetComponent,
        TDSTabComponent,
        TDSTabNavBarComponent,
        TDSTabNavItemDirective,
        TDSTabsInkBarDirective,
        TDSTabScrollListDirective,
        TDSTabNavOperationComponent,
        TDSTabAddButtonComponent,
        TDSTabCloseButtonComponent,
        TDSTabDirective,
        TDSTabBodyComponent,
        TDSTabLinkDirective,
        TDSTabLinkTemplateDirective], imports: [BidiModule,
        CommonModule,
        ObserversModule,
        TDSOutletModule,
        PlatformModule,
        A11yModule,
        CdkScrollableModule,
        TDSDropDownModule], exports: [TDSTabSetComponent,
        TDSTabComponent,
        TDSTabNavBarComponent,
        TDSTabNavItemDirective,
        TDSTabsInkBarDirective,
        TDSTabScrollListDirective,
        TDSTabNavOperationComponent,
        TDSTabAddButtonComponent,
        TDSTabCloseButtonComponent,
        TDSTabDirective,
        TDSTabBodyComponent,
        TDSTabLinkDirective,
        TDSTabLinkTemplateDirective] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSTabChangeEvent, TDSTabComponent, TDSTabDirective, TDSTabLinkDirective, TDSTabLinkTemplateDirective, TDSTabSetComponent, TDSTabsModule, TDS_TAB_SET, TDSTabAddButtonComponent as ɵTDSTabAddButtonComponent, TDSTabBodyComponent as ɵTDSTabBodyComponent, TDSTabCloseButtonComponent as ɵTDSTabCloseButtonComponent, TDSTabNavBarComponent as ɵTDSTabNavBarComponent, TDSTabNavItemDirective as ɵTDSTabNavItemDirective, TDSTabNavOperationComponent as ɵTDSTabNavOperationComponent, TDSTabScrollListDirective as ɵTDSTabScrollListDirective, TDSTabsInkBarDirective as ɵTDSTabsInkBarDirective };
//# sourceMappingURL=tds-ui-tabs.mjs.map
