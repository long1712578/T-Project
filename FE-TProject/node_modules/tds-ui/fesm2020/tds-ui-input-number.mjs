import { __decorate } from 'tslib';
import { UP_ARROW, DOWN_ARROW, ENTER } from '@angular/cdk/keycodes';
import * as i0 from '@angular/core';
import { EventEmitter, forwardRef, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, Inject, Host, Self, Output, ViewChild, Input, NgModule } from '@angular/core';
import { Subject, fromEvent } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as i5 from 'tds-ui/form-field';
import { TDS_FORM_FIELD, TDSFormFieldControl } from 'tds-ui/form-field';
import { TDSHelperObject, InputBoolean } from 'tds-ui/shared/utility';
import { isNotNil } from 'tds-ui/core/util';
import { coerceBooleanProperty } from 'tds-ui/shared/coercion';
import { TDSIsErrorState } from 'tds-ui/shared/common';
import * as i1 from '@angular/cdk/a11y';
import * as i2 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i3 from '@angular/forms';
import { FormsModule } from '@angular/forms';
import * as i4 from '@angular/common';
import { CommonModule } from '@angular/common';

const _c0 = ["inputElement"];
const _c1 = function (a0, a1, a2) { return { "py-2": a0, "py-1": a1, "py-1.5": a2 }; };
const _c2 = function (a0) { return { "hidden": a0 }; };
const _c3 = function (a0, a1) { return { "text-xs": a0, "text-sm": a1 }; };
const _c4 = function (a0, a1) { return { "pr-8": a0, "pr-3": a1 }; };
class TDSInputNumberComponent {
    constructor(ngZone, elementRef, cdr, focusMonitor, directionality, _formField, _parentForm, _parentFormGroup, ngControl) {
        this.ngZone = ngZone;
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.focusMonitor = focusMonitor;
        this.directionality = directionality;
        this._formField = _formField;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this.ngControl = ngControl;
        this.value = null;
        this.destroy$ = new Subject();
        this.stateChanges = new Subject();
        this.parentIsFormField = false;
        this.isFocused = false;
        this.disabledUp = false;
        this.disabledDown = false;
        this.dir = 'ltr';
        this.onChange = () => { };
        this.onTouched = () => { };
        this.tdsBlur = new EventEmitter();
        this.tdsFocus = new EventEmitter();
        this.min = -Infinity;
        this.max = Infinity;
        this.parser = (value) => value
            .trim()
            .replace(/。/g, '.')
            .replace(/[^\w\.-]+/g, '');
        this.precisionMode = 'toFixed';
        this.placeholder = '';
        this.step = 1;
        this.inputMode = 'decimal';
        this.id = null;
        this.disabled = false;
        this.autoFocus = false;
        this.formatter = value => value;
        this._size = 'md';
        // ngControl, focused, empty, required,
        this.errorState = false;
        this._required = false;
        this.hiddenIcon = false;
        /**
         *
         */
        this.autoFormat = false;
        // TODO: move to host after View Engine deprecation
        this.elementRef.nativeElement.classList.add('tds-input-number');
        if (this.ngControl != null) {
            this.ngControl.valueAccessor = this;
        }
        if (this._formField) {
            // this.size = this._formField.size;
            this.parentIsFormField = true;
        }
    }
    get size() {
        return this._size;
    }
    set size(value) {
        if (this._size != value) {
            this._size = value;
            this.stateChanges.next();
        }
    }
    updateErrorState() {
        const oldState = this.errorState;
        const parent = this._parentFormGroup || this._parentForm;
        // const matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;
        const control = this.ngControl ? this.ngControl.control : null;
        const newState = this._isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
            this.cdr.markForCheck();
        }
    }
    _isErrorState(control, form) {
        return TDSIsErrorState(control, form);
    }
    get focused() {
        return this.isFocused;
    }
    get empty() {
        return !TDSHelperObject.hasValue(this.value);
    }
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = coerceBooleanProperty(value);
        this.stateChanges.next();
    }
    // setDescribedByIds, onContainerClickts
    setDescribedByIds(ids) {
        if (ids.length) {
            this.elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));
        }
        else {
            this.elementRef.nativeElement.removeAttribute('aria-describedby');
        }
    }
    onContainerClick(e) {
        // e.preventDefault();
        // e.stopPropagation();
    }
    onModelChange(value) {
        const parsedValue = this.parser(value);
        this.parsedValue = parsedValue;
        const validValue = this.getCurrentValidValue(this.parsedValue);
        this.setValue(validValue);
        if (this.autoFormat) {
            this.updateDisplayValue(this.value);
        }
    }
    getCurrentValidValue(value) {
        let val = value;
        if (val === '') {
            val = '';
        }
        else if (!this.isNotCompleteNumber(val)) {
            val = `${this.getValidValue(val)}`;
        }
        else {
            val = this.value;
        }
        return this.toNumber(val);
    }
    // '1.' '1x' 'xx' '' => are not complete numbers
    isNotCompleteNumber(num) {
        return (isNaN(num) ||
            num === '' ||
            num === null ||
            !!(num && num.toString().indexOf('.') === num.toString().length - 1));
    }
    getValidValue(value) {
        let val = parseFloat(value);
        // https://github.com/tds-design/tds-design/issues/7358
        if (isNaN(val)) {
            return value;
        }
        if (val < this.min) {
            val = this.min;
        }
        if (val > this.max) {
            val = this.max;
        }
        return val;
    }
    toNumber(num) {
        if (this.isNotCompleteNumber(num)) {
            return num;
        }
        const numStr = String(num);
        if (numStr.indexOf('.') >= 0 && isNotNil(this.precision)) {
            if (typeof this.precisionMode === 'function') {
                return this.precisionMode(num, this.precision);
            }
            else if (this.precisionMode === 'cut') {
                const numSplit = numStr.split('.');
                numSplit[1] = numSplit[1].slice(0, this.precision);
                return Number(numSplit.join('.'));
            }
            return Number(Number(num).toFixed(this.precision));
        }
        return Number(num);
    }
    getRatio(e) {
        let ratio = 1;
        if (e.metaKey || e.ctrlKey) {
            ratio = 0.1;
        }
        else if (e.shiftKey) {
            ratio = 10;
        }
        return ratio;
    }
    down(e, ratio) {
        if (!this.isFocused) {
            this.focus();
        }
        this.onStep('down', e, ratio);
    }
    up(e, ratio) {
        if (!this.isFocused) {
            this.focus();
        }
        this.onStep('up', e, ratio);
    }
    getPrecision(value) {
        const valueString = value.toString();
        if (valueString.indexOf('e-') >= 0) {
            return parseInt(valueString.slice(valueString.indexOf('e-') + 2), 10);
        }
        let precision = 0;
        if (valueString.indexOf('.') >= 0) {
            precision = valueString.length - valueString.indexOf('.') - 1;
        }
        return precision;
    }
    // step={1.0} value={1.51}
    // press +
    // then value should be 2.51, rather than 2.5
    // if this.props.precision is undefined
    // https://github.com/react-component/input-number/issues/39
    getMaxPrecision(currentValue, ratio) {
        if (isNotNil(this.precision)) {
            return this.precision;
        }
        const ratioPrecision = this.getPrecision(ratio);
        const stepPrecision = this.getPrecision(this.step);
        const currentValuePrecision = this.getPrecision(currentValue);
        if (!currentValue) {
            return ratioPrecision + stepPrecision;
        }
        return Math.max(currentValuePrecision, ratioPrecision + stepPrecision);
    }
    getPrecisionFactor(currentValue, ratio) {
        const precision = this.getMaxPrecision(currentValue, ratio);
        return Math.pow(10, precision);
    }
    upStep(val, rat) {
        const precisionFactor = this.getPrecisionFactor(val, rat);
        const precision = Math.abs(this.getMaxPrecision(val, rat));
        let result;
        if (typeof val === 'number') {
            result = ((precisionFactor * val + precisionFactor * this.step * rat) / precisionFactor).toFixed(precision);
        }
        else {
            result = this.min === -Infinity ? this.step : this.min;
        }
        return this.toNumber(result);
    }
    downStep(val, rat) {
        const precisionFactor = this.getPrecisionFactor(val, rat);
        const precision = Math.abs(this.getMaxPrecision(val, rat));
        let result;
        if (typeof val === 'number') {
            result = ((precisionFactor * val - precisionFactor * this.step * rat) / precisionFactor).toFixed(precision);
        }
        else {
            result = this.min === -Infinity ? -this.step : this.min;
        }
        return this.toNumber(result);
    }
    onStep(type, e, ratio = 1) {
        this.stop();
        e.preventDefault();
        if (this.disabled) {
            return;
        }
        const value = this.getCurrentValidValue(this.parsedValue) || 0;
        let val = 0;
        if (type === 'up') {
            val = this.upStep(value, ratio);
        }
        else if (type === 'down') {
            val = this.downStep(value, ratio);
        }
        const outOfRange = val > this.max || val < this.min;
        if (val > this.max) {
            val = this.max;
        }
        else if (val < this.min) {
            val = this.min;
        }
        this.setValue(val);
        this.updateDisplayValue(val);
        this.isFocused = true;
        this.stateChanges.next();
        if (outOfRange) {
            return;
        }
        this.autoStepTimer = setTimeout(() => {
            this[type](e, ratio);
        }, 300);
    }
    stop() {
        if (this.autoStepTimer) {
            clearTimeout(this.autoStepTimer);
        }
    }
    setValue(value) {
        if (`${this.value}` !== `${value}`) {
            this.onChange(value);
        }
        this.value = value;
        this.parsedValue = value;
        this.disabledUp = this.disabledDown = false;
        if (value || value === 0) {
            const val = Number(value);
            if (val >= this.max) {
                this.disabledUp = true;
            }
            if (val <= this.min) {
                this.disabledDown = true;
            }
        }
    }
    updateDisplayValue(value) {
        const displayValue = isNotNil(this.formatter(value)) ? this.formatter(value) : '';
        this.displayValue = displayValue;
        this.inputElement.nativeElement.value = `${displayValue}`;
    }
    // onKeyDown(e: KeyboardEvent): void {
    //   if (e.keyCode === UP_ARROW) {
    //     const ratio = this.getRatio(e);
    //     this.up(e, ratio);
    //     this.stop();
    //   } else if (e.keyCode === DOWN_ARROW) {
    //     const ratio = this.getRatio(e);
    //     this.down(e, ratio);
    //     this.stop();
    //   } else if (e.keyCode === ENTER) {
    //     this.updateDisplayValue(this.value!);
    //   }
    // }
    writeValue(value) {
        this.value = value;
        this.setValue(value);
        this.updateDisplayValue(value);
        this.cdr.markForCheck();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(disabled) {
        this.disabled = disabled;
        this.cdr.markForCheck();
    }
    focus() {
        this.focusMonitor.focusVia(this.inputElement, 'keyboard');
    }
    blur() {
        this.inputElement.nativeElement.blur();
    }
    ngOnInit() {
        this.focusMonitor
            .monitor(this.elementRef, true)
            .pipe(takeUntil(this.destroy$))
            .subscribe(focusOrigin => {
            if (!focusOrigin) {
                this.isFocused = false;
                this.updateDisplayValue(this.value);
                this.tdsBlur.emit();
                this.stateChanges.next();
                Promise.resolve().then(() => this.onTouched());
            }
            else {
                this.isFocused = true;
                this.stateChanges.next();
                this.tdsFocus.emit();
            }
        });
        this.dir = this.directionality.value;
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
        });
        this.ngZone.runOutsideAngular(() => {
            fromEvent(this.inputElement.nativeElement, 'keyup')
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => this.stop());
            fromEvent(this.inputElement.nativeElement, 'keydown')
                .pipe(takeUntil(this.destroy$))
                .subscribe(event => {
                const { keyCode } = event;
                if (keyCode !== UP_ARROW && keyCode !== DOWN_ARROW && keyCode !== ENTER) {
                    return;
                }
                this.ngZone.run(() => {
                    if (keyCode === UP_ARROW) {
                        const ratio = this.getRatio(event);
                        this.up(event, ratio);
                        this.stop();
                    }
                    else if (keyCode === DOWN_ARROW) {
                        const ratio = this.getRatio(event);
                        this.down(event, ratio);
                        this.stop();
                    }
                    else {
                        this.updateDisplayValue(this.value);
                    }
                    this.cdr.markForCheck();
                });
            });
        });
    }
    ngOnChanges(changes) {
        if (changes.formatter && !changes.formatter.isFirstChange()) {
            const validValue = this.getCurrentValidValue(this.parsedValue);
            this.setValue(validValue);
            this.updateDisplayValue(validValue);
        }
    }
    ngAfterViewInit() {
        if (this.autoFocus) {
            this.focus();
        }
    }
    ngOnDestroy() {
        this.focusMonitor.stopMonitoring(this.elementRef);
        this.destroy$.next();
        this.destroy$.complete();
    }
    ngDoCheck() {
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
}
TDSInputNumberComponent.ɵfac = function TDSInputNumberComponent_Factory(t) { return new (t || TDSInputNumberComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.FocusMonitor), i0.ɵɵdirectiveInject(i2.Directionality, 8), i0.ɵɵdirectiveInject(TDS_FORM_FIELD, 9), i0.ɵɵdirectiveInject(i3.NgForm, 8), i0.ɵɵdirectiveInject(i3.FormGroupDirective, 8), i0.ɵɵdirectiveInject(i3.NgControl, 10)); };
TDSInputNumberComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSInputNumberComponent, selectors: [["tds-input-number"]], viewQuery: function TDSInputNumberComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    } }, hostAttrs: [1, "inline-block", "box-border", "relative", "min-w-0", "group", "outline-none", "w-full"], hostVars: 30, hostBindings: function TDSInputNumberComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("tds-input-number-focused", ctx.isFocused)("tds-input-number-disabled", ctx.disabled)("bg-neutral-3-50", ctx.disabled)("cursor-not-allowed", ctx.disabled)("tds-input-number-rtl", ctx.dir === "rtl")("border", !ctx.parentIsFormField)("border-neutral-2-200", !ctx.parentIsFormField && !ctx.isFocused)("dark:border-d-neutral-2-200", !ctx.parentIsFormField && !ctx.isFocused)("border-primary-1", !ctx.parentIsFormField && ctx.isFocused)("ring", !ctx.parentIsFormField && ctx.isFocused)("ring-opacity-20", !ctx.parentIsFormField && ctx.isFocused)("ring-primary-1", !ctx.parentIsFormField && ctx.isFocused)("rounded", !ctx.parentIsFormField)("bg-white", !ctx.parentIsFormField && !ctx.disabled)("dark:bg-d-neutral-3-50", !ctx.parentIsFormField && !ctx.disabled);
    } }, inputs: { min: "min", max: "max", parser: "parser", precision: "precision", precisionMode: "precisionMode", placeholder: "placeholder", step: "step", inputMode: "inputMode", id: "id", disabled: "disabled", autoFocus: "autoFocus", formatter: "formatter", size: "size", required: "required", hiddenIcon: "hiddenIcon", autoFormat: "autoFormat" }, outputs: { tdsBlur: "tdsBlur", tdsFocus: "tdsFocus" }, exportAs: ["tdsInputNumber"], features: [i0.ɵɵProvidersFeature([
            {
                provide: TDSFormFieldControl,
                useExisting: forwardRef(() => TDSInputNumberComponent),
                multi: true
            }
        ]), i0.ɵɵNgOnChangesFeature], decls: 10, vars: 39, consts: [[1, "box-border", "min-w-0", "inline-block", "w-full", 3, "ngClass"], [1, "tds-input-number-handler-wrap", "absolute", "right-0", "top-0", "bottom-0", "w-8", 3, "ngClass"], [1, "w-full", "h-full", "flex", "flex-col", "items-center"], ["unselectable", "unselectable", 1, "tds-input-number-handler", "w-full", "text-center", "tds-input-number-handler-up", "h-1/2", "flex", "flex-col-reverse", "hover:bg-neutral-3-50", "hover:text-neutral-1-900", "dark:hover:text-d-neutral-1-900", "dark:hover:bg-d-neutral-3-400", "text-neutral-1-500", "dark:text-d-neutral-1-500", 3, "mousedown", "mouseup", "mouseleave"], [1, "tdsi-arrow-up-fill", "leading-3", "tds-input-number-handler-up-inner", 3, "ngClass"], ["unselectable", "unselectable", 1, "tds-input-number-handler", "w-full", "text-center", "tds-input-number-handler-down", "h-1/2", "flex", "flex-col", "hover:bg-neutral-3-50", "hover:text-neutral-1-900", "dark:hover:text-d-neutral-1-900", "dark:hover:bg-d-neutral-3-400", "text-neutral-1-500", "dark:text-d-neutral-1-500", 3, "mousedown", "mouseup", "mouseleave"], [1, "tdsi-arrow-down-fill", "leading-3", "tds-input-number-handler-down-inner", 3, "ngClass"], [1, "tds-input-number-input-wrap", "pl-3", 3, "ngClass"], ["autocomplete", "off", 1, "tds-input-number-input", "flex", "items-center", "text-body-2", "focus:outline-none", "focus:border-transparent", "shadow-none", "border-0", "bg-transparent", "text-current", "p-0", "m-0", "w-full", "outline-none", "box-border", "placeholder:text-neutral-1-400", "dark:placeholder:text-d-neutral-1-400", 3, "disabled", "placeholder", "ngModel", "ngModelChange"], ["inputElement", ""]], template: function TDSInputNumberComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "span", 3);
        i0.ɵɵlistener("mousedown", function TDSInputNumberComponent_Template_span_mousedown_3_listener($event) { return ctx.up($event); })("mouseup", function TDSInputNumberComponent_Template_span_mouseup_3_listener() { return ctx.stop(); })("mouseleave", function TDSInputNumberComponent_Template_span_mouseleave_3_listener() { return ctx.stop(); });
        i0.ɵɵelement(4, "i", 4);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(5, "span", 5);
        i0.ɵɵlistener("mousedown", function TDSInputNumberComponent_Template_span_mousedown_5_listener($event) { return ctx.down($event); })("mouseup", function TDSInputNumberComponent_Template_span_mouseup_5_listener() { return ctx.stop(); })("mouseleave", function TDSInputNumberComponent_Template_span_mouseleave_5_listener() { return ctx.stop(); });
        i0.ɵɵelement(6, "i", 6);
        i0.ɵɵelementEnd()()();
        i0.ɵɵelementStart(7, "div", 7)(8, "input", 8, 9);
        i0.ɵɵlistener("ngModelChange", function TDSInputNumberComponent_Template_input_ngModelChange_8_listener($event) { return ctx.onModelChange($event); });
        i0.ɵɵelementEnd()()();
    } if (rf & 2) {
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(24, _c1, ctx.size === "lg", ctx.size === "sm", ctx.size === "md"));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(28, _c2, ctx.disabled || ctx.hiddenIcon));
        i0.ɵɵadvance(2);
        i0.ɵɵclassProp("cursor-pointer", !ctx.disabledUp)("tds-input-number-handler-up-disabled", ctx.disabledUp);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(30, _c3, ctx.size == "sm", ctx.size !== "sm"));
        i0.ɵɵadvance(1);
        i0.ɵɵclassProp("tds-input-number-handler-down-disabled", ctx.disabledDown)("cursor-pointer", !ctx.disabledDown);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(33, _c3, ctx.size == "sm", ctx.size !== "sm"));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(36, _c4, !(ctx.disabled || ctx.hiddenIcon), ctx.disabled || ctx.hiddenIcon));
        i0.ɵɵadvance(1);
        i0.ɵɵclassProp("cursor-not-allowed", ctx.disabled);
        i0.ɵɵproperty("disabled", ctx.disabled)("placeholder", ctx.placeholder)("ngModel", ctx.displayValue);
        i0.ɵɵattribute("id", ctx.id)("autofocus", ctx.autoFocus ? "autofocus" : null)("min", ctx.min)("max", ctx.max)("step", ctx.step)("inputmode", ctx.inputMode);
    } }, directives: [i4.NgClass, i3.DefaultValueAccessor, i3.NgControlStatus, i3.NgModel], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSInputNumberComponent.prototype, "disabled", void 0);
__decorate([
    InputBoolean()
], TDSInputNumberComponent.prototype, "autoFocus", void 0);
__decorate([
    InputBoolean()
], TDSInputNumberComponent.prototype, "hiddenIcon", void 0);
__decorate([
    InputBoolean()
], TDSInputNumberComponent.prototype, "autoFormat", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSInputNumberComponent, [{
        type: Component,
        args: [{ selector: 'tds-input-number', exportAs: 'tdsInputNumber', providers: [
                    {
                        provide: TDSFormFieldControl,
                        useExisting: forwardRef(() => TDSInputNumberComponent),
                        multi: true
                    }
                ], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, host: {
                    '[class.tds-input-number-focused]': 'isFocused',
                    '[class.tds-input-number-disabled]': 'disabled',
                    '[class.bg-neutral-3-50]': 'disabled',
                    '[class.cursor-not-allowed]': 'disabled',
                    '[class.tds-input-number-rtl]': `dir === 'rtl'`,
                    '[class.border]': "!parentIsFormField",
                    '[class.border-neutral-2-200]': "!parentIsFormField && !isFocused",
                    '[class.dark:border-d-neutral-2-200]': "!parentIsFormField && !isFocused",
                    '[class.border-primary-1]': "!parentIsFormField && isFocused",
                    '[class.ring]': "!parentIsFormField && isFocused",
                    '[class.ring-opacity-20]': "!parentIsFormField && isFocused",
                    '[class.ring-primary-1]': "!parentIsFormField && isFocused",
                    '[class.rounded]': "!parentIsFormField ",
                    '[class.bg-white]': "!parentIsFormField && !disabled",
                    '[class.dark:bg-d-neutral-3-50]': "!parentIsFormField && !disabled",
                    'class': 'inline-block box-border relative min-w-0 group outline-none w-full'
                }, template: "<div class=\"box-border  min-w-0  inline-block w-full\"\r\n    [ngClass]=\"{'py-2':size === 'lg', 'py-1':size === 'sm','py-1.5': size === 'md'}\">\r\n\r\n    <div class=\"tds-input-number-handler-wrap absolute right-0 top-0 bottom-0 w-8\" [ngClass]=\"{'hidden':disabled || hiddenIcon}\">\r\n        <div class=\"w-full h-full flex  flex-col items-center\" >\r\n            <span unselectable=\"unselectable\"\r\n                class=\"tds-input-number-handler w-full text-center tds-input-number-handler-up h-1/2 flex flex-col-reverse hover:bg-neutral-3-50 hover:text-neutral-1-900 dark:hover:text-d-neutral-1-900 dark:hover:bg-d-neutral-3-400 text-neutral-1-500 dark:text-d-neutral-1-500\"\r\n                (mousedown)=\"up($event)\" (mouseup)=\"stop()\" (mouseleave)=\"stop()\" [class.cursor-pointer]=\"!disabledUp\"\r\n                [class.tds-input-number-handler-up-disabled]=\"disabledUp\">\r\n                <i [ngClass]=\"{'text-xs':size == 'sm','text-sm':size !== 'sm'}\"\r\n                    class=\"tdsi-arrow-up-fill leading-3  tds-input-number-handler-up-inner  \"></i>\r\n            </span>\r\n            <span unselectable=\"unselectable\"\r\n                class=\"tds-input-number-handler w-full text-center tds-input-number-handler-down  h-1/2 flex flex-col hover:bg-neutral-3-50 hover:text-neutral-1-900 dark:hover:text-d-neutral-1-900 dark:hover:bg-d-neutral-3-400 text-neutral-1-500 dark:text-d-neutral-1-500\"\r\n                (mousedown)=\"down($event)\" (mouseup)=\"stop()\" (mouseleave)=\"stop()\"\r\n                [class.tds-input-number-handler-down-disabled]=\"disabledDown\" [class.cursor-pointer]=\"!disabledDown\">\r\n                <i [ngClass]=\"{'text-xs':size == 'sm','text-sm':size !== 'sm'}\"\r\n                    class=\"tdsi-arrow-down-fill leading-3  tds-input-number-handler-down-inner \"></i>\r\n            </span>\r\n        </div>\r\n\r\n    </div>\r\n    <div class=\"tds-input-number-input-wrap pl-3\"  [ngClass]=\"{'pr-8':!(disabled || hiddenIcon),'pr-3':disabled || hiddenIcon}\">\r\n        <input #inputElement autocomplete=\"off\"\r\n            class=\"tds-input-number-input flex items-center text-body-2  focus:outline-none focus:border-transparent shadow-none border-0 bg-transparent text-current  p-0  m-0 w-full outline-none  box-border placeholder:text-neutral-1-400 dark:placeholder:text-d-neutral-1-400\"\r\n            [attr.id]=\"id\" [attr.autofocus]=\"autoFocus ? 'autofocus' : null\" [class.cursor-not-allowed]='disabled'\r\n            [disabled]=\"disabled\" [attr.min]=\"min\" [attr.max]=\"max\" [placeholder]=\"placeholder\" [attr.step]=\"step\"\r\n            [attr.inputmode]=\"inputMode\"  [ngModel]=\"displayValue\"\r\n            (ngModelChange)=\"onModelChange($event)\" />\r\n    </div>\r\n</div>" }]
    }], function () { return [{ type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.FocusMonitor }, { type: i2.Directionality, decorators: [{
                type: Optional
            }] }, { type: i5.TDSFormField, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TDS_FORM_FIELD]
            }, {
                type: Host
            }] }, { type: i3.NgForm, decorators: [{
                type: Optional
            }] }, { type: i3.FormGroupDirective, decorators: [{
                type: Optional
            }] }, { type: i3.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }]; }, { tdsBlur: [{
            type: Output
        }], tdsFocus: [{
            type: Output
        }], inputElement: [{
            type: ViewChild,
            args: ['inputElement', { static: true }]
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], parser: [{
            type: Input
        }], precision: [{
            type: Input
        }], precisionMode: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], step: [{
            type: Input
        }], inputMode: [{
            type: Input
        }], id: [{
            type: Input
        }], disabled: [{
            type: Input
        }], autoFocus: [{
            type: Input
        }], formatter: [{
            type: Input
        }], size: [{
            type: Input
        }], required: [{
            type: Input
        }], hiddenIcon: [{
            type: Input
        }], autoFormat: [{
            type: Input
        }] }); })();

class TDSInputNumberModule {
}
TDSInputNumberModule.ɵfac = function TDSInputNumberModule_Factory(t) { return new (t || TDSInputNumberModule)(); };
TDSInputNumberModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSInputNumberModule });
TDSInputNumberModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[BidiModule, CommonModule, FormsModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSInputNumberModule, [{
        type: NgModule,
        args: [{
                imports: [BidiModule, CommonModule, FormsModule],
                declarations: [TDSInputNumberComponent],
                exports: [TDSInputNumberComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSInputNumberModule, { declarations: [TDSInputNumberComponent], imports: [BidiModule, CommonModule, FormsModule], exports: [TDSInputNumberComponent] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSInputNumberComponent, TDSInputNumberModule };
//# sourceMappingURL=tds-ui-input-number.mjs.map
