import { __decorate } from 'tslib';
import * as i6 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, ViewChild, Injector, Injectable, Optional, Directive, Inject, Input, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { filter, take, takeUntil } from 'rxjs/operators';
import * as i1 from 'tds-ui/core/config';
import { WithConfig } from 'tds-ui/core/config';
import { InputBoolean } from 'tds-ui/shared/utility';
import * as i3 from '@angular/cdk/overlay';
import { OverlayRef, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { ComponentPortal, PortalModule } from '@angular/cdk/portal';
import { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';
import { fadeMotion } from 'tds-ui/core/animation';
import { isNotNil } from 'tds-ui/core/util';
import * as i4 from 'tds-ui/button';
import { TDSButtonModule } from 'tds-ui/button';
import * as i5 from '@angular/cdk/drag-drop';
import { DragDropModule } from '@angular/cdk/drag-drop';
import * as i3$1 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import { TDSPipesModule } from 'tds-ui/core/pipes';

const TDS_IMAGE_ZOOM_CLASS_NAME_MAP = {
    enter: 'tds-zoom-enter',
    enterActive: 'tds-zoom-enter-active',
    leave: 'tds-zoom-leave',
    leaveActive: 'tds-zoom-leave-active'
};
const TDS_IMAGE_FADE_CLASS_NAME_MAP = {
    enter: 'tds-fade-enter',
    enterActive: 'tds-fade-enter-active',
    leave: 'tds-fade-leave',
    leaveActive: 'tds-fade-leave-active'
};
const TDS_IMAGE_PREVIEW_MASK_CLASS_NAME = 'tds-image-preview-mask';

class TDSImagePreviewOptions {
    constructor() {
        this.keyboard = true;
        this.noAnimation = false;
        this.maskClosable = true;
        this.closeOnNavigation = true;
    }
}

class TDSImagePreviewRef {
    constructor(previewInstance, config, overlayRef) {
        this.previewInstance = previewInstance;
        this.config = config;
        this.overlayRef = overlayRef;
        overlayRef
            .keydownEvents()
            .pipe(filter(event => this.config.keyboard && event.keyCode === ESCAPE && !hasModifierKey(event)))
            .subscribe(event => {
            event.preventDefault();
            this.close();
        });
        overlayRef.detachments().subscribe(() => {
            this.overlayRef.dispose();
        });
        previewInstance.containerClick.pipe(take(1)).subscribe(() => {
            this.close();
        });
        previewInstance.closeClick.pipe(take(1)).subscribe(() => {
            this.close();
        });
        previewInstance.animationStateChanged
            .pipe(filter(event => event.phaseName === 'done' && event.toState === 'leave'), take(1))
            .subscribe(() => {
            this.dispose();
        });
    }
    switchTo(index) {
        this.previewInstance.switchTo(index);
    }
    next() {
        this.previewInstance.next();
    }
    prev() {
        this.previewInstance.prev();
    }
    close() {
        this.previewInstance.startLeaveAnimation();
    }
    dispose() {
        this.overlayRef.dispose();
    }
}

/**
 * fit content details: https://github.com/NG-ZORRO/ng-zorro-antd/pull/6154#issuecomment-745025554
 *
 * calc position x,y point
 *
 * CASE (width <= clientWidth && height <= clientHeight):
 *
 * ------------- clientWidth -------------
 * |                                     |
 * |        ------ width ------          |
 * |        |                 |          |
 * |        |                 |          |
 * client   height            |          |
 * Height   |                 |          |
 * |        |                 |          |
 * |        -------------------          |
 * |                                     |
 * |                                     |
 * ---------------------------------------
 * fixedPosition = { x: 0, y: 0 }
 *
 *
 *
 * CASE (width > clientWidth || height > clientHeight):
 *
 * ------------- clientWidth -------------
 * |        |                            |
 * |        top                          |
 * |        |                            |
 * |--left--|--------------- width -----------------
 * |        |                                      |
 * client   |                                      |
 * Height   |                                      |
 * |        |                                      |
 * |        |                                      |
 * |        height                                 |
 * |        |                                      |
 * ---------|                                      |
 *          |                                      |
 *          |                                      |
 *          |                                      |
 *          ----------------------------------------
 *
 *
 * - left || top > 0
 *   left -> 0 || top -> 0
 *
 * - (left + width) < clientWidth || (top + height) < clientHeight
 * - left | top + width | height < clientWidth | clientHeight -> Back left | top + width | height === clientWidth | clientHeight
 *
 * DEFAULT:
 * - hold position
 *
 */
function getFitContentPosition(params) {
    let fixPos = {};
    if (params.width <= params.clientWidth && params.height <= params.clientHeight) {
        fixPos = {
            x: 0,
            y: 0
        };
    }
    if (params.width > params.clientWidth || params.height > params.clientHeight) {
        fixPos = {
            x: fitPoint(params.left, params.width, params.clientWidth),
            y: fitPoint(params.top, params.height, params.clientHeight)
        };
    }
    return fixPos;
}
function getOffset(node) {
    const box = node.getBoundingClientRect();
    const docElem = document.documentElement;
    // use docElem.scrollLeft to support IE
    return {
        left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
        top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
    };
}
function getClientSize() {
    const width = document.documentElement.clientWidth;
    const height = window.innerHeight || document.documentElement.clientHeight;
    return {
        width,
        height
    };
}
function fitPoint(start, size, clientSize) {
    const startAddSize = start + size;
    const offsetStart = (size - clientSize) / 2;
    let distance = null;
    if (size > clientSize) {
        if (start > 0) {
            distance = offsetStart;
        }
        if (start < 0 && startAddSize < clientSize) {
            distance = -offsetStart;
        }
    }
    else {
        if (start < 0 || startAddSize > clientSize) {
            distance = start < 0 ? offsetStart : -offsetStart;
        }
    }
    return distance;
}

const _c0$1 = ["imgRef"];
function TDSImagePreviewComponent_ng_container_8_img_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "img", 13, 14);
} if (rf & 2) {
    const image_r3 = i0.ɵɵnextContext().$implicit;
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("width", image_r3.width)("height", image_r3.height)("transform", ctx_r5.previewImageTransform);
    i0.ɵɵattribute("src", image_r3.src, i0.ɵɵsanitizeUrl)("srcset", image_r3.srcset, i0.ɵɵsanitizeUrl)("alt", image_r3.alt);
} }
function TDSImagePreviewComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, TDSImagePreviewComponent_ng_container_8_img_1_Template, 2, 9, "img", 12);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const imageIndex_r4 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.index === imageIndex_r4);
} }
function TDSImagePreviewComponent_li_10_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "li", 15);
    i0.ɵɵlistener("click", function TDSImagePreviewComponent_li_10_Template_li_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r10); const option_r8 = restoredCtx.$implicit; return option_r8.onClick(); });
    i0.ɵɵelement(1, "span", 16);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r8 = ctx.$implicit;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("tds-image-preview-operations-operation-disabled", ctx_r1.zoomOutDisabled && option_r8.type === "zoomOut");
    i0.ɵɵproperty("ngClass", ctx_r1.zoomOutDisabled && option_r8.type === "zoomOut" ? "text-neutral-1-900" : "text-white");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", option_r8.icon);
} }
function TDSImagePreviewComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div", 17);
    i0.ɵɵlistener("click", function TDSImagePreviewComponent_ng_container_11_Template_div_click_1_listener($event) { i0.ɵɵrestoreView(_r12); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.onSwitchLeft($event); });
    i0.ɵɵelement(2, "span", 18);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(3, "div", 19);
    i0.ɵɵlistener("click", function TDSImagePreviewComponent_ng_container_11_Template_div_click_3_listener($event) { i0.ɵɵrestoreView(_r12); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.onSwitchRight($event); });
    i0.ɵɵelement(4, "span", 20);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("tds-image-preview-switch-left-disabled", ctx_r2.index <= 0);
    i0.ɵɵproperty("ngClass", ctx_r2.index <= 0 ? "text-neutral-1-900" : "text-white");
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("tds-image-preview-switch-right-disabled", ctx_r2.index >= ctx_r2.images.length - 1);
    i0.ɵɵproperty("ngClass", ctx_r2.index >= ctx_r2.images.length - 1 ? "text-neutral-1-900" : "text-white");
} }
const TDS_CONFIG_MODULE_NAME$2 = 'image';
const initialPosition = {
    x: 0,
    y: 0
};
class TDSImagePreviewComponent {
    constructor(cdr, tdsConfigService, config, overlayRef) {
        this.cdr = cdr;
        this.tdsConfigService = tdsConfigService;
        this.config = config;
        this.overlayRef = overlayRef;
        this.images = [];
        this.index = 0;
        this.isDragging = false;
        this.visible = true;
        this.animationState = 'enter';
        this.animationStateChanged = new EventEmitter();
        this.previewImageTransform = '';
        this.previewImageWrapperTransform = '';
        this.operations = [
            {
                icon: 'tdsi-rotate-left-line',
                onClick: () => {
                    this.onRotateLeft();
                },
                type: 'rotateLeft'
            },
            {
                icon: 'tdsi-rotate-right-line',
                onClick: () => {
                    this.onRotateRight();
                },
                type: 'rotateRight'
            },
            {
                icon: 'tdsi-zoom-out-line',
                onClick: () => {
                    this.onZoomOut();
                },
                type: 'zoomOut'
            },
            {
                icon: 'tdsi-zoom-in-line',
                onClick: () => {
                    this.onZoomIn();
                },
                type: 'zoomIn'
            },
        ];
        this.zoomOutDisabled = false;
        this.position = { ...initialPosition };
        this.containerClick = new EventEmitter();
        this.closeClick = new EventEmitter();
        this.destroy$ = new Subject();
        // TODO: move to host after View Engine deprecation
        this.zoom = this.config.zoom ?? 1;
        this.rotate = this.config.rotate ?? 0;
        this.updateZoomOutDisabled();
        this.updatePreviewImageTransform();
        this.updatePreviewImageWrapperTransform();
    }
    get animationDisabled() {
        return this.config.noAnimation ?? false;
    }
    get maskClosable() {
        const defaultConfig = this.tdsConfigService.getConfigForComponent(TDS_CONFIG_MODULE_NAME$2) || {};
        return this.config.maskClosable ?? defaultConfig.maskClosable ?? true;
    }
    setImages(images) {
        this.images = images;
        this.cdr.markForCheck();
    }
    switchTo(index) {
        this.index = index;
        this.cdr.markForCheck();
    }
    next() {
        if (this.index < this.images.length - 1) {
            this.reset();
            this.index++;
            this.updatePreviewImageTransform();
            this.updatePreviewImageWrapperTransform();
            this.updateZoomOutDisabled();
            this.cdr.markForCheck();
        }
    }
    prev() {
        if (this.index > 0) {
            this.reset();
            this.index--;
            this.updatePreviewImageTransform();
            this.updatePreviewImageWrapperTransform();
            this.updateZoomOutDisabled();
            this.cdr.markForCheck();
        }
    }
    markForCheck() {
        this.cdr.markForCheck();
    }
    onClose() {
        this.closeClick.emit();
    }
    onZoomIn() {
        this.zoom += 1;
        this.updatePreviewImageTransform();
        this.updateZoomOutDisabled();
        this.position = { ...initialPosition };
    }
    onZoomOut() {
        if (this.zoom > 1) {
            this.zoom -= 1;
            this.updatePreviewImageTransform();
            this.updateZoomOutDisabled();
            this.position = { ...initialPosition };
        }
    }
    onRotateRight() {
        this.rotate += 90;
        this.updatePreviewImageTransform();
    }
    onRotateLeft() {
        this.rotate -= 90;
        this.updatePreviewImageTransform();
    }
    onSwitchLeft(event) {
        event.preventDefault();
        event.stopPropagation();
        this.prev();
    }
    onSwitchRight(event) {
        event.preventDefault();
        event.stopPropagation();
        this.next();
    }
    onContainerClick(e) {
        if (e.target === e.currentTarget && this.maskClosable) {
            this.containerClick.emit();
        }
    }
    onAnimationStart(event) {
        if (event.toState === 'enter') {
            this.setEnterAnimationClass();
        }
        else if (event.toState === 'leave') {
            this.setLeaveAnimationClass();
        }
        this.animationStateChanged.emit(event);
    }
    onAnimationDone(event) {
        if (event.toState === 'enter') {
            this.setEnterAnimationClass();
        }
        else if (event.toState === 'leave') {
            this.setLeaveAnimationClass();
        }
        this.animationStateChanged.emit(event);
    }
    startLeaveAnimation() {
        this.animationState = 'leave';
        this.cdr.markForCheck();
    }
    onDragStarted() {
        this.isDragging = true;
    }
    onDragReleased() {
        this.isDragging = false;
        const width = this.imageRef.nativeElement.offsetWidth * this.zoom;
        const height = this.imageRef.nativeElement.offsetHeight * this.zoom;
        const { left, top } = getOffset(this.imageRef.nativeElement);
        const { width: clientWidth, height: clientHeight } = getClientSize();
        const isRotate = this.rotate % 180 !== 0;
        const fitContentParams = {
            width: isRotate ? height : width,
            height: isRotate ? width : height,
            left,
            top,
            clientWidth,
            clientHeight
        };
        const fitContentPos = getFitContentPosition(fitContentParams);
        if (isNotNil(fitContentPos.x) || isNotNil(fitContentPos.y)) {
            this.position = { ...this.position, ...fitContentPos };
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    updatePreviewImageTransform() {
        this.previewImageTransform = `scale3d(${this.zoom}, ${this.zoom}, 1) rotate(${this.rotate}deg)`;
    }
    updatePreviewImageWrapperTransform() {
        this.previewImageWrapperTransform = `translate3d(${this.position.x}px, ${this.position.y}px, 0)`;
    }
    updateZoomOutDisabled() {
        this.zoomOutDisabled = this.zoom <= 1;
    }
    setEnterAnimationClass() {
        if (this.animationDisabled) {
            return;
        }
        const backdropElement = this.overlayRef.backdropElement;
        if (backdropElement) {
            backdropElement.classList.add(TDS_IMAGE_FADE_CLASS_NAME_MAP.enter);
            backdropElement.classList.add(TDS_IMAGE_FADE_CLASS_NAME_MAP.enterActive);
        }
    }
    setLeaveAnimationClass() {
        if (this.animationDisabled) {
            return;
        }
        const backdropElement = this.overlayRef.backdropElement;
        if (backdropElement) {
            backdropElement.classList.add(TDS_IMAGE_FADE_CLASS_NAME_MAP.leave);
            backdropElement.classList.add(TDS_IMAGE_FADE_CLASS_NAME_MAP.leaveActive);
        }
    }
    reset() {
        this.zoom = 1;
        this.rotate = 0;
        this.position = { ...initialPosition };
    }
}
TDSImagePreviewComponent.ɵfac = function TDSImagePreviewComponent_Factory(t) { return new (t || TDSImagePreviewComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.TDSConfigService), i0.ɵɵdirectiveInject(TDSImagePreviewOptions), i0.ɵɵdirectiveInject(i3.OverlayRef)); };
TDSImagePreviewComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSImagePreviewComponent, selectors: [["tds-image-preview"]], viewQuery: function TDSImagePreviewComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$1, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.imageRef = _t.first);
    } }, hostAttrs: ["tabindex", "-1", "role", "document", 1, "fixed", "inset-0", "overflow-auto", "bg-black", "bg-opacity-40"], hostVars: 8, hostBindings: function TDSImagePreviewComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵsyntheticHostListener("@fadeMotion.start", function TDSImagePreviewComponent_animation_fadeMotion_start_HostBindingHandler($event) { return ctx.onAnimationStart($event); })("@fadeMotion.done", function TDSImagePreviewComponent_animation_fadeMotion_done_HostBindingHandler($event) { return ctx.onAnimationDone($event); });
        i0.ɵɵlistener("click", function TDSImagePreviewComponent_click_HostBindingHandler($event) { return ctx.onContainerClick($event); });
    } if (rf & 2) {
        i0.ɵɵsyntheticHostProperty("@.disabled", ctx.config.noAnimation)("@fadeMotion", ctx.animationState);
        i0.ɵɵstyleProp("z-index", ctx.config.zIndex);
        i0.ɵɵclassProp("tds-image-preview-moving", ctx.isDragging)("tds-image-preview-wrap", true);
    } }, exportAs: ["tdsImagePreview"], decls: 13, vars: 6, consts: [[1, "tds-image-preview", "pointer-events-none", "h-full", "text-center", "m-0", "p-0"], ["tabindex", "0", "aria-hidden", "true", 2, "width", "0", "height", "0", "overflow", "hidden", "outline", "none"], [1, "tds-image-preview-content", "m-0", "p-0", "w-full", "h-full"], [1, "tds-image-preview-body", "absolute", "inset-0", "overflow-hidden"], [1, "tds-image-preview-operations", "box-border", "absolute", "m-0", "p-0", "top-6", "right-6", "pointer-events-auto", 2, "z-index", "1"], [1, "tds-image-preview-operations-operation", "flex", "items-center", "justify-center", "cursor-pointer", 3, "click"], ["tds-button-close", "", 1, "tds-image-preview-operations-icon", "text-white", "dark:text-white"], ["cdkDrag", "", 1, "tds-image-preview-img-wrapper", "absolute", "inset-0", "flex", "items-center", "justify-center", 3, "cdkDragFreeDragPosition", "mousedown", "cdkDragReleased"], [4, "ngFor", "ngForOf"], [1, "tds-image-preview-operations", "pointer-events-auto", "box-border", "absolute", "m-0", "cursor-pointer", "bottom-0", "right-0", "flex", "justify-center", "items-center", "w-full", "bg-black", "bg-opacity-40", "py-3", 2, "z-index", "1"], ["class", "tds-image-preview-operations-operation mr-5  cursor-pointer  flex ", 3, "ngClass", "tds-image-preview-operations-operation-disabled", "click", 4, "ngFor", "ngForOf"], [4, "ngIf"], ["cdkDragHandle", "", "class", "tds-image-preview-img text-center pointer-events-auto", 3, "width", "height", "transform", 4, "ngIf"], ["cdkDragHandle", "", 1, "tds-image-preview-img", "text-center", "pointer-events-auto"], ["imgRef", ""], [1, "tds-image-preview-operations-operation", "mr-5", "cursor-pointer", "flex", 3, "ngClass", "click"], [1, "tds-image-preview-operations-icon", "text-xl", "leading-none", 3, "ngClass"], [1, "tds-image-preview-switch-left", "pointer-events-auto", "-mt-5", "cursor-pointer", "rounded-full", "bg-black", "bg-opacity-40", "text-white", "left-5", "absolute", "top-1/2", "flex", "items-censter", "z-10", "p-5", 3, "ngClass", "click"], [1, "tdsi-arrow-left-line", "text-xl", "leading-none"], [1, "tds-image-preview-switch-right", "rounded-full", "-mt-5", "pointer-events-auto", "cursor-pointer", "bg-black", "bg-opacity-40", "text-white", "absolute", "top-1/2", "right-5", "flex", "items-censter", "z-10", "p-5", 3, "ngClass", "click"], [1, "tdsi-arrow-right-line", "text-xl", "leading-none"]], template: function TDSImagePreviewComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelement(1, "div", 1);
        i0.ɵɵelementStart(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "div", 5);
        i0.ɵɵlistener("click", function TDSImagePreviewComponent_Template_div_click_5_listener() { return ctx.onClose(); });
        i0.ɵɵelement(6, "button", 6);
        i0.ɵɵelementEnd()();
        i0.ɵɵelementStart(7, "div", 7);
        i0.ɵɵlistener("mousedown", function TDSImagePreviewComponent_Template_div_mousedown_7_listener() { return ctx.onDragStarted(); })("cdkDragReleased", function TDSImagePreviewComponent_Template_div_cdkDragReleased_7_listener() { return ctx.onDragReleased(); });
        i0.ɵɵtemplate(8, TDSImagePreviewComponent_ng_container_8_Template, 2, 1, "ng-container", 8);
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(9, "ul", 9);
        i0.ɵɵtemplate(10, TDSImagePreviewComponent_li_10_Template, 2, 4, "li", 10);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(11, TDSImagePreviewComponent_ng_container_11_Template, 5, 6, "ng-container", 11);
        i0.ɵɵelementEnd()();
        i0.ɵɵelement(12, "div", 1);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(7);
        i0.ɵɵstyleProp("transform", ctx.previewImageWrapperTransform);
        i0.ɵɵproperty("cdkDragFreeDragPosition", ctx.position);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.images);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", ctx.operations);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.images.length > 1);
    } }, directives: [i4.TDSButtonCloseComponent, i5.CdkDrag, i6.NgForOf, i6.NgIf, i5.CdkDragHandle, i6.NgClass], encapsulation: 2, data: { animation: [fadeMotion] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSImagePreviewComponent, [{
        type: Component,
        args: [{
                selector: 'tds-image-preview',
                exportAs: 'tdsImagePreview',
                animations: [fadeMotion],
                template: `
    <div class="tds-image-preview pointer-events-none h-full	text-center m-0 p-0">
      <div tabindex="0" aria-hidden="true" style="width: 0; height: 0; overflow: hidden; outline: none;"></div>
      <div class="tds-image-preview-content m-0 p-0 w-full h-full">
        <div class="tds-image-preview-body absolute inset-0 overflow-hidden">
          <div class="tds-image-preview-operations box-border absolute m-0 p-0 top-6 right-6  pointer-events-auto" style="zIndex:1">
            <div
              class="tds-image-preview-operations-operation flex items-center justify-center cursor-pointer"             
              (click)="onClose()"
            >
            <button tds-button-close class="tds-image-preview-operations-icon text-white dark:text-white"></button>
             </div>
          </div>
          <div
            class="tds-image-preview-img-wrapper absolute inset-0 flex items-center justify-center"
            cdkDrag
            [style.transform]="previewImageWrapperTransform"
            [cdkDragFreeDragPosition]="position"
            (mousedown)="onDragStarted()"
            (cdkDragReleased)="onDragReleased()"
          >
            <ng-container *ngFor="let image of images; index as imageIndex">
              <img
                cdkDragHandle
                class="tds-image-preview-img text-center pointer-events-auto"
                #imgRef
                *ngIf="index === imageIndex"
                [attr.src]="image.src"
                [attr.srcset]="image.srcset"
                [attr.alt]="image.alt"
                [style.width]="image.width"
                [style.height]="image.height"
                [style.transform]="previewImageTransform"
              />
            </ng-container>
          </div>
          <ul class="tds-image-preview-operations pointer-events-auto box-border absolute m-0  cursor-pointer bottom-0 right-0 flex justify-center items-center w-full bg-black bg-opacity-40 py-3" style="zIndex:1">
            <li
              class="tds-image-preview-operations-operation mr-5  cursor-pointer  flex "
              [ngClass]="zoomOutDisabled && option.type === 'zoomOut' ?'text-neutral-1-900':'text-white'"
              [class.tds-image-preview-operations-operation-disabled]="zoomOutDisabled && option.type === 'zoomOut'"
              (click)="option.onClick()"
              *ngFor="let option of operations"
            >
              <span class="tds-image-preview-operations-icon text-xl leading-none " [ngClass]="option.icon"></span>
            </li>
          </ul>
          <ng-container *ngIf="images.length > 1">
            <div
              class="tds-image-preview-switch-left pointer-events-auto -mt-5  cursor-pointer rounded-full bg-black bg-opacity-40  text-white left-5 absolute top-1/2  flex items-censter  z-10 p-5"
              [class.tds-image-preview-switch-left-disabled]="index <= 0"
              [ngClass]="index <= 0 ?'text-neutral-1-900':'text-white'"
              (click)="onSwitchLeft($event)"
            >
              <span class="tdsi-arrow-left-line text-xl leading-none"></span>
            </div>
            <div
              class="tds-image-preview-switch-right rounded-full -mt-5 pointer-events-auto cursor-pointer bg-black bg-opacity-40 text-white absolute top-1/2 right-5 flex items-censter z-10 p-5"
              [class.tds-image-preview-switch-right-disabled]="index >= images.length - 1"
              [ngClass]="index >= (images.length - 1) ?'text-neutral-1-900':'text-white'"
              (click)="onSwitchRight($event)"
            >
              <span class="tdsi-arrow-right-line text-xl leading-none"></span>
            </div>
          </ng-container>
        </div>
      </div>
      <div tabindex="0" aria-hidden="true" style="width: 0; height: 0; overflow: hidden; outline: none;"></div>
    </div>
  `,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    '[class.tds-image-preview-moving]': 'isDragging',
                    '[style.zIndex]': 'config.zIndex',
                    '[class.tds-image-preview-wrap]': 'true',
                    '[@.disabled]': 'config.noAnimation',
                    '[@fadeMotion]': 'animationState',
                    '(@fadeMotion.start)': 'onAnimationStart($event)',
                    '(@fadeMotion.done)': 'onAnimationDone($event)',
                    '(click)': 'onContainerClick($event)',
                    'class': "fixed inset-0 overflow-auto bg-black bg-opacity-40",
                    tabindex: '-1',
                    role: 'document'
                }
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.TDSConfigService }, { type: TDSImagePreviewOptions }, { type: i3.OverlayRef }]; }, { imageRef: [{
            type: ViewChild,
            args: ['imgRef']
        }] }); })();

const TDS_CONFIG_MODULE_NAME$1 = 'image';
class TDSImageService {
    constructor(overlay, injector, tdsConfigService, directionality) {
        this.overlay = overlay;
        this.injector = injector;
        this.tdsConfigService = tdsConfigService;
        this.directionality = directionality;
    }
    preview(images, options) {
        return this.display(images, options);
    }
    display(images, config) {
        const configMerged = { ...new TDSImagePreviewOptions(), ...(config ?? {}) };
        const overlayRef = this.createOverlay(configMerged);
        const previewComponent = this.attachPreviewComponent(overlayRef, configMerged);
        previewComponent.setImages(images);
        const previewRef = new TDSImagePreviewRef(previewComponent, configMerged, overlayRef);
        previewComponent.previewRef = previewRef;
        return previewRef;
    }
    attachPreviewComponent(overlayRef, config) {
        const injector = Injector.create({
            parent: this.injector,
            providers: [
                { provide: OverlayRef, useValue: overlayRef },
                { provide: TDSImagePreviewOptions, useValue: config }
            ]
        });
        const containerPortal = new ComponentPortal(TDSImagePreviewComponent, null, injector);
        const containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    }
    createOverlay(config) {
        const globalConfig = this.tdsConfigService.getConfigForComponent(TDS_CONFIG_MODULE_NAME$1) || {};
        const overLayConfig = new OverlayConfig({
            hasBackdrop: true,
            scrollStrategy: this.overlay.scrollStrategies.block(),
            positionStrategy: this.overlay.position().global(),
            disposeOnNavigation: config.closeOnNavigation ?? globalConfig.closeOnNavigation ?? true,
            backdropClass: TDS_IMAGE_PREVIEW_MASK_CLASS_NAME,
            direction: config.direction || globalConfig.direction || this.directionality.value
        });
        return this.overlay.create(overLayConfig);
    }
}
TDSImageService.ɵfac = function TDSImageService_Factory(t) { return new (t || TDSImageService)(i0.ɵɵinject(i3.Overlay), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i1.TDSConfigService), i0.ɵɵinject(i3$1.Directionality, 8)); };
TDSImageService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TDSImageService, factory: TDSImageService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSImageService, [{
        type: Injectable
    }], function () { return [{ type: i3.Overlay }, { type: i0.Injector }, { type: i1.TDSConfigService }, { type: i3$1.Directionality, decorators: [{
                type: Optional
            }] }]; }, null); })();

const _c0 = ["*"];
class TDSImageGroupComponent {
    constructor() {
        this.images = [];
    }
    addImage(image) {
        this.images.push(image);
    }
}
TDSImageGroupComponent.ɵfac = function TDSImageGroupComponent_Factory(t) { return new (t || TDSImageGroupComponent)(); };
TDSImageGroupComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSImageGroupComponent, selectors: [["tds-image-group"]], exportAs: ["tdsImageGroup"], ngContentSelectors: _c0, decls: 1, vars: 0, template: function TDSImageGroupComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSImageGroupComponent, [{
        type: Component,
        args: [{
                selector: 'tds-image-group',
                exportAs: 'tdsImageGroup',
                template: '<ng-content></ng-content>',
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            }]
    }], null, null); })();

const TDS_CONFIG_MODULE_NAME = 'image';
class TDSImageDirective {
    constructor(document, tdsConfigService, elementRef, tdsImageService, cdr, parentGroup, directionality) {
        this.document = document;
        this.tdsConfigService = tdsConfigService;
        this.elementRef = elementRef;
        this.tdsImageService = tdsImageService;
        this.cdr = cdr;
        this.parentGroup = parentGroup;
        this.directionality = directionality;
        this._TDSModuleName = TDS_CONFIG_MODULE_NAME;
        this.tdsSrc = '';
        this.srcset = '';
        this.disablePreview = false;
        this.fallback = null;
        this.placeholder = null;
        this.status = 'normal';
        this.destroy$ = new Subject();
    }
    get previewable() {
        return !this.disablePreview && this.status !== 'error';
    }
    ngOnInit() {
        this.backLoad();
        if (this.parentGroup) {
            this.parentGroup.addImage(this);
        }
        if (this.directionality) {
            this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
                this.dir = direction;
                this.cdr.detectChanges();
            });
            this.dir = this.directionality.value;
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    onPreview() {
        if (!this.previewable) {
            return;
        }
        if (this.parentGroup) {
            // preview inside image group
            const previewAbleImages = this.parentGroup.images.filter(e => e.previewable);
            const previewImages = previewAbleImages.map(e => ({ src: e.tdsSrc, srcset: e.srcset }));
            const previewIndex = previewAbleImages.findIndex(el => this === el);
            const previewRef = this.tdsImageService.preview(previewImages, { direction: this.dir });
            previewRef.switchTo(previewIndex);
        }
        else {
            // preview not inside image group
            const previewImages = [{ src: this.tdsSrc, srcset: this.srcset }];
            this.tdsImageService.preview(previewImages, { direction: this.dir });
        }
    }
    getElement() {
        return this.elementRef;
    }
    ngOnChanges(changes) {
        const { tdsSrc } = changes;
        if (tdsSrc) {
            this.getElement().nativeElement.src = tdsSrc.currentValue;
            this.backLoad();
        }
    }
    /**
     * use internal Image object handle fallback & placeholder
     *
     * @private
     */
    backLoad() {
        this.backLoadImage = this.document.createElement('img');
        this.backLoadImage.src = this.tdsSrc;
        this.backLoadImage.srcset = this.srcset;
        this.status = 'loading';
        if (this.backLoadImage.complete) {
            this.status = 'normal';
            this.getElement().nativeElement.src = this.tdsSrc;
            this.getElement().nativeElement.srcset = this.srcset;
        }
        else {
            if (this.placeholder) {
                this.getElement().nativeElement.src = this.placeholder;
                this.getElement().nativeElement.srcset = '';
            }
            else {
                this.getElement().nativeElement.src = this.tdsSrc;
                this.getElement().nativeElement.srcset = this.srcset;
            }
            this.backLoadImage.onload = () => {
                this.status = 'normal';
                this.getElement().nativeElement.src = this.tdsSrc;
                this.getElement().nativeElement.srcset = this.srcset;
            };
            this.backLoadImage.onerror = () => {
                this.status = 'error';
                if (this.fallback) {
                    this.getElement().nativeElement.src = this.fallback;
                    this.getElement().nativeElement.srcset = '';
                }
            };
        }
    }
}
TDSImageDirective.ɵfac = function TDSImageDirective_Factory(t) { return new (t || TDSImageDirective)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i1.TDSConfigService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(TDSImageService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(TDSImageGroupComponent, 8), i0.ɵɵdirectiveInject(i3$1.Directionality, 8)); };
TDSImageDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSImageDirective, selectors: [["img", "tds-image", ""]], hostBindings: function TDSImageDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("click", function TDSImageDirective_click_HostBindingHandler() { return ctx.onPreview(); });
    } }, inputs: { tdsSrc: "tdsSrc", srcset: "srcset", disablePreview: "disablePreview", fallback: "fallback", placeholder: "placeholder" }, exportAs: ["tdsImage"], features: [i0.ɵɵNgOnChangesFeature] });
__decorate([
    InputBoolean(),
    WithConfig()
], TDSImageDirective.prototype, "disablePreview", void 0);
__decorate([
    WithConfig()
], TDSImageDirective.prototype, "fallback", void 0);
__decorate([
    WithConfig()
], TDSImageDirective.prototype, "placeholder", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSImageDirective, [{
        type: Directive,
        args: [{
                selector: 'img[tds-image]',
                exportAs: 'tdsImage',
                host: {
                    '(click)': 'onPreview()'
                }
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: i1.TDSConfigService }, { type: i0.ElementRef }, { type: TDSImageService }, { type: i0.ChangeDetectorRef }, { type: TDSImageGroupComponent, decorators: [{
                type: Optional
            }] }, { type: i3$1.Directionality, decorators: [{
                type: Optional
            }] }]; }, { tdsSrc: [{
            type: Input
        }], srcset: [{
            type: Input
        }], disablePreview: [{
            type: Input
        }], fallback: [{
            type: Input
        }], placeholder: [{
            type: Input
        }] }); })();

class TDSImageModule {
}
TDSImageModule.ɵfac = function TDSImageModule_Factory(t) { return new (t || TDSImageModule)(); };
TDSImageModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSImageModule });
TDSImageModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [TDSImageService], imports: [[BidiModule, OverlayModule, PortalModule, DragDropModule, CommonModule, TDSPipesModule, TDSButtonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSImageModule, [{
        type: NgModule,
        args: [{
                imports: [BidiModule, OverlayModule, PortalModule, DragDropModule, CommonModule, TDSPipesModule, TDSButtonModule],
                exports: [TDSImageDirective, TDSImagePreviewComponent, TDSImageGroupComponent],
                providers: [TDSImageService],
                declarations: [TDSImageDirective, TDSImagePreviewComponent, TDSImageGroupComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSImageModule, { declarations: [TDSImageDirective, TDSImagePreviewComponent, TDSImageGroupComponent], imports: [BidiModule, OverlayModule, PortalModule, DragDropModule, CommonModule, TDSPipesModule, TDSButtonModule], exports: [TDSImageDirective, TDSImagePreviewComponent, TDSImageGroupComponent] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSImageDirective, TDSImageGroupComponent, TDSImageModule, TDSImagePreviewComponent, TDSImagePreviewOptions, TDSImagePreviewRef, TDSImageService, TDS_IMAGE_FADE_CLASS_NAME_MAP, TDS_IMAGE_PREVIEW_MASK_CLASS_NAME, TDS_IMAGE_ZOOM_CLASS_NAME_MAP, getClientSize, getFitContentPosition, getOffset };
//# sourceMappingURL=tds-ui-image.mjs.map
