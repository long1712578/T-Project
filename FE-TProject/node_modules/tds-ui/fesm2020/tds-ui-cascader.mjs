import { __decorate } from 'tslib';
import { DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, BACKSPACE, ESCAPE } from '@angular/cdk/keycodes';
import * as i6 from '@angular/cdk/overlay';
import { CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, ViewEncapsulation, Input, Injectable, EventEmitter, forwardRef, Optional, Host, ViewChild, ViewChildren, Output, HostListener, NgModule } from '@angular/core';
import * as i8 from '@angular/forms';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { BehaviorSubject, Subject, fromEvent } from 'rxjs';
import { takeUntil, startWith } from 'rxjs/operators';
import { InputBoolean } from 'tds-ui/shared/utility';
import * as i7 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2 from 'tds-ui/progress-spinner';
import { TDSSpinnerModule } from 'tds-ui/progress-spinner';
import * as i3 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';
import * as i4 from 'tds-ui/core/highlight';
import { TDSHighlightModule } from 'tds-ui/core/highlight';
import { isNotNil, arraysEqual, toArray } from 'tds-ui/core/util';
import * as i2$1 from 'tds-ui/core/config';
import { WithConfig } from 'tds-ui/core/config';
import { slideMotion } from 'tds-ui/core/animation';
import * as i11 from 'tds-ui/core/overlay';
import { DEFAULT_CASCADER_POSITIONS, TDSOverlayModule } from 'tds-ui/core/overlay';
import * as i3$1 from 'tds-ui/i18n';
import * as i4$1 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i5 from 'tds-ui/core/no-animation';
import { TDSNoAnimationModule } from 'tds-ui/core/no-animation';
import * as i12 from 'tds-ui/empty';
import { TDSEmptyModule } from 'tds-ui/empty';
import { TDSInputModule } from 'tds-ui/tds-input';

function isShowSearchObject(options) {
    return typeof options !== 'boolean';
}

function isChildOption(o) {
    return o.isLeaf || !o.children || !o.children.length;
}
function isParentOption(o) {
    return !!o.children && !!o.children.length && !o.isLeaf;
}

const _c0$1 = ["tds-cascader-option", ""];
function TDSCascaderOptionComponent_ng_container_0_ng_template_1_Template(rf, ctx) { }
const _c1$1 = function (a0, a1) { return { $implicit: a0, index: a1 }; };
function TDSCascaderOptionComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, TDSCascaderOptionComponent_ng_container_0_ng_template_1_Template, 0, 0, "ng-template", 3);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r0.optionTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction2(2, _c1$1, ctx_r0.option, ctx_r0.columnIndex));
} }
function TDSCascaderOptionComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 4);
    i0.ɵɵpipe(1, "tdsHighlight");
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("innerHTML", i0.ɵɵpipeBind4(1, 1, ctx_r2.optionLabel, ctx_r2.highlightText, "g", "tds-cascader-menu-item-keyword"), i0.ɵɵsanitizeHtml);
} }
function TDSCascaderOptionComponent_div_3_span_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵelement(1, "tds-spinner", 7);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("color", "primary");
} }
function TDSCascaderOptionComponent_div_3_ng_template_2_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "span");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(ctx_r8.expandIcon);
} }
function TDSCascaderOptionComponent_div_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, TDSCascaderOptionComponent_div_3_ng_template_2_ng_container_0_Template, 2, 2, "ng-container", 8);
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r7.expandIcon);
} }
function TDSCascaderOptionComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtemplate(1, TDSCascaderOptionComponent_div_3_span_1_Template, 2, 1, "span", 0);
    i0.ɵɵtemplate(2, TDSCascaderOptionComponent_div_3_ng_template_2_Template, 1, 1, "ng-template", null, 6, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r6 = i0.ɵɵreference(3);
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r3.option.loading)("ngIfElse", _r6);
} }
class TDSCascaderOptionComponent {
    constructor(cdr, elementRef, renderer) {
        this.cdr = cdr;
        this.optionTemplate = null;
        this.activated = false;
        this.tdsLabelProperty = 'label';
        this.expandIcon = '';
        this.dir = 'ltr';
        renderer.addClass(elementRef.nativeElement, 'tds-cascader-menu-item');
        renderer.addClass(elementRef.nativeElement, 'tds-cascader-menu-item-expanded');
        this.nativeElement = elementRef.nativeElement;
    }
    ngOnInit() {
        if (this.expandIcon === '' && this.dir === 'rtl') {
            this.expandIcon = 'tdsi-arrow-left-line';
        }
        else if (this.expandIcon === '') {
            this.expandIcon = 'tdsi-arrow-right-line';
        }
    }
    get optionLabel() {
        return this.option[this.tdsLabelProperty];
    }
    markForCheck() {
        this.cdr.markForCheck();
    }
}
TDSCascaderOptionComponent.ɵfac = function TDSCascaderOptionComponent_Factory(t) { return new (t || TDSCascaderOptionComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2)); };
TDSCascaderOptionComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCascaderOptionComponent, selectors: [["", "tds-cascader-option", ""]], hostVars: 7, hostBindings: function TDSCascaderOptionComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("title", ctx.option.title || ctx.optionLabel);
        i0.ɵɵclassProp("tds-cascader-menu-item-active", ctx.activated)("tds-cascader-menu-item-expand", !ctx.option.isLeaf)("tds-cascader-menu-item-disabled", ctx.option.disabled);
    } }, inputs: { optionTemplate: "optionTemplate", option: "option", activated: "activated", highlightText: "highlightText", tdsLabelProperty: "tdsLabelProperty", columnIndex: "columnIndex", expandIcon: "expandIcon", dir: "dir" }, exportAs: ["tdsCascaderOption"], attrs: _c0$1, decls: 4, vars: 3, consts: [[4, "ngIf", "ngIfElse"], ["defaultOptionTemplate", ""], ["class", "tds-cascader-menu-item-expand-icon text-base leading-4 text-neutral-600 dark:text-d-neutral-1-600", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "tds-cascader-menu-item-content", 3, "innerHTML"], [1, "tds-cascader-menu-item-expand-icon", "text-base", "leading-4", "text-neutral-600", "dark:text-d-neutral-1-600"], ["icon", ""], [1, "h-4", "w-4", 3, "color"], [4, "tdsStringTemplateOutlet"]], template: function TDSCascaderOptionComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TDSCascaderOptionComponent_ng_container_0_Template, 2, 5, "ng-container", 0);
        i0.ɵɵtemplate(1, TDSCascaderOptionComponent_ng_template_1_Template, 2, 6, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtemplate(3, TDSCascaderOptionComponent_div_3_Template, 4, 2, "div", 2);
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(2);
        i0.ɵɵproperty("ngIf", ctx.optionTemplate)("ngIfElse", _r1);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.option.isLeaf || (ctx.option.children == null ? null : ctx.option.children.length) || ctx.option.loading);
    } }, directives: [i7.NgIf, i7.NgTemplateOutlet, i2.TDSProgressSpinnerComponent, i3.TDSStringTemplateOutletDirective], pipes: [i4.TDSHighlightPipe], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCascaderOptionComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                selector: '[tds-cascader-option]',
                exportAs: 'tdsCascaderOption',
                template: `
    <ng-container *ngIf="optionTemplate; else defaultOptionTemplate">
      <ng-template
        [ngTemplateOutlet]="optionTemplate"
        [ngTemplateOutletContext]="{ $implicit: option, index: columnIndex }"
      ></ng-template>
    </ng-container>
    <ng-template #defaultOptionTemplate>
      <div
        class="tds-cascader-menu-item-content"
        [innerHTML]="optionLabel | tdsHighlight: highlightText:'g':'tds-cascader-menu-item-keyword'"
      ></div>
    </ng-template>
    <div *ngIf="!option.isLeaf || option.children?.length || option.loading" class="tds-cascader-menu-item-expand-icon text-base leading-4 text-neutral-600 dark:text-d-neutral-1-600">
      <span *ngIf="option.loading; else icon">
        <tds-spinner [color]="'primary'" class="h-4 w-4"></tds-spinner>
      </span>      
      <ng-template #icon>
      <ng-container *tdsStringTemplateOutlet="expandIcon">
      <span [class]="expandIcon"></span>
  </ng-container>
      </ng-template>
    </div>
  `,
                host: {
                    '[attr.title]': 'option.title || optionLabel',
                    '[class.tds-cascader-menu-item-active]': 'activated',
                    '[class.tds-cascader-menu-item-expand]': '!option.isLeaf',
                    '[class.tds-cascader-menu-item-disabled]': 'option.disabled',
                }
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, { optionTemplate: [{
            type: Input
        }], option: [{
            type: Input
        }], activated: [{
            type: Input
        }], highlightText: [{
            type: Input
        }], tdsLabelProperty: [{
            type: Input
        }], columnIndex: [{
            type: Input
        }], expandIcon: [{
            type: Input
        }], dir: [{
            type: Input
        }] }); })();

/**
 * All data is stored and parsed in TDSCascaderService.
 */
class TDSCascaderService {
    constructor() {
        /** Activated options in each column. */
        this.activatedOptions = [];
        /** An array to store cascader items arranged in different layers. */
        this.columns = [];
        /** If user has entered searching mode. */
        this.inSearchingMode = false;
        /** Selected options would be output to user. */
        this.selectedOptions = [];
        this.values = [];
        this.$loading = new BehaviorSubject(false);
        /**
         * Emit an event to notify cascader it needs to redraw because activated or
         * selected options are changed.
         */
        this.$redraw = new Subject();
        /**
         * Emit an event when an option gets selected.
         * Emit true if a leaf options is selected.
         */
        this.$optionSelected = new Subject();
        /**
         * Emit an event to notify cascader it needs to quit searching mode.
         * Only emit when user do select a searching option.
         */
        this.$quitSearching = new Subject();
        /** To hold columns before entering searching mode. */
        this.columnsSnapshot = [[]];
        /** To hold activated options before entering searching mode. */
        this.activatedOptionsSnapshot = [];
    }
    /** Return cascader options in the first layer. */
    get tdsOptions() {
        return this.columns[0];
    }
    ngOnDestroy() {
        this.$redraw.complete();
        this.$quitSearching.complete();
        this.$optionSelected.complete();
        this.$loading.complete();
    }
    /**
     * Make sure that value matches what is displayed in the dropdown.
     */
    syncOptions(first = false) {
        const values = this.values;
        const hasValue = values && values.length;
        const lastColumnIndex = values.length - 1;
        const initColumnWithIndex = (columnIndex) => {
            const activatedOptionSetter = () => {
                const currentValue = values[columnIndex];
                if (!isNotNil(currentValue)) {
                    this.$redraw.next();
                    return;
                }
                const option = this.findOptionWithValue(columnIndex, values[columnIndex]) ||
                    (typeof currentValue === 'object'
                        ? currentValue
                        : {
                            [`${this.cascaderComponent.tdsValueProperty}`]: currentValue,
                            [`${this.cascaderComponent.tdsLabelProperty}`]: currentValue
                        });
                this.setOptionActivated(option, columnIndex, false, false);
                if (columnIndex < lastColumnIndex) {
                    initColumnWithIndex(columnIndex + 1);
                }
                else {
                    this.dropBehindColumns(columnIndex);
                    this.selectedOptions = [...this.activatedOptions];
                    this.$redraw.next();
                }
            };
            if (this.isLoaded(columnIndex) || !this.cascaderComponent.tdsLoadData) {
                activatedOptionSetter();
            }
            else {
                const option = this.activatedOptions[columnIndex - 1] || {};
                this.loadChildren(option, columnIndex - 1, activatedOptionSetter);
            }
        };
        this.activatedOptions = [];
        this.selectedOptions = [];
        if (first && this.cascaderComponent.tdsLoadData && !hasValue) {
            // Should also notify the component that value changes. Fix #3480.
            this.$redraw.next();
            return;
        }
        else {
            initColumnWithIndex(0);
        }
    }
    /**
     * Bind cascader component so this service could use inputs.
     */
    withComponent(cascaderComponent) {
        this.cascaderComponent = cascaderComponent;
    }
    /**
     * Reset all options. Rebuild searching options if in searching mode.
     */
    withOptions(options) {
        this.columnsSnapshot = this.columns = options && options.length ? [options] : [];
        if (this.inSearchingMode) {
            this.prepareSearchOptions(this.cascaderComponent.inputValue);
        }
        else if (this.columns.length) {
            this.syncOptions();
        }
    }
    /**
     * Try to set a option as activated.
     *
     * @param option Cascader option
     * @param columnIndex Of which column this option is in
     * @param performSelect Select
     * @param loadingChildren Try to load children asynchronously.
     */
    setOptionActivated(option, columnIndex, performSelect = false, loadingChildren = true) {
        if (option.disabled) {
            return;
        }
        this.activatedOptions[columnIndex] = option;
        this.trackAncestorActivatedOptions(columnIndex);
        this.dropBehindActivatedOptions(columnIndex);
        const isParent = isParentOption(option);
        if (isParent) {
            // Parent option that has children.
            this.setColumnData(option.children, columnIndex + 1, option);
        }
        else if (!option.isLeaf && loadingChildren) {
            // Parent option that should try to load children asynchronously.
            this.loadChildren(option, columnIndex);
        }
        else if (option.isLeaf) {
            // Leaf option.
            this.dropBehindColumns(columnIndex);
        }
        // Actually perform selection to make an options not only activated but also selected.
        if (performSelect) {
            this.setOptionSelected(option, columnIndex);
        }
        this.$redraw.next();
    }
    setOptionSelected(option, index) {
        const changeOn = this.cascaderComponent.tdsChangeOn;
        const shouldPerformSelection = (o, i) => typeof changeOn === 'function' ? changeOn(o, i) : false;
        if (option.isLeaf || this.cascaderComponent.tdsChangeOnSelect || shouldPerformSelection(option, index)) {
            this.selectedOptions = [...this.activatedOptions];
            this.prepareEmitValue();
            this.$redraw.next();
            this.$optionSelected.next({ option, index });
        }
    }
    setOptionDeactivatedSinceColumn(column) {
        this.dropBehindActivatedOptions(column - 1);
        this.dropBehindColumns(column);
        this.$redraw.next();
    }
    /**
     * Set a searching option as selected, finishing up things.
     *
     * @param option
     */
    setSearchOptionSelected(option) {
        this.activatedOptions = [option];
        this.selectedOptions = [...option.path];
        this.prepareEmitValue();
        this.$redraw.next();
        this.$optionSelected.next({ option, index: 0 });
        setTimeout(() => {
            // Reset data and tell UI only to remove input and reset dropdown width style.
            this.$quitSearching.next();
            this.$redraw.next();
            this.inSearchingMode = false;
            this.columns = [...this.columnsSnapshot];
            this.activatedOptions = [...this.selectedOptions];
        }, 200);
    }
    /**
     * Filter cascader options to reset `columns`.
     *
     * @param searchValue The string user wants to search.
     */
    prepareSearchOptions(searchValue) {
        const results = []; // Search results only have one layer.
        const path = [];
        const defaultFilter = (i, p) => p.some(o => {
            const label = this.getOptionLabel(o);
            return !!label && label.indexOf(i) !== -1;
        });
        const showSearch = this.cascaderComponent.tdsShowSearch;
        const filter = isShowSearchObject(showSearch) && showSearch.filter ? showSearch.filter : defaultFilter;
        const sorter = isShowSearchObject(showSearch) && showSearch.sorter ? showSearch.sorter : null;
        const loopChild = (node, forceDisabled = false) => {
            path.push(node);
            const cPath = Array.from(path);
            if (filter(searchValue, cPath)) {
                const disabled = forceDisabled || node.disabled;
                const option = {
                    disabled,
                    isLeaf: true,
                    path: cPath,
                    [this.cascaderComponent.tdsLabelProperty]: cPath.map(p => this.getOptionLabel(p)).join(' / ')
                };
                results.push(option);
            }
            path.pop();
        };
        const loopParent = (node, forceDisabled = false) => {
            const disabled = forceDisabled || node.disabled;
            path.push(node);
            node.children.forEach(sNode => {
                if (!sNode.parent) {
                    sNode.parent = node;
                }
                if (!sNode.isLeaf) {
                    loopParent(sNode, disabled);
                }
                if (sNode.isLeaf || !sNode.children || !sNode.children.length) {
                    loopChild(sNode, disabled);
                }
            });
            path.pop();
        };
        if (!this.columnsSnapshot.length) {
            this.columns = [[]];
            return;
        }
        this.columnsSnapshot[0].forEach(o => (isChildOption(o) ? loopChild(o) : loopParent(o)));
        if (sorter) {
            results.sort((a, b) => sorter(a.path, b.path, searchValue));
        }
        this.columns = [results];
        this.$redraw.next(); // Search results may be empty, so should redraw.
    }
    /**
     * Toggle searching mode by UI. It deals with things not directly related to UI.
     *
     * @param toSearching If this cascader is entering searching mode
     */
    toggleSearchingMode(toSearching) {
        this.inSearchingMode = toSearching;
        if (toSearching) {
            this.activatedOptionsSnapshot = [...this.activatedOptions];
            this.activatedOptions = [];
            this.selectedOptions = [];
            this.$redraw.next();
        }
        else {
            // User quit searching mode without selecting an option.
            this.activatedOptions = [...this.activatedOptionsSnapshot];
            this.selectedOptions = [...this.activatedOptions];
            this.columns = [...this.columnsSnapshot];
            this.syncOptions();
            this.$redraw.next();
        }
    }
    /**
     * Clear selected options.
     */
    clear() {
        this.values = [];
        this.selectedOptions = [];
        this.activatedOptions = [];
        this.dropBehindColumns(0);
        this.$redraw.next();
        this.$optionSelected.next(null);
    }
    getOptionLabel(o) {
        return o[this.cascaderComponent.tdsLabelProperty || 'label'];
    }
    getOptionValue(o) {
        return o[this.cascaderComponent.tdsValueProperty || 'value'];
    }
    /**
     * Try to insert options into a column.
     *
     * @param options Options to insert
     * @param columnIndex Position
     */
    setColumnData(options, columnIndex, parent) {
        const existingOptions = this.columns[columnIndex];
        if (!arraysEqual(existingOptions, options)) {
            options.forEach(o => (o.parent = parent));
            this.columns[columnIndex] = options;
            this.dropBehindColumns(columnIndex);
        }
    }
    /**
     * Set all ancestor options as activated.
     */
    trackAncestorActivatedOptions(startIndex) {
        for (let i = startIndex - 1; i >= 0; i--) {
            if (!this.activatedOptions[i]) {
                this.activatedOptions[i] = this.activatedOptions[i + 1].parent;
            }
        }
    }
    dropBehindActivatedOptions(lastReserveIndex) {
        this.activatedOptions = this.activatedOptions.splice(0, lastReserveIndex + 1);
    }
    dropBehindColumns(lastReserveIndex) {
        if (lastReserveIndex < this.columns.length - 1) {
            this.columns = this.columns.slice(0, lastReserveIndex + 1);
        }
    }
    /**
     * Load children of an option asynchronously.
     */
    loadChildren(option, columnIndex, success, failure) {
        const loadFn = this.cascaderComponent.tdsLoadData;
        if (loadFn) {
            // If there isn't any option in columns.
            this.$loading.next(columnIndex < 0);
            if (typeof option === 'object') {
                option.loading = true;
            }
            loadFn(option, columnIndex).then(() => {
                option.loading = false;
                if (option.children) {
                    this.setColumnData(option.children, columnIndex + 1, option);
                }
                if (success) {
                    success();
                }
                this.$loading.next(false);
                this.$redraw.next();
            }, () => {
                option.loading = false;
                option.isLeaf = true;
                if (failure) {
                    failure();
                }
                this.$redraw.next();
            });
        }
    }
    isLoaded(index) {
        return this.columns[index] && this.columns[index].length > 0;
    }
    /**
     * Find a option that has a given value in a given column.
     */
    findOptionWithValue(columnIndex, value) {
        const targetColumn = this.columns[columnIndex];
        if (targetColumn) {
            const v = typeof value === 'object' ? this.getOptionValue(value) : value;
            return targetColumn.find(o => v === this.getOptionValue(o));
        }
        return null;
    }
    prepareEmitValue() {
        this.values = this.selectedOptions.map(o => this.getOptionValue(o));
    }
}
TDSCascaderService.ɵfac = function TDSCascaderService_Factory(t) { return new (t || TDSCascaderService)(); };
TDSCascaderService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TDSCascaderService, factory: TDSCascaderService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCascaderService, [{
        type: Injectable
    }], null, null); })();

const _c0 = ["selectContainer"];
const _c1 = ["input"];
const _c2 = ["menu"];
function TDSCascaderComponent_ng_container_3_div_7_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r10 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ctx_r10.labelRenderText, " ");
} }
function TDSCascaderComponent_ng_container_3_div_7_ng_template_2_ng_template_0_Template(rf, ctx) { }
function TDSCascaderComponent_ng_container_3_div_7_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, TDSCascaderComponent_ng_container_3_div_7_ng_template_2_ng_template_0_Template, 0, 0, "ng-template", 17);
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r12.tdsLabelRender)("ngTemplateOutletContext", ctx_r12.labelRenderContext);
} }
function TDSCascaderComponent_ng_container_3_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 14);
    i0.ɵɵtemplate(1, TDSCascaderComponent_ng_container_3_div_7_ng_container_1_Template, 2, 1, "ng-container", 15);
    i0.ɵɵtemplate(2, TDSCascaderComponent_ng_container_3_div_7_ng_template_2_Template, 1, 2, "ng-template", null, 16, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r11 = i0.ɵɵreference(3);
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("title", ctx_r6.labelRenderText);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r6.isLabelRenderTemplate)("ngIfElse", _r11);
} }
const _c3 = function (a0, a1) { return { "invisible": a0, "visible": a1 }; };
function TDSCascaderComponent_ng_container_3_div_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 18)(1, "div", 19);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMap(i0.ɵɵpureFunction2(3, _c3, ctx_r7.inputValue, !ctx_r7.inputValue));
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", ctx_r7.showPlaceholder ? ctx_r7.tdsPlaceHolder || ctx_r7.locale.placeholder : null, " ");
} }
function TDSCascaderComponent_ng_container_3_div_9_Template(rf, ctx) { if (rf & 1) {
    const _r15 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 20)(1, "i", 21);
    i0.ɵɵlistener("click", function TDSCascaderComponent_ng_container_3_div_9_Template_i_click_1_listener($event) { i0.ɵɵrestoreView(_r15); const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.clearSelection($event); });
    i0.ɵɵelementEnd()();
} }
function TDSCascaderComponent_ng_container_3_div_10_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "span");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r18 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(ctx_r18.tdsSuffixIcon);
} }
function TDSCascaderComponent_ng_container_3_div_10_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, TDSCascaderComponent_ng_container_3_div_10_ng_container_1_ng_container_1_Template, 2, 2, "ng-container", 23);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r16 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r16.tdsSuffixIcon);
} }
function TDSCascaderComponent_ng_container_3_div_10_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵelement(1, "tds-spinner", 24);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("color", "primary");
} }
function TDSCascaderComponent_ng_container_3_div_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 22);
    i0.ɵɵtemplate(1, TDSCascaderComponent_ng_container_3_div_10_ng_container_1_Template, 2, 1, "ng-container", 2);
    i0.ɵɵtemplate(2, TDSCascaderComponent_ng_container_3_div_10_span_2_Template, 2, 1, "span", 2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext(2);
    i0.ɵɵclassMap(ctx_r9.tdsClassArrow);
    i0.ɵɵclassProp("tds-select-arrow-loading", ctx_r9.isLoading);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r9.isLoading);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r9.isLoading);
} }
const _c4 = function (a0) { return { "opacity-0 w-0 h-0": a0 }; };
const _c5 = function (a0, a1) { return { "opacity-0 w-0 h-0": a0, "w-full h-full": a1 }; };
function TDSCascaderComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r20 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "div", 4)(2, "div", 5, 6)(4, "div", 7)(5, "input", 8, 9);
    i0.ɵɵlistener("ngModelChange", function TDSCascaderComponent_ng_container_3_Template_input_ngModelChange_5_listener($event) { i0.ɵɵrestoreView(_r20); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.inputValue = $event; })("blur", function TDSCascaderComponent_ng_container_3_Template_input_blur_5_listener() { i0.ɵɵrestoreView(_r20); const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.handleInputBlur(); })("focus", function TDSCascaderComponent_ng_container_3_Template_input_focus_5_listener() { i0.ɵɵrestoreView(_r20); const ctx_r22 = i0.ɵɵnextContext(); return ctx_r22.handleInputFocus(); })("change", function TDSCascaderComponent_ng_container_3_Template_input_change_5_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵelementEnd()();
    i0.ɵɵtemplate(7, TDSCascaderComponent_ng_container_3_div_7_Template, 4, 3, "div", 10);
    i0.ɵɵtemplate(8, TDSCascaderComponent_ng_container_3_div_8_Template, 3, 6, "div", 11);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(9, TDSCascaderComponent_ng_container_3_div_9_Template, 2, 0, "div", 12);
    i0.ɵɵtemplate(10, TDSCascaderComponent_ng_container_3_div_10_Template, 3, 6, "div", 13);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(ctx_r2.tdsClassContainer);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(14, _c4, !ctx_r2.tdsShowSearch));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(16, _c5, !ctx_r2.tdsShowSearch, !ctx_r2.tdsShowSearch))("readonly", !ctx_r2.tdsShowSearch)("disabled", ctx_r2.tdsDisabled)("ngModel", ctx_r2.inputValue);
    i0.ɵɵattribute("autoComplete", "off")("expanded", ctx_r2.menuVisible)("autofocus", ctx_r2.tdsAutoFocus ? "autofocus" : null);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r2.showLabelRender);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r2.showLabelRender);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.clearIconVisible);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.tdsShowArrow);
} }
function TDSCascaderComponent_ng_template_5_ul_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "ul", 30)(1, "li", 31);
    i0.ɵɵelement(2, "tds-embed-empty", 32);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r25 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("width", ctx_r25.dropdownWidthStyle)("height", ctx_r25.dropdownHeightStyle);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("componentName", "cascader")("specificContent", ctx_r25.tdsNotFoundContent);
} }
const _c6 = function (a0, a1, a2, a3, a4, a5, a6) { return { "bg-neutral-3-50 dark:bg-d-neutral-3-300": a0, "cursor-pointer": a1, " cursor-not-allowed": a2, "px-1.5": a3, "px-2": a4, "px-2.5": a5, "px-3": a6 }; };
function TDSCascaderComponent_ng_template_5_ng_template_4_ul_0_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r34 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "li", 36);
    i0.ɵɵlistener("mouseenter", function TDSCascaderComponent_ng_template_5_ng_template_4_ul_0_li_1_Template_li_mouseenter_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r34); const option_r32 = restoredCtx.$implicit; const i_r30 = i0.ɵɵnextContext().index; const ctx_r33 = i0.ɵɵnextContext(3); return ctx_r33.onOptionMouseEnter(option_r32, i_r30, $event); })("mouseleave", function TDSCascaderComponent_ng_template_5_ng_template_4_ul_0_li_1_Template_li_mouseleave_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r34); const option_r32 = restoredCtx.$implicit; const i_r30 = i0.ɵɵnextContext().index; const ctx_r36 = i0.ɵɵnextContext(3); return ctx_r36.onOptionMouseLeave(option_r32, i_r30, $event); })("click", function TDSCascaderComponent_ng_template_5_ng_template_4_ul_0_li_1_Template_li_click_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r34); const option_r32 = restoredCtx.$implicit; const i_r30 = i0.ɵɵnextContext().index; const ctx_r38 = i0.ɵɵnextContext(3); return ctx_r38.onOptionClick(option_r32, i_r30, $event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r32 = ctx.$implicit;
    const i_r30 = i0.ɵɵnextContext().index;
    const ctx_r31 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("expandIcon", ctx_r31.tdsExpandIcon)("columnIndex", i_r30)("tdsLabelProperty", ctx_r31.tdsLabelProperty)("optionTemplate", ctx_r31.tdsOptionRender)("activated", ctx_r31.isOptionActivated(option_r32, i_r30))("highlightText", ctx_r31.inSearchingMode ? ctx_r31.inputValue : "")("option", option_r32)("dir", ctx_r31.dir)("ngClass", i0.ɵɵpureFunction7(9, _c6, ctx_r31.isOptionActivated(option_r32, i_r30), !option_r32.disabled, option_r32.disabled, ctx_r31.tdsSize == "sm", ctx_r31.tdsSize == "md", ctx_r31.tdsSize == "lg", ctx_r31.tdsSize == "xl"));
} }
function TDSCascaderComponent_ng_template_5_ng_template_4_ul_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "ul", 34);
    i0.ɵɵtemplate(1, TDSCascaderComponent_ng_template_5_ng_template_4_ul_0_li_1_Template, 1, 17, "li", 35);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const options_r29 = ctx.$implicit;
    const i_r30 = ctx.index;
    const ctx_r28 = i0.ɵɵnextContext(3);
    i0.ɵɵstyleProp("height", ctx_r28.dropdownHeightStyle)("width", ctx_r28.dropdownWidthStyle);
    i0.ɵɵclassProp("border-l", i_r30 > 0)("border-neutral-200", i_r30 > 0)("dark:border-d-neutral-200", i_r30 > 0);
    i0.ɵɵproperty("ngClass", ctx_r28.menuColumnCls);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", options_r29);
} }
function TDSCascaderComponent_ng_template_5_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, TDSCascaderComponent_ng_template_5_ng_template_4_ul_0_Template, 2, 12, "ul", 33);
} if (rf & 2) {
    const ctx_r27 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngForOf", ctx_r27.cascaderService.columns);
} }
function TDSCascaderComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    const _r42 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 25);
    i0.ɵɵlistener("mouseleave", function TDSCascaderComponent_ng_template_5_Template_div_mouseleave_0_listener($event) { i0.ɵɵrestoreView(_r42); const ctx_r41 = i0.ɵɵnextContext(); return ctx_r41.onTriggerMouseLeave($event); });
    i0.ɵɵelementStart(1, "div", 26, 27);
    i0.ɵɵtemplate(3, TDSCascaderComponent_ng_template_5_ul_3_Template, 3, 6, "ul", 28);
    i0.ɵɵtemplate(4, TDSCascaderComponent_ng_template_5_ng_template_4_Template, 1, 1, "ng-template", null, 29, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const _r26 = i0.ɵɵreference(5);
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("tds-cascader-dropdown-rtl", ctx_r3.dir === "rtl");
    i0.ɵɵproperty("@slideMotion", "enter")("@.disabled", ctx_r3.noAnimation == null ? null : ctx_r3.noAnimation.noAnimation)("noAnimation", ctx_r3.noAnimation == null ? null : ctx_r3.noAnimation.noAnimation);
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("tds-cascader-rtl", ctx_r3.dir === "rtl")("tds-cascader-menus-hidden", !ctx_r3.menuVisible)("tds-cascader-menu-empty", ctx_r3.shouldShowEmpty);
    i0.ɵɵproperty("ngClass", ctx_r3.menuCls)("ngStyle", ctx_r3.tdsMenuStyle);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.shouldShowEmpty)("ngIfElse", _r26);
} }
const _c7 = ["*"];
const TDS_CONFIG_MODULE_NAME = 'cascader';
const defaultDisplayRender = (labels) => labels.join(' / ');
class TDSCascaderComponent {
    constructor(cascaderService, tdsConfigService, ngZone, cdr, i18nService, elementRef, renderer, directionality, noAnimation) {
        this.cascaderService = cascaderService;
        this.tdsConfigService = tdsConfigService;
        this.ngZone = ngZone;
        this.cdr = cdr;
        this.i18nService = i18nService;
        this.directionality = directionality;
        this.noAnimation = noAnimation;
        this._tdsModuleName = TDS_CONFIG_MODULE_NAME;
        this.tdsOptionRender = null;
        this.tdsShowInput = true;
        this.tdsShowArrow = true;
        this.tdsAllowClear = true;
        this.tdsAutoFocus = false;
        this.tdsChangeOnSelect = false;
        this.tdsDisabled = false;
        this.tdsExpandTrigger = 'click';
        this.tdsValueProperty = 'value';
        this.tdsLabelRender = null;
        this.tdsLabelProperty = 'label';
        this.tdsSize = 'md';
        this.tdsBackdrop = false;
        this.tdsShowSearch = false;
        this.tdsPlaceHolder = '';
        this.tdsMenuStyle = null;
        this.tdsMouseEnterDelay = 150; // ms
        this.tdsMouseLeaveDelay = 150; // ms
        this.tdsTriggerAction = ['click'];
        // TODO: RTL
        this.tdsSuffixIcon = 'tdsi-arrow-down-line';
        this.tdsExpandIcon = '';
        this.tdsVisibleChange = new EventEmitter();
        this.tdsSelectionChange = new EventEmitter();
        this.tdsSelect = new EventEmitter();
        this.tdsClear = new EventEmitter();
        /**
         * If the dropdown should show the empty content.
         * `true` if there's no options.
         */
        this.shouldShowEmpty = false;
        this.menuVisible = false;
        this.isLoading = false;
        this.labelRenderContext = {};
        this.onChange = Function.prototype;
        this.onTouched = Function.prototype;
        this.positions = [...DEFAULT_CASCADER_POSITIONS];
        this.dropdownHeightStyle = '';
        this.isFocused = false;
        this.dir = 'ltr';
        this.tdsClassContainer = "";
        this.tdsClassArrow = '';
        this.destroy$ = new Subject();
        this.inputString = '';
        this.isOpening = false;
        this.delayMenuTimer = null;
        this.delaySelectTimer = null;
        this.el = elementRef.nativeElement;
        this.cascaderService.withComponent(this);
        renderer.addClass(elementRef.nativeElement, 'tds-select');
        renderer.addClass(elementRef.nativeElement, 'tds-cascader');
    }
    get tdsOptions() {
        return this.cascaderService.tdsOptions;
    }
    set tdsOptions(options) {
        this.cascaderService.withOptions(options);
    }
    get inSearchingMode() {
        return this.cascaderService.inSearchingMode;
    }
    set inputValue(inputValue) {
        this.inputString = inputValue;
        this.toggleSearchingMode(!!inputValue);
    }
    get inputValue() {
        return this.inputString;
    }
    get menuCls() {
        return { [`${this.tdsMenuClassName}`]: !!this.tdsMenuClassName };
    }
    get menuColumnCls() {
        return { [`${this.tdsColumnClassName}`]: !!this.tdsColumnClassName };
    }
    get hasInput() {
        return !!this.inputValue;
    }
    get hasValue() {
        return this.cascaderService.values && this.cascaderService.values.length > 0;
    }
    get showLabelRender() {
        return this.hasValue;
    }
    get showPlaceholder() {
        return !(this.hasInput || this.hasValue);
    }
    get clearIconVisible() {
        return this.tdsAllowClear && !this.tdsDisabled && (this.hasValue || this.hasInput);
    }
    get isLabelRenderTemplate() {
        return !!this.tdsLabelRender;
    }
    ngOnInit() {
        const srv = this.cascaderService;
        srv.$redraw.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.updateClassCss();
            // These operations would not mutate data.
            this.checkChildren();
            this.setDisplayLabel();
            this.reposition();
            this.setDropdownStyles();
            this.cdr.markForCheck();
        });
        srv.$loading.pipe(takeUntil(this.destroy$)).subscribe(loading => {
            this.isLoading = loading;
        });
        srv.$optionSelected.pipe(takeUntil(this.destroy$)).subscribe(data => {
            if (!data) {
                this.onChange([]);
                this.tdsSelect.emit(null);
                this.tdsSelectionChange.emit([]);
            }
            else {
                const { option, index } = data;
                const shouldClose = option.isLeaf || (this.tdsChangeOnSelect && this.tdsExpandTrigger === 'hover');
                if (shouldClose) {
                    this.delaySetMenuVisible(false);
                }
                this.onChange(this.cascaderService.values);
                this.tdsSelectionChange.emit(this.cascaderService.selectedOptions);
                this.tdsSelect.emit({ option, index });
                this.cdr.markForCheck();
            }
        });
        srv.$quitSearching.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.inputString = '';
            this.dropdownWidthStyle = '';
        });
        this.i18nService.localeChange.pipe(startWith(), takeUntil(this.destroy$)).subscribe(() => {
            this.setLocale();
        });
        this.tdsConfigService
            .getConfigChangeEventForComponent(TDS_CONFIG_MODULE_NAME)
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => {
            this.cdr.markForCheck();
        });
        this.dir = this.directionality.value;
        this.directionality.change.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.dir = this.directionality.value;
            srv.$redraw.next();
        });
        this.setupKeydownListener();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.clearDelayMenuTimer();
        this.clearDelaySelectTimer();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    writeValue(value) {
        this.cascaderService.values = toArray(value);
        this.cascaderService.syncOptions(true);
    }
    delaySetMenuVisible(visible, delay = 100, setOpening = false) {
        this.clearDelayMenuTimer();
        if (delay) {
            if (visible && setOpening) {
                this.isOpening = true;
            }
            this.delayMenuTimer = setTimeout(() => {
                this.setMenuVisible(visible);
                this.cdr.detectChanges();
                this.clearDelayMenuTimer();
                if (visible) {
                    setTimeout(() => {
                        this.isOpening = false;
                    }, 100);
                }
            }, delay);
        }
        else {
            this.setMenuVisible(visible);
        }
    }
    setMenuVisible(visible) {
        if (this.tdsDisabled || this.menuVisible === visible) {
            return;
        }
        if (visible) {
            this.cascaderService.syncOptions();
            this.scrollToActivatedOptions();
        }
        if (!visible) {
            this.inputValue = '';
        }
        this.menuVisible = visible;
        this.tdsVisibleChange.emit(visible);
        this.updateClassCss();
        this.cdr.detectChanges();
    }
    clearDelayMenuTimer() {
        if (this.delayMenuTimer) {
            clearTimeout(this.delayMenuTimer);
            this.delayMenuTimer = null;
        }
    }
    clearSelection(event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        this.labelRenderText = '';
        this.labelRenderContext = {};
        this.inputValue = '';
        this.setMenuVisible(false);
        this.cascaderService.clear();
        this.tdsClear.emit();
    }
    getSubmitValue() {
        return this.cascaderService.selectedOptions.map(o => this.cascaderService.getOptionValue(o));
    }
    focus() {
        if (!this.isFocused) {
            (this.input ? this.input.nativeElement : this.el).focus();
            this.isFocused = true;
        }
    }
    blur() {
        if (this.isFocused) {
            (this.input ? this.input.nativeElement : this.el).blur();
            this.isFocused = false;
        }
    }
    handleInputBlur() {
        this.menuVisible ? this.focus() : this.blur();
    }
    handleInputFocus() {
        this.focus();
    }
    onTriggerClick() {
        if (this.tdsDisabled) {
            return;
        }
        if (this.tdsShowSearch) {
            this.focus();
        }
        if (this.isActionTrigger('click')) {
            this.delaySetMenuVisible(!this.menuVisible, 100);
        }
        this.onTouched();
    }
    onTriggerMouseEnter() {
        if (this.tdsDisabled || !this.isActionTrigger('hover')) {
            return;
        }
        this.delaySetMenuVisible(true, this.tdsMouseEnterDelay, true);
    }
    onTriggerMouseLeave(event) {
        if (this.tdsDisabled || !this.menuVisible || this.isOpening || !this.isActionTrigger('hover')) {
            event.preventDefault();
            return;
        }
        const mouseTarget = event.relatedTarget;
        const hostEl = this.el;
        const menuEl = this.menu && this.menu.nativeElement;
        if (hostEl.contains(mouseTarget) || (menuEl && menuEl.contains(mouseTarget))) {
            return;
        }
        this.delaySetMenuVisible(false, this.tdsMouseLeaveDelay);
    }
    onOptionMouseEnter(option, columnIndex, event) {
        event.preventDefault();
        if (this.tdsExpandTrigger === 'hover') {
            if (!option.isLeaf) {
                this.delaySetOptionActivated(option, columnIndex, false);
            }
            else {
                this.cascaderService.setOptionDeactivatedSinceColumn(columnIndex);
            }
        }
    }
    onOptionMouseLeave(option, _columnIndex, event) {
        event.preventDefault();
        if (this.tdsExpandTrigger === 'hover' && !option.isLeaf) {
            this.clearDelaySelectTimer();
        }
    }
    onOptionClick(option, columnIndex, event) {
        if (event) {
            event.preventDefault();
        }
        if (option && option.disabled) {
            return;
        }
        this.el.focus();
        this.inSearchingMode
            ? this.cascaderService.setSearchOptionSelected(option)
            : this.cascaderService.setOptionActivated(option, columnIndex, true);
    }
    onClickOutside(event) {
        if (!this.el.contains(event.target)) {
            this.closeMenu();
        }
    }
    isActionTrigger(action) {
        return typeof this.tdsTriggerAction === 'string'
            ? this.tdsTriggerAction === action
            : this.tdsTriggerAction.indexOf(action) !== -1;
    }
    onEnter() {
        const columnIndex = Math.max(this.cascaderService.activatedOptions.length - 1, 0);
        const option = this.cascaderService.activatedOptions[columnIndex];
        if (option && !option.disabled) {
            this.inSearchingMode
                ? this.cascaderService.setSearchOptionSelected(option)
                : this.cascaderService.setOptionActivated(option, columnIndex, true);
        }
    }
    moveUpOrDown(isUp) {
        const columnIndex = Math.max(this.cascaderService.activatedOptions.length - 1, 0);
        const activeOption = this.cascaderService.activatedOptions[columnIndex];
        const options = this.cascaderService.columns[columnIndex] || [];
        const length = options.length;
        let nextIndex = -1;
        if (!activeOption) {
            // Not selected options in this column
            nextIndex = isUp ? length : -1;
        }
        else {
            nextIndex = options.indexOf(activeOption);
        }
        while (true) {
            nextIndex = isUp ? nextIndex - 1 : nextIndex + 1;
            if (nextIndex < 0 || nextIndex >= length) {
                break;
            }
            const nextOption = options[nextIndex];
            if (!nextOption || nextOption.disabled) {
                continue;
            }
            this.cascaderService.setOptionActivated(nextOption, columnIndex);
            break;
        }
    }
    moveLeft() {
        const options = this.cascaderService.activatedOptions;
        if (options.length) {
            options.pop(); // Remove the last one
        }
    }
    moveRight() {
        const length = this.cascaderService.activatedOptions.length;
        const options = this.cascaderService.columns[length];
        if (options && options.length) {
            const nextOpt = options.find(o => !o.disabled);
            if (nextOpt) {
                this.cascaderService.setOptionActivated(nextOpt, length);
            }
        }
    }
    clearDelaySelectTimer() {
        if (this.delaySelectTimer) {
            clearTimeout(this.delaySelectTimer);
            this.delaySelectTimer = null;
        }
    }
    delaySetOptionActivated(option, columnIndex, performSelect) {
        this.clearDelaySelectTimer();
        this.delaySelectTimer = setTimeout(() => {
            this.cascaderService.setOptionActivated(option, columnIndex, performSelect);
            this.delaySelectTimer = null;
        }, 150);
    }
    toggleSearchingMode(toSearching) {
        if (this.inSearchingMode !== toSearching) {
            this.cascaderService.toggleSearchingMode(toSearching);
        }
        if (this.inSearchingMode) {
            this.cascaderService.prepareSearchOptions(this.inputValue);
        }
    }
    isOptionActivated(option, index) {
        const activeOpt = this.cascaderService.activatedOptions[index];
        return activeOpt === option;
    }
    setDisabledState(isDisabled) {
        if (isDisabled) {
            this.closeMenu();
        }
        this.tdsDisabled = isDisabled;
    }
    closeMenu() {
        this.blur();
        this.clearDelayMenuTimer();
        this.setMenuVisible(false);
    }
    /**
     * Reposition the cascader panel. When a menu opens, the cascader expands
     * and may exceed the boundary of browser's window.
     */
    reposition() {
        if (this.overlay && this.overlay.overlayRef && this.menuVisible) {
            Promise.resolve().then(() => {
                this.overlay.overlayRef.updatePosition();
            });
        }
    }
    /**
     * When a cascader options is changed, a child needs to know that it should re-render.
     */
    checkChildren() {
        if (this.cascaderItems) {
            this.cascaderItems.forEach(item => item.markForCheck());
        }
    }
    setDisplayLabel() {
        const selectedOptions = this.cascaderService.selectedOptions;
        const labels = selectedOptions.map(o => this.cascaderService.getOptionLabel(o));
        if (this.isLabelRenderTemplate) {
            this.labelRenderContext = { labels, selectedOptions };
        }
        else {
            this.labelRenderText = defaultDisplayRender.call(this, labels);
        }
    }
    setDropdownStyles() {
        const firstColumn = this.cascaderService.columns[0];
        this.shouldShowEmpty =
            (this.inSearchingMode && (!firstColumn || !firstColumn.length)) || // Should show empty when there's no searching result
                (!(this.tdsOptions && this.tdsOptions.length) && !this.tdsLoadData); // Should show when there's no options and developer does not use tdsLoadData
        this.dropdownHeightStyle = this.shouldShowEmpty ? 'auto' : '';
        if (this.input) {
            this.dropdownWidthStyle =
                this.inSearchingMode || this.shouldShowEmpty ? `${this.selectContainer.nativeElement.offsetWidth}px` : '';
        }
    }
    setLocale() {
        this.locale = this.i18nService.getLocaleData('global');
        this.cdr.markForCheck();
    }
    scrollToActivatedOptions() {
        // The `scrollIntoView` is a native DOM API, which doesn't require Angular to run
        // a change detection when a promise microtask is resolved.
        this.ngZone.runOutsideAngular(() => {
            Promise.resolve().then(() => {
                // scroll only until option menu view is ready
                this.cascaderItems
                    .toArray()
                    .filter(e => e.activated)
                    .forEach(e => {
                    e.nativeElement.scrollIntoView({ block: 'start', inline: 'nearest' });
                });
            });
        });
    }
    setupKeydownListener() {
        this.ngZone.runOutsideAngular(() => {
            fromEvent(this.el, 'keydown')
                .pipe(takeUntil(this.destroy$))
                .subscribe(event => {
                const keyCode = event.keyCode;
                if (keyCode !== DOWN_ARROW &&
                    keyCode !== UP_ARROW &&
                    keyCode !== LEFT_ARROW &&
                    keyCode !== RIGHT_ARROW &&
                    keyCode !== ENTER &&
                    keyCode !== BACKSPACE &&
                    keyCode !== ESCAPE) {
                    return;
                }
                // Press any keys above to reopen menu.
                if (!this.menuVisible && keyCode !== BACKSPACE && keyCode !== ESCAPE) {
                    // The `setMenuVisible` runs `detectChanges()`, so we don't need to run `markForCheck()` additionally.
                    return this.ngZone.run(() => this.setMenuVisible(true));
                }
                // Make these keys work as default in searching mode.
                if (this.inSearchingMode && (keyCode === BACKSPACE || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW)) {
                    return;
                }
                if (!this.menuVisible) {
                    return;
                }
                event.preventDefault();
                this.ngZone.run(() => {
                    // Interact with the component.
                    if (keyCode === DOWN_ARROW) {
                        this.moveUpOrDown(false);
                    }
                    else if (keyCode === UP_ARROW) {
                        this.moveUpOrDown(true);
                    }
                    else if (keyCode === LEFT_ARROW) {
                        this.moveLeft();
                    }
                    else if (keyCode === RIGHT_ARROW) {
                        this.moveRight();
                    }
                    else if (keyCode === ENTER) {
                        this.onEnter();
                    }
                    // `@HostListener`s run `markForCheck()` internally before calling the actual handler so
                    // we call `markForCheck()` to be backwards-compatible.
                    this.cdr.markForCheck();
                });
            });
        });
    }
    //buildCss
    updateClassCss() {
        this.tdsClassContainer = this.getCssContainer();
        this.tdsClassArrow = this.getCssArrow();
    }
    getCssBySize() {
        let result = '';
        switch (this.tdsSize) {
            case 'sm':
                result = " py-1  pl-2.5 ";
                break;
            case 'md':
                result = " py-1.5  pl-3 ";
                break;
            case 'lg':
                result = " py-2  pl-3.5 ";
                break;
            case 'xl':
                result = " py-2.5 pl-4 ";
                break;
            default:
                result = ' py-1.5  pl-3 ';
        }
        return result;
    }
    getCssArrow() {
        let result = 'text-neutral-1-900 dark:text-d-neutral-1-900 text-base leading-4 flex items-center justify-center ';
        switch (this.tdsSize) {
            case 'sm':
                result += " px-1.5 ";
                break;
            case 'md':
                result += " px-2.5 ";
                break;
            case 'lg':
                result += " px-3 ";
                break;
            case 'xl':
                result += " px-3.5 ";
                break;
            default:
                result += ' px-2.5 ';
        }
        return result;
    }
    getCssContainer() {
        let result = 'dark:bg-d-neutral-3-50 bg-white border rounded dark:group-hover:bg-d-neutral-3-50 group-hover:bg-neutral-3-50';
        if (!this.menuVisible) {
            result += " dark:border-d-neutral-2-200 border-neutral-2-200";
        }
        else {
            result += ' outline-none ring-opacity-20 ring ring-primary-1 border-primary-1';
        }
        result += this.tdsDisabled ? " cursor-not-allowed " : " cursor-pointer ";
        result += this.getCssBySize();
        return result;
    }
}
TDSCascaderComponent.ɵfac = function TDSCascaderComponent_Factory(t) { return new (t || TDSCascaderComponent)(i0.ɵɵdirectiveInject(TDSCascaderService), i0.ɵɵdirectiveInject(i2$1.TDSConfigService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3$1.TDSI18nService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i4$1.Directionality, 8), i0.ɵɵdirectiveInject(i5.TDSNoAnimationDirective, 9)); };
TDSCascaderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCascaderComponent, selectors: [["tds-cascader"], ["", "tds-cascader", ""]], viewQuery: function TDSCascaderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 5);
        i0.ɵɵviewQuery(_c2, 5);
        i0.ɵɵviewQuery(CdkConnectedOverlay, 5);
        i0.ɵɵviewQuery(TDSCascaderOptionComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.selectContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menu = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overlay = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cascaderItems = _t);
    } }, hostAttrs: [1, "group"], hostVars: 17, hostBindings: function TDSCascaderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("click", function TDSCascaderComponent_click_HostBindingHandler() { return ctx.onTriggerClick(); })("mouseenter", function TDSCascaderComponent_mouseenter_HostBindingHandler() { return ctx.onTriggerMouseEnter(); })("mouseleave", function TDSCascaderComponent_mouseleave_HostBindingHandler($event) { return ctx.onTriggerMouseLeave($event); });
    } if (rf & 2) {
        i0.ɵɵattribute("tabIndex", "0");
        i0.ɵɵclassProp("tds-select-allow-clear", ctx.tdsAllowClear)("tds-select-show-arrow", ctx.tdsShowArrow)("tds-select-show-search", !!ctx.tdsShowSearch)("tds-select-disabled", ctx.tdsDisabled)("tds-select-open", ctx.menuVisible)("tds-select-focused", ctx.isFocused)("tds-select-single", true)("tds-select-rtl", ctx.dir === "rtl");
    } }, inputs: { tdsOptionRender: "tdsOptionRender", tdsShowInput: "tdsShowInput", tdsShowArrow: "tdsShowArrow", tdsAllowClear: "tdsAllowClear", tdsAutoFocus: "tdsAutoFocus", tdsChangeOnSelect: "tdsChangeOnSelect", tdsDisabled: "tdsDisabled", tdsColumnClassName: "tdsColumnClassName", tdsExpandTrigger: "tdsExpandTrigger", tdsValueProperty: "tdsValueProperty", tdsLabelRender: "tdsLabelRender", tdsLabelProperty: "tdsLabelProperty", tdsNotFoundContent: "tdsNotFoundContent", tdsSize: "tdsSize", tdsBackdrop: "tdsBackdrop", tdsShowSearch: "tdsShowSearch", tdsPlaceHolder: "tdsPlaceHolder", tdsMenuClassName: "tdsMenuClassName", tdsMenuStyle: "tdsMenuStyle", tdsMouseEnterDelay: "tdsMouseEnterDelay", tdsMouseLeaveDelay: "tdsMouseLeaveDelay", tdsTriggerAction: "tdsTriggerAction", tdsChangeOn: "tdsChangeOn", tdsLoadData: "tdsLoadData", tdsSuffixIcon: "tdsSuffixIcon", tdsExpandIcon: "tdsExpandIcon", tdsOptions: "tdsOptions" }, outputs: { tdsVisibleChange: "tdsVisibleChange", tdsSelectionChange: "tdsSelectionChange", tdsSelect: "tdsSelect", tdsClear: "tdsClear" }, exportAs: ["tdsCascader"], features: [i0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TDSCascaderComponent),
                multi: true
            },
            TDSCascaderService
        ])], ngContentSelectors: _c7, decls: 6, vars: 6, consts: [["cdkOverlayOrigin", ""], ["origin", "cdkOverlayOrigin", "trigger", ""], [4, "ngIf"], ["cdkConnectedOverlay", "", "tdsConnectedOverlay", "", 3, "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayPositions", "cdkConnectedOverlayTransformOriginOn", "cdkConnectedOverlayOpen", "overlayOutsideClick", "detach"], [1, "w-full", "flex", "items-center"], [1, "tds-select-selector", "flex-auto", "relative", "h-5"], ["selectContainer", ""], [1, "tds-select-selection-search", "h-5", 3, "ngClass"], ["type", "search", 1, "tds-select-selection-search-input", "text-body-2", 3, "ngClass", "readonly", "disabled", "ngModel", "ngModelChange", "blur", "focus", "change"], ["input", ""], ["class", "tds-select-selection-item absolute inset-0 truncate text-body-2", 3, "title", 4, "ngIf"], ["class", "tds-select-selection-placeholder absolute inset-0  flex items-center text-body-2 text-neutral-1-400 dark:text-d-neutral-1-400", 3, "class", 4, "ngIf"], ["class", "tds-select-clear flex items-center justify-center pl-2", 4, "ngIf"], ["class", "tds-select-arrow", 3, "class", "tds-select-arrow-loading", 4, "ngIf"], [1, "tds-select-selection-item", "absolute", "inset-0", "truncate", "text-body-2", 3, "title"], [4, "ngIf", "ngIfElse"], ["labelTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "tds-select-selection-placeholder", "absolute", "inset-0", "flex", "items-center", "text-body-2", "text-neutral-1-400", "dark:text-d-neutral-1-400"], [1, "truncate", "w-full"], [1, "tds-select-clear", "flex", "items-center", "justify-center", "pl-2"], [1, "tdsi-close-fill", "text-neutral-1-500", "dark:text-d-neutral-1-500", "text-base", "leading-4", 3, "click"], [1, "tds-select-arrow"], [4, "tdsStringTemplateOutlet"], [1, "h-4", "w-4", 3, "color"], [1, "tds-select-dropdown", "tds-cascader-dropdown", "tds-select-dropdown-placement-bottomLeft", 3, "noAnimation", "mouseleave"], [1, "tds-cascader-menus", "flex", "flex-wrap", "items-stretch", "relative", "mt-1", "bg-white", "dark:bg-d-neutral-3-200", "text-neutral-1-900", "dark:text-d-neutral-1-900", "rounded", "shadow-xl", 3, "ngClass", "ngStyle"], ["menu", ""], ["class", "tds-cascader-menu  py-1 min-w-[176px]", 3, "width", "height", 4, "ngIf", "ngIfElse"], ["hasOptionsTemplate", ""], [1, "tds-cascader-menu", "py-1", "min-w-[176px]"], [1, "tds-cascader-menu-item", "tds-cascader-menu-item-disabled"], [1, "tds-cascader-menu-item-content", 3, "componentName", "specificContent"], ["class", "tds-cascader-menu min-w-[176px]  py-1", "role", "menuitemcheckbox", 3, "ngClass", "height", "width", "border-l", "border-neutral-200", "dark:border-d-neutral-200", 4, "ngFor", "ngForOf"], ["role", "menuitemcheckbox", 1, "tds-cascader-menu", "min-w-[176px]", "py-1", 3, "ngClass"], ["tds-cascader-option", "", "class", "py-1.5  dark:hover:bg-d-neutral-3-300 hover:bg-neutral-3-50 flex items-center justify-between", 3, "expandIcon", "columnIndex", "tdsLabelProperty", "optionTemplate", "activated", "highlightText", "option", "dir", "ngClass", "mouseenter", "mouseleave", "click", 4, "ngFor", "ngForOf"], ["tds-cascader-option", "", 1, "py-1.5", "dark:hover:bg-d-neutral-3-300", "hover:bg-neutral-3-50", "flex", "items-center", "justify-between", 3, "expandIcon", "columnIndex", "tdsLabelProperty", "optionTemplate", "activated", "highlightText", "option", "dir", "ngClass", "mouseenter", "mouseleave", "click"]], template: function TDSCascaderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵtemplate(3, TDSCascaderComponent_ng_container_3_Template, 11, 19, "ng-container", 2);
        i0.ɵɵprojection(4);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(5, TDSCascaderComponent_ng_template_5_Template, 6, 15, "ng-template", 3);
        i0.ɵɵlistener("overlayOutsideClick", function TDSCascaderComponent_Template_ng_template_overlayOutsideClick_5_listener($event) { return ctx.onClickOutside($event); })("detach", function TDSCascaderComponent_Template_ng_template_detach_5_listener() { return ctx.closeMenu(); });
    } if (rf & 2) {
        const _r0 = i0.ɵɵreference(1);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.tdsShowInput);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("cdkConnectedOverlayHasBackdrop", ctx.tdsBackdrop)("cdkConnectedOverlayOrigin", _r0)("cdkConnectedOverlayPositions", ctx.positions)("cdkConnectedOverlayTransformOriginOn", ".tds-cascader-dropdown")("cdkConnectedOverlayOpen", ctx.menuVisible);
    } }, directives: [i6.CdkOverlayOrigin, i7.NgIf, i7.NgClass, i8.DefaultValueAccessor, i8.NgControlStatus, i8.NgModel, i7.NgTemplateOutlet, i3.TDSStringTemplateOutletDirective, i2.TDSProgressSpinnerComponent, i6.CdkConnectedOverlay, i11.TDSConnectedOverlayDirective, i5.TDSNoAnimationDirective, i7.NgStyle, i12.TDSEmbedEmptyComponent, i7.NgForOf, TDSCascaderOptionComponent, i4$1.Dir], encapsulation: 2, data: { animation: [slideMotion] }, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSCascaderComponent.prototype, "tdsShowInput", void 0);
__decorate([
    InputBoolean()
], TDSCascaderComponent.prototype, "tdsShowArrow", void 0);
__decorate([
    InputBoolean()
], TDSCascaderComponent.prototype, "tdsAllowClear", void 0);
__decorate([
    InputBoolean()
], TDSCascaderComponent.prototype, "tdsAutoFocus", void 0);
__decorate([
    InputBoolean()
], TDSCascaderComponent.prototype, "tdsChangeOnSelect", void 0);
__decorate([
    InputBoolean()
], TDSCascaderComponent.prototype, "tdsDisabled", void 0);
__decorate([
    WithConfig()
], TDSCascaderComponent.prototype, "tdsSize", void 0);
__decorate([
    WithConfig()
], TDSCascaderComponent.prototype, "tdsBackdrop", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCascaderComponent, [{
        type: Component,
        args: [{ changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, selector: 'tds-cascader, [tds-cascader]', exportAs: 'tdsCascader', preserveWhitespaces: false, animations: [slideMotion], providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TDSCascaderComponent),
                        multi: true
                    },
                    TDSCascaderService
                ], host: {
                    '[attr.tabIndex]': '"0"',
                    '[class.tds-select-allow-clear]': 'tdsAllowClear',
                    '[class.tds-select-show-arrow]': 'tdsShowArrow',
                    '[class.tds-select-show-search]': '!!tdsShowSearch',
                    '[class.tds-select-disabled]': 'tdsDisabled',
                    '[class.tds-select-open]': 'menuVisible',
                    '[class.tds-select-focused]': 'isFocused',
                    '[class.tds-select-single]': 'true',
                    '[class.tds-select-rtl]': `dir ==='rtl'`,
                    'class': 'group'
                }, template: "<div cdkOverlayOrigin #origin=\"cdkOverlayOrigin\" #trigger>\r\n    <ng-container *ngIf=\"tdsShowInput\">\r\n        <div class=\"w-full flex items-center \" [class]=\"tdsClassContainer\">\r\n            <div #selectContainer class=\"tds-select-selector flex-auto relative h-5\">\r\n                <div class=\"tds-select-selection-search h-5\" [ngClass]=\"{'opacity-0 w-0 h-0': !tdsShowSearch}\">\r\n                    <input #input type=\"search\" class=\"tds-select-selection-search-input text-body-2\"\r\n                        [ngClass]=\"{'opacity-0 w-0 h-0': !tdsShowSearch,'w-full h-full':!tdsShowSearch}\"\r\n                        [attr.autoComplete]=\"'off'\" [attr.expanded]=\"menuVisible\"\r\n                        [attr.autofocus]=\"tdsAutoFocus ? 'autofocus' : null\" [readonly]=\"!tdsShowSearch\"\r\n                        [disabled]=\"tdsDisabled\" [(ngModel)]=\"inputValue\" (blur)=\"handleInputBlur()\"\r\n                        (focus)=\"handleInputFocus()\" (change)=\"$event.stopPropagation()\" />\r\n                </div>\r\n                <div *ngIf=\"showLabelRender\" class=\"tds-select-selection-item absolute inset-0 truncate text-body-2\"\r\n                    [title]=\"labelRenderText\">\r\n                    <ng-container *ngIf=\"!isLabelRenderTemplate; else labelTemplate\">{{ labelRenderText }}\r\n                    </ng-container>\r\n                    <ng-template #labelTemplate>\r\n                        <ng-template [ngTemplateOutlet]=\"tdsLabelRender\" [ngTemplateOutletContext]=\"labelRenderContext\">\r\n                        </ng-template>\r\n                    </ng-template>\r\n                </div>\r\n                <div *ngIf=\"!showLabelRender\"\r\n                    class=\"tds-select-selection-placeholder absolute inset-0  flex items-center text-body-2 text-neutral-1-400 dark:text-d-neutral-1-400\"\r\n                    [class]=\"{'invisible':inputValue,'visible':!inputValue}\">\r\n                    <div class=\"truncate  w-full\">\r\n                        {{ showPlaceholder ? tdsPlaceHolder || locale.placeholder : null }}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"tds-select-clear flex items-center justify-center pl-2\" *ngIf=\"clearIconVisible\">\r\n                <i class=\"tdsi-close-fill text-neutral-1-500 dark:text-d-neutral-1-500 text-base leading-4 \"\r\n                    (click)=\"clearSelection($event)\"></i>\r\n            </div>\r\n            <div class=\"tds-select-arrow\" [class]=\"tdsClassArrow\" [class.tds-select-arrow-loading]=\"isLoading\"\r\n                *ngIf=\"tdsShowArrow\">\r\n                <ng-container *ngIf=\"!isLoading\">\r\n                    <ng-container *tdsStringTemplateOutlet=\"tdsSuffixIcon\">\r\n                        <span [class]=\"tdsSuffixIcon\"></span>\r\n                    </ng-container>\r\n                </ng-container>\r\n                <!--   <ng-container *ngIf=\"!isLoading && menuVisible\">\r\n                    <ng-container *tdsStringTemplateOutlet=\"tdsExpandIcon\">\r\n                        <span [class]=\"tdsExpandIcon\"></span>\r\n                    </ng-container>\r\n                </ng-container> -->\r\n                <span *ngIf=\"isLoading\">\r\n                    <tds-spinner [color]=\"'primary'\" class=\"h-4 w-4\"></tds-spinner>\r\n                </span>\r\n            </div>\r\n        </div>\r\n    </ng-container>\r\n    <ng-content></ng-content>\r\n</div>\r\n<ng-template cdkConnectedOverlay tdsConnectedOverlay [cdkConnectedOverlayHasBackdrop]=\"tdsBackdrop\"\r\n    [cdkConnectedOverlayOrigin]=\"origin\" [cdkConnectedOverlayPositions]=\"positions\"\r\n    [cdkConnectedOverlayTransformOriginOn]=\"'.tds-cascader-dropdown'\" [cdkConnectedOverlayOpen]=\"menuVisible\"\r\n    (overlayOutsideClick)=\"onClickOutside($event)\" (detach)=\"closeMenu()\">\r\n    <div class=\"tds-select-dropdown tds-cascader-dropdown tds-select-dropdown-placement-bottomLeft\"\r\n        [class.tds-cascader-dropdown-rtl]=\"dir === 'rtl'\" [@slideMotion]=\"'enter'\"\r\n        [@.disabled]=\"noAnimation?.noAnimation\" [noAnimation]=\"noAnimation?.noAnimation\"\r\n        (mouseleave)=\"onTriggerMouseLeave($event)\">\r\n        <div #menu\r\n            class=\"tds-cascader-menus flex flex-wrap items-stretch relative mt-1 bg-white dark:bg-d-neutral-3-200 text-neutral-1-900 dark:text-d-neutral-1-900 rounded shadow-xl\"\r\n            [class.tds-cascader-rtl]=\"dir === 'rtl'\" [class.tds-cascader-menus-hidden]=\"!menuVisible\"\r\n            [class.tds-cascader-menu-empty]=\"shouldShowEmpty\" [ngClass]=\"menuCls\" [ngStyle]=\"tdsMenuStyle\">\r\n            <ul *ngIf=\"shouldShowEmpty; else hasOptionsTemplate\" class=\"tds-cascader-menu  py-1 min-w-[176px]\"\r\n                [style.width]=\"dropdownWidthStyle\" [style.height]=\"dropdownHeightStyle\">\r\n                <li class=\"tds-cascader-menu-item tds-cascader-menu-item-disabled\">\r\n                    <tds-embed-empty class=\"tds-cascader-menu-item-content\" [componentName]=\"'cascader'\"\r\n                        [specificContent]=\"tdsNotFoundContent\"></tds-embed-empty>\r\n                </li>\r\n            </ul>\r\n            <ng-template #hasOptionsTemplate>\r\n                <ul *ngFor=\"let options of cascaderService.columns; let i = index\"\r\n                    class=\"tds-cascader-menu min-w-[176px]  py-1\" role=\"menuitemcheckbox\" [ngClass]=\"menuColumnCls\"\r\n                    [style.height]=\"dropdownHeightStyle\" [style.width]=\"dropdownWidthStyle\" [class.border-l]='i > 0'\r\n                    [class.border-neutral-200]='i > 0' [class.dark:border-d-neutral-200]='i > 0'>\r\n                    <li tds-cascader-option *ngFor=\"let option of options\" [expandIcon]=\"tdsExpandIcon\"\r\n                        [columnIndex]=\"i\" [tdsLabelProperty]=\"tdsLabelProperty\" [optionTemplate]=\"tdsOptionRender\"\r\n                        [activated]=\"isOptionActivated(option, i)\" [highlightText]=\"inSearchingMode ? inputValue : ''\"\r\n                        [option]=\"option\" [dir]=\"dir\" (mouseenter)=\"onOptionMouseEnter(option, i, $event)\"\r\n                        (mouseleave)=\"onOptionMouseLeave(option, i, $event)\" (click)=\"onOptionClick(option, i, $event)\"\r\n                        class=\"py-1.5  dark:hover:bg-d-neutral-3-300 hover:bg-neutral-3-50 flex items-center justify-between\"\r\n                        [ngClass]=\"{'bg-neutral-3-50 dark:bg-d-neutral-3-300': isOptionActivated(option, i),\r\n                    'cursor-pointer':!option.disabled,' cursor-not-allowed':option.disabled,\r\n                    'px-1.5':tdsSize == 'sm',\r\n                    'px-2':tdsSize == 'md',\r\n                    'px-2.5':tdsSize == 'lg',\r\n                    'px-3':tdsSize == 'xl'\r\n                \r\n                }\">\r\n                    </li>\r\n                </ul>\r\n            </ng-template>\r\n        </div>\r\n    </div>\r\n</ng-template>" }]
    }], function () { return [{ type: TDSCascaderService }, { type: i2$1.TDSConfigService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i3$1.TDSI18nService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i4$1.Directionality, decorators: [{
                type: Optional
            }] }, { type: i5.TDSNoAnimationDirective, decorators: [{
                type: Host
            }, {
                type: Optional
            }] }]; }, { selectContainer: [{
            type: ViewChild,
            args: ['selectContainer', { static: false }]
        }], input: [{
            type: ViewChild,
            args: ['input', { static: false }]
        }], menu: [{
            type: ViewChild,
            args: ['menu', { static: false }]
        }], overlay: [{
            type: ViewChild,
            args: [CdkConnectedOverlay, { static: false }]
        }], cascaderItems: [{
            type: ViewChildren,
            args: [TDSCascaderOptionComponent]
        }], tdsOptionRender: [{
            type: Input
        }], tdsShowInput: [{
            type: Input
        }], tdsShowArrow: [{
            type: Input
        }], tdsAllowClear: [{
            type: Input
        }], tdsAutoFocus: [{
            type: Input
        }], tdsChangeOnSelect: [{
            type: Input
        }], tdsDisabled: [{
            type: Input
        }], tdsColumnClassName: [{
            type: Input
        }], tdsExpandTrigger: [{
            type: Input
        }], tdsValueProperty: [{
            type: Input
        }], tdsLabelRender: [{
            type: Input
        }], tdsLabelProperty: [{
            type: Input
        }], tdsNotFoundContent: [{
            type: Input
        }], tdsSize: [{
            type: Input
        }], tdsBackdrop: [{
            type: Input
        }], tdsShowSearch: [{
            type: Input
        }], tdsPlaceHolder: [{
            type: Input
        }], tdsMenuClassName: [{
            type: Input
        }], tdsMenuStyle: [{
            type: Input
        }], tdsMouseEnterDelay: [{
            type: Input
        }], tdsMouseLeaveDelay: [{
            type: Input
        }], tdsTriggerAction: [{
            type: Input
        }], tdsChangeOn: [{
            type: Input
        }], tdsLoadData: [{
            type: Input
        }], tdsSuffixIcon: [{
            type: Input
        }], tdsExpandIcon: [{
            type: Input
        }], tdsOptions: [{
            type: Input
        }], tdsVisibleChange: [{
            type: Output
        }], tdsSelectionChange: [{
            type: Output
        }], tdsSelect: [{
            type: Output
        }], tdsClear: [{
            type: Output
        }], onTriggerClick: [{
            type: HostListener,
            args: ['click']
        }], onTriggerMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onTriggerMouseLeave: [{
            type: HostListener,
            args: ['mouseleave', ['$event']]
        }] }); })();

class TDSCascaderModule {
}
TDSCascaderModule.ɵfac = function TDSCascaderModule_Factory(t) { return new (t || TDSCascaderModule)(); };
TDSCascaderModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSCascaderModule });
TDSCascaderModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            BidiModule,
            CommonModule,
            FormsModule,
            OverlayModule,
            TDSOutletModule,
            TDSEmptyModule,
            TDSHighlightModule,
            TDSInputModule,
            TDSNoAnimationModule,
            TDSOverlayModule,
            TDSSpinnerModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCascaderModule, [{
        type: NgModule,
        args: [{
                imports: [
                    BidiModule,
                    CommonModule,
                    FormsModule,
                    OverlayModule,
                    TDSOutletModule,
                    TDSEmptyModule,
                    TDSHighlightModule,
                    TDSInputModule,
                    TDSNoAnimationModule,
                    TDSOverlayModule,
                    TDSSpinnerModule
                ],
                declarations: [TDSCascaderComponent, TDSCascaderOptionComponent],
                exports: [TDSCascaderComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSCascaderModule, { declarations: [TDSCascaderComponent, TDSCascaderOptionComponent], imports: [BidiModule,
        CommonModule,
        FormsModule,
        OverlayModule,
        TDSOutletModule,
        TDSEmptyModule,
        TDSHighlightModule,
        TDSInputModule,
        TDSNoAnimationModule,
        TDSOverlayModule,
        TDSSpinnerModule], exports: [TDSCascaderComponent] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSCascaderComponent, TDSCascaderModule, TDSCascaderOptionComponent, TDSCascaderService, isChildOption, isParentOption, isShowSearchObject };
//# sourceMappingURL=tds-ui-cascader.mjs.map
