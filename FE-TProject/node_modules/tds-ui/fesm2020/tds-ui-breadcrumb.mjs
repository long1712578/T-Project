import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, ViewEncapsulation, Input, TemplateRef, Optional, ViewChild, ContentChildren, NgModule } from '@angular/core';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2 from 'tds-ui/dropdown';
import { TDSDropDownModule } from 'tds-ui/dropdown';
import * as i3 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';
import { __decorate } from 'tslib';
import { Router, ActivatedRoute, NavigationEnd, PRIMARY_OUTLET } from '@angular/router';
import { Subject } from 'rxjs';
import { takeUntil, filter, startWith } from 'rxjs/operators';
import { TDSHelperObject, InputBoolean } from 'tds-ui/shared/utility';
import * as i1$1 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import { OverlayModule } from '@angular/cdk/overlay';
import { TDSOverlayModule } from 'tds-ui/core/overlay';

function TDSBreadCrumbItemComponent_ng_container_0_ng_template_2_Template(rf, ctx) { }
function TDSBreadCrumbItemComponent_ng_container_0_span_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 6);
} }
function TDSBreadCrumbItemComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "span", 3);
    i0.ɵɵtemplate(2, TDSBreadCrumbItemComponent_ng_container_0_ng_template_2_Template, 0, 0, "ng-template", 4);
    i0.ɵɵtemplate(3, TDSBreadCrumbItemComponent_ng_container_0_span_3_Template, 1, 0, "span", 5);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    const _r1 = i0.ɵɵreference(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("tdsDropdownMenu", ctx_r0.overlay);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !!ctx_r0.overlay);
} }
function TDSBreadCrumbItemComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 7);
    i0.ɵɵprojection(1);
    i0.ɵɵelementEnd();
} }
function TDSBreadCrumbItemComponent_span_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "span", 10);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", ctx_r6.separator);
} }
function TDSBreadCrumbItemComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 8);
    i0.ɵɵtemplate(1, TDSBreadCrumbItemComponent_span_3_ng_container_1_Template, 2, 1, "ng-container", 9);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r3.separator);
} }
const _c0$2 = ["*"];
class TDSBreadCrumbItemComponent {
    constructor() {
        this.separator = '/';
        this.active = false;
    }
}
TDSBreadCrumbItemComponent.ɵfac = function TDSBreadCrumbItemComponent_Factory(t) { return new (t || TDSBreadCrumbItemComponent)(); };
TDSBreadCrumbItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSBreadCrumbItemComponent, selectors: [["tds-breadcrumb-item"]], hostAttrs: [1, "text-caption-1", "font-regular", "text-neutral-1-400", "dark:text-d-neutral-1-400", "flex", "items-center", "hover:text-primary-1", "dark:hover:text-primary-1", "cursor-pointer"], hostVars: 2, hostBindings: function TDSBreadCrumbItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("tds-breadcrumitem-active", ctx.active == true);
    } }, inputs: { overlay: "overlay", separator: "separator", active: "active" }, exportAs: ["tdsBreadcrumbItem"], ngContentSelectors: _c0$2, decls: 4, vars: 3, consts: [[4, "ngIf", "ngIfElse"], ["noMenuTpl", ""], ["class", "tds-breadcrumb-separator px-1 flex text-neutral-1-400 dark:text-d-neutral-1-400", 4, "ngIf"], ["tds-dropdown", "", 1, "tds-breadcrumb-overlay-link", "flex", "items-center", 3, "tdsDropdownMenu"], [3, "ngTemplateOutlet"], ["class", "flex items-center tdsi-arrow-down-fill text-base leading-4 px-1", 4, "ngIf"], [1, "flex", "items-center", "tdsi-arrow-down-fill", "text-base", "leading-4", "px-1"], [1, "tds-breadcrumb-link"], [1, "tds-breadcrumb-separator", "px-1", "flex", "text-neutral-1-400", "dark:text-d-neutral-1-400"], [4, "tdsStringTemplateOutlet"], [1, "text-base", "leading-4", 3, "ngClass"]], template: function TDSBreadCrumbItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtemplate(0, TDSBreadCrumbItemComponent_ng_container_0_Template, 4, 3, "ng-container", 0);
        i0.ɵɵtemplate(1, TDSBreadCrumbItemComponent_ng_template_1_Template, 2, 0, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtemplate(3, TDSBreadCrumbItemComponent_span_3_Template, 2, 1, "span", 2);
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(2);
        i0.ɵɵproperty("ngIf", !!ctx.overlay)("ngIfElse", _r1);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.separator);
    } }, directives: [i1.NgIf, i2.TDSDropDownDirective, i1.NgTemplateOutlet, i3.TDSStringTemplateOutletDirective, i1.NgClass], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSBreadCrumbItemComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                selector: 'tds-breadcrumb-item',
                exportAs: 'tdsBreadcrumbItem',
                preserveWhitespaces: false,
                template: `
    <ng-container *ngIf="!!overlay; else noMenuTpl">
      <span class="tds-breadcrumb-overlay-link flex items-center" tds-dropdown [tdsDropdownMenu]="overlay">
        <ng-template [ngTemplateOutlet]="noMenuTpl"></ng-template>
        <span *ngIf="!!overlay" class='flex items-center tdsi-arrow-down-fill text-base leading-4 px-1'></span>
      </span>
    </ng-container>

    <ng-template #noMenuTpl>
      <span class="tds-breadcrumb-link">
        <ng-content></ng-content>
      </span>
    </ng-template>

    <span class="tds-breadcrumb-separator px-1 flex text-neutral-1-400 dark:text-d-neutral-1-400" *ngIf="separator">
      <ng-container *tdsStringTemplateOutlet="separator">
       <span class='text-base leading-4' [ngClass]="separator"></span>
      </ng-container>
    </span>
  `,
                host: {
                    '[class.tds-breadcrumitem-active]': 'active == true',
                    'class': 'text-caption-1 font-regular text-neutral-1-400 dark:text-d-neutral-1-400 flex items-center hover:text-primary-1 dark:hover:text-primary-1 cursor-pointer'
                }
            }]
    }], function () { return []; }, { overlay: [{
            type: Input
        }], separator: [{
            type: Input
        }], active: [{
            type: Input
        }] }); })();

const _c0$1 = ["defaultSeparator"];
function TDSBreadCrumbComponent_ng_container_1_tds_breadcrumb_item_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "tds-breadcrumb-item", 2)(1, "a", 3);
    i0.ɵɵlistener("click", function TDSBreadCrumbComponent_ng_container_1_tds_breadcrumb_item_1_Template_a_click_1_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r5); const breadcrumb_r2 = restoredCtx.$implicit; const ctx_r4 = i0.ɵɵnextContext(2); return ctx_r4.navigate(breadcrumb_r2.url, $event); });
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const breadcrumb_r2 = ctx.$implicit;
    const last_r3 = ctx.last;
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("active", last_r3)("separator", last_r3 ? null : ctx_r1.separator);
    i0.ɵɵadvance(1);
    i0.ɵɵattribute("href", breadcrumb_r2.url, i0.ɵɵsanitizeUrl);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(breadcrumb_r2.label);
} }
function TDSBreadCrumbComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, TDSBreadCrumbComponent_ng_container_1_tds_breadcrumb_item_1_Template, 3, 4, "tds-breadcrumb-item", 1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r0.breadcrumbs);
} }
const _c1 = ["*"];
class TDSBreadCrumbComponent {
    constructor(injector, ngZone, cdr, elementRef, renderer, directionality) {
        this.injector = injector;
        this.ngZone = ngZone;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.directionality = directionality;
        this.autoGenerate = false;
        this.separator = 'tdsi-arrow-right-line';
        this.routeLabel = 'breadcrumb';
        this.routeLabelFn = label => label;
        this.breadcrumbs = [];
        this.dir = 'ltr';
        this.destroy$ = new Subject();
        renderer.addClass(elementRef.nativeElement, 'tds-breadcrumb');
    }
    ngAfterContentInit() {
        if (!this.autoGenerate) {
            if (TDSHelperObject.hasValue(this.listChild) && this.listChild.length > 0) {
                this.listChild.forEach((item, index) => {
                    if (index < this.listChild.length - 1) {
                        item.separator = this.separator ? this.separator : this.defaultSeparator;
                        item.active = false;
                    }
                    else {
                        item.separator = null;
                        item.active = true;
                    }
                });
            }
        }
    }
    ngOnInit() {
        if (this.autoGenerate) {
            this.registerRouterChange();
        }
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.prepareComponentForRtl();
            this.cdr.detectChanges();
        });
        this.dir = this.directionality.value;
        this.prepareComponentForRtl();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    navigate(url, e) {
        e.preventDefault();
        this.ngZone.run(() => this.injector.get(Router).navigateByUrl(url).then()).then();
    }
    registerRouterChange() {
        try {
            const router = this.injector.get(Router);
            const activatedRoute = this.injector.get(ActivatedRoute);
            router.events
                .pipe(filter(e => e instanceof NavigationEnd), takeUntil(this.destroy$), startWith(true) // trigger initial render
            )
                .subscribe(() => {
                this.breadcrumbs = this.getBreadcrumbs(activatedRoute.root);
                this.cdr.markForCheck();
            });
        }
        catch (e) {
            throw new Error(`[TDS] You should import RouterModule if you want to use 'autoGenerate'.`);
        }
    }
    getBreadcrumbs(route, url = '', breadcrumbs = []) {
        const children = route.children;
        // If there's no sub root, then stop the recurse and returns the generated breadcrumbs.
        if (children.length === 0) {
            return breadcrumbs;
        }
        for (const child of children) {
            if (child.outlet === PRIMARY_OUTLET) {
                // Only parse components in primary router-outlet (in another word, router-outlet without a specific name).
                // Parse this layer and generate a breadcrumb item.
                const routeUrl = child.snapshot.url
                    .map(segment => segment.path)
                    .filter(path => path)
                    .join('/');
                // Do not change nextUrl if routeUrl is falsy. This happens when it's a route lazy loading other modules.
                const nextUrl = !!routeUrl ? url + `/${routeUrl}` : url;
                const breadcrumbLabel = this.routeLabelFn(child.snapshot.data[this.routeLabel]);
                // If have data, go to generate a breadcrumb for it.
                if (routeUrl != null && breadcrumbLabel) {
                    const breadcrumb = {
                        label: breadcrumbLabel,
                        params: child.snapshot.params,
                        url: nextUrl
                    };
                    breadcrumbs.push(breadcrumb);
                }
                return this.getBreadcrumbs(child, nextUrl, breadcrumbs);
            }
        }
        return breadcrumbs;
    }
    prepareComponentForRtl() {
        if (this.dir === 'rtl') {
            this.renderer.addClass(this.elementRef.nativeElement, 'tds-breadcrumb-rtl');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'tds-breadcrumb-rtl');
        }
    }
}
TDSBreadCrumbComponent.ɵfac = function TDSBreadCrumbComponent_Factory(t) { return new (t || TDSBreadCrumbComponent)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1$1.Directionality, 8)); };
TDSBreadCrumbComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSBreadCrumbComponent, selectors: [["tds-breadcrumb"]], contentQueries: function TDSBreadCrumbComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, TDSBreadCrumbItemComponent, 4);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.listChild = _t);
    } }, viewQuery: function TDSBreadCrumbComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$1, 5, TemplateRef);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defaultSeparator = _t.first);
    } }, hostAttrs: [1, "flex", "items-center", "w-full"], inputs: { autoGenerate: "autoGenerate", separator: "separator", routeLabel: "routeLabel", routeLabelFn: "routeLabelFn" }, exportAs: ["tdsBreadcrumb"], ngContentSelectors: _c1, decls: 2, vars: 1, consts: [[4, "ngIf"], [3, "active", "separator", 4, "ngFor", "ngForOf"], [3, "active", "separator"], [3, "click"]], template: function TDSBreadCrumbComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵprojection(0);
        i0.ɵɵtemplate(1, TDSBreadCrumbComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.autoGenerate && ctx.breadcrumbs.length);
    } }, directives: [i1.NgIf, i1.NgForOf, TDSBreadCrumbItemComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSBreadCrumbComponent.prototype, "autoGenerate", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSBreadCrumbComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                selector: 'tds-breadcrumb',
                exportAs: 'tdsBreadcrumb',
                preserveWhitespaces: false,
                template: `
    <ng-content></ng-content>
    <ng-container *ngIf="autoGenerate && breadcrumbs.length">
      <tds-breadcrumb-item *ngFor="let breadcrumb of breadcrumbs;let last = last" [active]="last" [separator]='last ? null : separator'>
        <a [attr.href]="breadcrumb.url" (click)="navigate(breadcrumb.url, $event)">{{ breadcrumb.label }}</a>
      </tds-breadcrumb-item>
      
    </ng-container> `,
                host: {
                    class: 'flex items-center w-full'
                }
            }]
    }], function () { return [{ type: i0.Injector }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1$1.Directionality, decorators: [{
                type: Optional
            }] }]; }, { defaultSeparator: [{
            type: ViewChild,
            args: ['defaultSeparator', { read: TemplateRef }]
        }], autoGenerate: [{
            type: Input
        }], separator: [{
            type: Input
        }], routeLabel: [{
            type: Input
        }], routeLabelFn: [{
            type: Input
        }], listChild: [{
            type: ContentChildren,
            args: [TDSBreadCrumbItemComponent]
        }] }); })();

const _c0 = ["*"];
class TDSBreadCrumbSeparatorComponent {
}
TDSBreadCrumbSeparatorComponent.ɵfac = function TDSBreadCrumbSeparatorComponent_Factory(t) { return new (t || TDSBreadCrumbSeparatorComponent)(); };
TDSBreadCrumbSeparatorComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSBreadCrumbSeparatorComponent, selectors: [["tds-breadcrumb-separator"]], exportAs: ["tdsBreadcrumbSeparator"], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, "tds-breadcrumb-separator", "text-neutral-1-400", "dark:text-d-neutral-1-400", "px-1", "flex"]], template: function TDSBreadCrumbSeparatorComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵelementStart(0, "span", 0);
        i0.ɵɵprojection(1);
        i0.ɵɵelementEnd();
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSBreadCrumbSeparatorComponent, [{
        type: Component,
        args: [{
                selector: 'tds-breadcrumb-separator',
                exportAs: 'tdsBreadcrumbSeparator',
                template: `
    <span class="tds-breadcrumb-separator text-neutral-1-400 dark:text-d-neutral-1-400 px-1 flex">
      <ng-content></ng-content>
    </span>
  `
            }]
    }], null, null); })();

class TDSBreadCrumbModule {
}
TDSBreadCrumbModule.ɵfac = function TDSBreadCrumbModule_Factory(t) { return new (t || TDSBreadCrumbModule)(); };
TDSBreadCrumbModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSBreadCrumbModule });
TDSBreadCrumbModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            TDSOutletModule,
            OverlayModule,
            TDSOverlayModule,
            TDSDropDownModule
        ], BidiModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSBreadCrumbModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    TDSOutletModule,
                    OverlayModule,
                    TDSOverlayModule,
                    TDSDropDownModule
                ],
                declarations: [
                    TDSBreadCrumbComponent,
                    TDSBreadCrumbItemComponent,
                    TDSBreadCrumbSeparatorComponent
                ],
                exports: [
                    BidiModule,
                    TDSBreadCrumbComponent,
                    TDSBreadCrumbItemComponent,
                    TDSBreadCrumbSeparatorComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSBreadCrumbModule, { declarations: [TDSBreadCrumbComponent,
        TDSBreadCrumbItemComponent,
        TDSBreadCrumbSeparatorComponent], imports: [CommonModule,
        TDSOutletModule,
        OverlayModule,
        TDSOverlayModule,
        TDSDropDownModule], exports: [BidiModule,
        TDSBreadCrumbComponent,
        TDSBreadCrumbItemComponent,
        TDSBreadCrumbSeparatorComponent] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSBreadCrumbComponent, TDSBreadCrumbItemComponent, TDSBreadCrumbModule, TDSBreadCrumbSeparatorComponent };
//# sourceMappingURL=tds-ui-breadcrumb.mjs.map
