import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ENTER, SPACE, hasModifierKey } from '@angular/cdk/keycodes';
import * as i0 from '@angular/core';
import { InjectionToken, Directive, Inject, Optional, Input, Component, ViewEncapsulation, ChangeDetectionStrategy, EventEmitter, Output, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { mixinDisabled } from 'tds-ui/shared/common';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i3 from 'tds-ui/core/selection';
import { TDSPseudoCheckboxModule } from 'tds-ui/core/selection';

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Injection token used to provide the parent component to options.
 */
const TDS_OPTION_PARENT_COMPONENT = new InjectionToken('TDS_OPTION_PARENT_COMPONENT');

const _c0$1 = ["*", [["tds-option"], ["ng-container"]]];
const _c1 = ["*", "tds-option, ng-container"];
// Notes on the accessibility pattern used for `tds-optgroup`.
// The option group has two different "modes": regular and inert. The regular mode uses the
// recommended a11y pattern which has `role="group"` on the group element with `aria-labelledby`
// pointing to the label. This works for `tds-select`, but it seems to hit a bug for autocomplete
// under VoiceOver where the group doesn't get read out at all. The bug appears to be that if
// there's __any__ a11y-related attribute on the group (e.g. `role` or `aria-labelledby`),
// VoiceOver on Safari won't read it out.
// We've introduced the `inert` mode as a workaround. Under this mode, all a11y attributes are
// removed from the group, and we get the screen reader to read out the group label by mirroring it
// inside an invisible element in the option. This is sub-optimal, because the screen reader will
// repeat the group label on each navigation, whereas the default pattern only reads the group when
// the user enters a new group. The following alternate approaches were considered:
// 1. Reading out the group label using the `LiveAnnouncer` solves the problem, but we can't control
//    when the text will be read out so sometimes it comes in too late or never if the user
//    navigates quickly.
// 2. `<tds-option aria-describedby="groupLabel"` - This works on Safari, but VoiceOver in Chrome
//    won't read out the description at all.
// 3. `<tds-option aria-labelledby="optionLabel groupLabel"` - This works on Chrome, but Safari
//     doesn't read out the text at all. Furthermore, on
// Boilerplate for applying mixins to TDSOptgroup.
/** @docs-private */
class TDSOptgroupBase {
}
const _TDSOptgroupMixinBase = mixinDisabled(TDSOptgroupBase);
// Counter for unique group ids.
let _uniqueOptgroupIdCounter = 0;
class _TDSOptgroupBase extends _TDSOptgroupMixinBase {
    constructor(parent) {
        super();
        /** Unique id for the underlying label. */
        this._labelId = `tds-optgroup-label-${_uniqueOptgroupIdCounter++}`;
        this._inert = parent?.inertGroups ?? false;
    }
}
_TDSOptgroupBase.ɵfac = function _TDSOptgroupBase_Factory(t) { return new (t || _TDSOptgroupBase)(i0.ɵɵdirectiveInject(TDS_OPTION_PARENT_COMPONENT, 8)); };
_TDSOptgroupBase.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: _TDSOptgroupBase, inputs: { label: "label" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(_TDSOptgroupBase, [{
        type: Directive
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [TDS_OPTION_PARENT_COMPONENT]
            }, {
                type: Optional
            }] }]; }, { label: [{
            type: Input
        }] }); })();
/**
 * Injection token that can be used to reference instances of `TDSOptgroup`. It serves as
 * alternative token to the actual `TDSOptgroup` class which could cause unnecessary
 * retention of the class and its component metadata.
 */
const TDS_OPTGROUP = new InjectionToken('TDSOptgroup');
/**
 * Component that is used to group instances of `tds-option`.
 */
class TDSOptgroup extends _TDSOptgroupBase {
}
TDSOptgroup.ɵfac = /*@__PURE__*/ function () { let ɵTDSOptgroup_BaseFactory; return function TDSOptgroup_Factory(t) { return (ɵTDSOptgroup_BaseFactory || (ɵTDSOptgroup_BaseFactory = i0.ɵɵgetInheritedFactory(TDSOptgroup)))(t || TDSOptgroup); }; }();
TDSOptgroup.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSOptgroup, selectors: [["tds-optgroup"]], hostAttrs: [1, "tds-optgroup"], hostVars: 5, hostBindings: function TDSOptgroup_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("role", ctx._inert ? null : "group")("aria-disabled", ctx._inert ? null : ctx.disabled.toString())("aria-labelledby", ctx._inert ? null : ctx._labelId);
        i0.ɵɵclassProp("tds-optgroup-disabled", ctx.disabled);
    } }, inputs: { disabled: "disabled" }, exportAs: ["tdsOptgroup"], features: [i0.ɵɵProvidersFeature([{ provide: TDS_OPTGROUP, useExisting: TDSOptgroup }]), i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 4, vars: 2, consts: [["aria-hidden", "true", 1, "tds-optgroup-label", 3, "id"]], template: function TDSOptgroup_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c0$1);
        i0.ɵɵelementStart(0, "span", 0);
        i0.ɵɵtext(1);
        i0.ɵɵprojection(2);
        i0.ɵɵelementEnd();
        i0.ɵɵprojection(3, 1);
    } if (rf & 2) {
        i0.ɵɵproperty("id", ctx._labelId);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1("", ctx.label, " ");
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSOptgroup, [{
        type: Component,
        args: [{ selector: 'tds-optgroup', exportAs: 'tdsOptgroup', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, inputs: ['disabled'], host: {
                    'class': 'tds-optgroup',
                    '[attr.role]': '_inert ? null : "group"',
                    '[attr.aria-disabled]': '_inert ? null : disabled.toString()',
                    '[attr.aria-labelledby]': '_inert ? null : _labelId',
                    '[class.tds-optgroup-disabled]': 'disabled',
                }, providers: [{ provide: TDS_OPTGROUP, useExisting: TDSOptgroup }], template: "<span class=\"tds-optgroup-label\" aria-hidden=\"true\" [id]=\"_labelId\">{{ label }} \r\n    <ng-content></ng-content>\r\n</span>\r\n<ng-content select=\"tds-option, ng-container\"></ng-content>\r\n" }]
    }], null, null); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function TDSOption_tds_pseudo_checkbox_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "tds-pseudo-checkbox", 3);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("state", ctx_r0.selected ? "checked" : "unchecked")("disabled", ctx_r0.disabled);
} }
function TDSOption_span_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 4);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("(", ctx_r1.group.label, ")");
} }
const _c0 = ["*"];
/**
 * Option IDs need to be unique across components, so this counter exists outside of
 * the component definition.
 */
let _uniqueIdCounter = 0;
/** Event object emitted by TDSOption when selected or deselected. */
class TDSOptionSelectionChange {
    constructor(
    /** Reference to the option that emitted the event. */
    source, 
    /** Whether the change in the option's value was a result of a user action. */
    isUserInput = false) {
        this.source = source;
        this.isUserInput = isUserInput;
    }
}
class _TDSOptionBase {
    constructor(_element, _changeDetectorRef, _parent, group) {
        this._element = _element;
        this._changeDetectorRef = _changeDetectorRef;
        this._parent = _parent;
        this.group = group;
        this._selected = false;
        this._active = false;
        this._disabled = false;
        this._hide = false;
        this._mostRecentViewValue = '';
        /** The unique ID of the option. */
        this.id = `tds-option-${_uniqueIdCounter++}`;
        /** Event emitted when the option is selected or deselected. */
        // tslint:disable-next-line:no-output-on-prefix
        this.onSelectionChange = new EventEmitter();
        /** Emits when the state of the option changes and any parents have to be notified. */
        this._stateChanges = new Subject();
    }
    /** Whether the wrapping component is in multiple selection mode. */
    get multiple() { return this._parent && this._parent.multiple; }
    /** Whether or not the option is currently selected. */
    get selected() { return this._selected; }
    /** Whether the option is disabled. */
    get disabled() { return (this.group && this.group.disabled) || this._disabled; }
    set disabled(value) { this._disabled = coerceBooleanProperty(value); }
    /** Whether the option is disabled. */
    get hide() { return this._hide; }
    set hide(value) { this._hide = coerceBooleanProperty(value); }
    /**
     * Whether or not the option is currently active and ready to be selected.
     * An active option displays styles as if it is focused, but the
     * focus is actually retained somewhere else. This comes in handy
     * for components like autocomplete where focus must remain on the input.
     */
    get active() {
        return this._active;
    }
    /**
     * The displayed value of the option. It is necessary to show the selected option in the
     * select's trigger.
     */
    get viewValue() {
        // TODO(kara): Add input property alternative for node envs.
        return (this._getHostElement().textContent || '').trim();
    }
    /** Selects the option. */
    select() {
        if (!this._selected) {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /** Deselects the option. */
    deselect() {
        if (this._selected) {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /** Sets focus onto this option. */
    focus(_origin, options) {
        // Note that we aren't using `_origin`, but we need to keep it because some internal consumers
        // use `TDSOption` in a `FocusKeyManager` and we need it to match `FocusableOption`.
        const element = this._getHostElement();
        if (typeof element.focus === 'function') {
            element.focus(options);
        }
    }
    /**
     * This method sets display styles on the option to make it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     */
    setActiveStyles() {
        if (!this._active) {
            this._active = true;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * This method removes display styles on the option that made it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     */
    setInactiveStyles() {
        if (this._active) {
            this._active = false;
            this._changeDetectorRef.markForCheck();
        }
    }
    /** Gets the label to be used when determining whether the option should be focused. */
    getLabel() {
        return this.viewValue;
    }
    /** Ensures the option is selected when activated from the keyboard. */
    _handleKeydown(event) {
        if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {
            this._selectViaInteraction();
            // Prevent the page from scrolling down and form submits.
            event.preventDefault();
        }
    }
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     */
    _selectViaInteraction() {
        if (!this.disabled) {
            this._selected = this.multiple ? !this._selected : true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent(true);
        }
    }
    /**
     * Gets the `aria-selected` value for the option. We explicitly omit the `aria-selected`
     * attribute from single-selection, unselected options. Including the `aria-selected="false"`
     * attributes adds a significant amount of noise to screen-reader users without providing useful
     * information.
     */
    _getAriaSelected() {
        return this.selected || (this.multiple ? false : null);
    }
    /** Returns the correct tabindex for the option depending on disabled state. */
    _getTabIndex() {
        return this.disabled ? '-1' : '0';
    }
    /** Gets the host DOM element. */
    _getHostElement() {
        return this._element.nativeElement;
    }
    ngAfterViewChecked() {
        // Since parent components could be using the option's label to display the selected values
        // (e.g. `tds-select`) and they don't have a way of knowing if the option's label has changed
        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
        // relatively cheap, however we still limit them only to selected options in order to avoid
        // hitting the DOM too often.
        if (this._selected) {
            const viewValue = this.viewValue;
            if (viewValue !== this._mostRecentViewValue) {
                this._mostRecentViewValue = viewValue;
                this._stateChanges.next();
            }
        }
    }
    ngOnDestroy() {
        this._stateChanges.complete();
    }
    /** Emits the selection change event. */
    _emitSelectionChangeEvent(isUserInput = false) {
        this.onSelectionChange.emit(new TDSOptionSelectionChange(this, isUserInput));
    }
}
_TDSOptionBase.ɵfac = function _TDSOptionBase_Factory(t) { i0.ɵɵinvalidFactory(); };
_TDSOptionBase.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: _TDSOptionBase, inputs: { value: "value", id: "id", disabled: "disabled", hide: "hide" }, outputs: { onSelectionChange: "onSelectionChange" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(_TDSOptionBase, [{
        type: Directive
    }], function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: undefined }, { type: _TDSOptgroupBase }]; }, { value: [{
            type: Input
        }], id: [{
            type: Input
        }], disabled: [{
            type: Input
        }], hide: [{
            type: Input
        }], onSelectionChange: [{
            type: Output
        }] }); })();
/**
 * Single option inside of a `<tds-select>` element.
 */
class TDSOption extends _TDSOptionBase {
    constructor(element, changeDetectorRef, parent, group) {
        super(element, changeDetectorRef, parent, group);
    }
}
TDSOption.ɵfac = function TDSOption_Factory(t) { return new (t || TDSOption)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(TDS_OPTION_PARENT_COMPONENT, 8), i0.ɵɵdirectiveInject(TDS_OPTGROUP, 8)); };
TDSOption.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSOption, selectors: [["tds-option"]], hostAttrs: ["role", "option", 1, "tds-option", "border-box", "max-w-full", "outline-none", "cursor-pointer", "relative", "text-left", "block", "py-1.5", "px-3", "text-caption-1", "font-regular", "text-neutral-1-900", "hover:bg-neutral-3-50", "whitespace-nowrap", "overflow-hidden", "overflow-ellipsis"], hostVars: 20, hostBindings: function TDSOption_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("click", function TDSOption_click_HostBindingHandler() { return ctx._selectViaInteraction(); })("keydown", function TDSOption_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); });
    } if (rf & 2) {
        i0.ɵɵhostProperty("id", ctx.id);
        i0.ɵɵattribute("tabindex", ctx._getTabIndex())("aria-selected", ctx._getAriaSelected())("aria-disabled", ctx.disabled.toString());
        i0.ɵɵclassProp("tds-selected", ctx.selected)("flex", ctx.selected)("justify-between", ctx.selected)("bg-neutral-3-50", ctx.selected)("tds-option-multiple", ctx.multiple)("tds-active", ctx.active)("text-primary-1", ctx.active)("tds-option-disabled", ctx.disabled);
    } }, exportAs: ["tdsOption"], features: [i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 4, vars: 2, consts: [["class", "tds-option-pseudo-checkbox", 3, "state", "disabled", 4, "ngIf"], [1, "tds-option-text", "overflow-ellipsis"], ["class", "cdk-visually-hidden", 4, "ngIf"], [1, "tds-option-pseudo-checkbox", 3, "state", "disabled"], [1, "cdk-visually-hidden"]], template: function TDSOption_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtemplate(0, TDSOption_tds_pseudo_checkbox_0_Template, 1, 2, "tds-pseudo-checkbox", 0);
        i0.ɵɵelementStart(1, "span", 1);
        i0.ɵɵprojection(2);
        i0.ɵɵelementEnd();
        i0.ɵɵtemplate(3, TDSOption_span_3_Template, 2, 1, "span", 2);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.multiple);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.group && ctx.group._inert);
    } }, directives: [i2.NgIf, i3.TDSPseudoCheckbox], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSOption, [{
        type: Component,
        args: [{ selector: 'tds-option', exportAs: 'tdsOption', host: {
                    'role': 'option',
                    '[attr.tabindex]': '_getTabIndex()',
                    '[class.tds-selected]': 'selected',
                    '[class.flex]': 'selected',
                    '[class.justify-between]': 'selected',
                    '[class.bg-neutral-3-50]': 'selected',
                    '[class.tds-option-multiple]': 'multiple',
                    '[class.tds-active]': 'active',
                    '[class.text-primary-1]': 'active',
                    '[id]': 'id',
                    '[attr.aria-selected]': '_getAriaSelected()',
                    '[attr.aria-disabled]': 'disabled.toString()',
                    '[class.tds-option-disabled]': 'disabled',
                    '(click)': '_selectViaInteraction()',
                    '(keydown)': '_handleKeydown($event)',
                    'class': 'tds-option  border-box max-w-full outline-none cursor-pointer relative text-left block py-1.5 px-3 text-caption-1 font-regular text-neutral-1-900 hover:bg-neutral-3-50 whitespace-nowrap overflow-hidden overflow-ellipsis',
                }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: "<tds-pseudo-checkbox *ngIf=\"multiple\" class=\"tds-option-pseudo-checkbox\"\r\n    [state]=\"selected ? 'checked' : 'unchecked'\" [disabled]=\"disabled\"></tds-pseudo-checkbox>\r\n\r\n<span class=\"tds-option-text overflow-ellipsis\">\r\n    <ng-content></ng-content>\r\n</span>\r\n<!-- <span class=\"tdsi-success-fill text-primary-1\" *ngIf=\"selected\">\r\n</span> -->\r\n\r\n<!-- See a11y notes inside optgroup.ts for context behind this element. -->\r\n<span class=\"cdk-visually-hidden\" *ngIf=\"group && group._inert\">({{ group.label }})</span>\r\n\r\n\r\n" }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TDS_OPTION_PARENT_COMPONENT]
            }] }, { type: TDSOptgroup, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TDS_OPTGROUP]
            }] }]; }, null); })();
/**
 * Counts the amount of option group labels that precede the specified option.
 * @param optionIndex Index of the option at which to start counting.
 * @param options Flat list of all of the options.
 * @param optionGroups Flat list of all of the option groups.
 * @docs-private
 */
function _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {
    if (optionGroups.length) {
        let optionsArray = options.toArray();
        let groups = optionGroups.toArray();
        let groupCounter = 0;
        for (let i = 0; i < optionIndex + 1; i++) {
            if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {
                groupCounter++;
            }
        }
        return groupCounter;
    }
    return 0;
}
/**
 * Determines the position to which to scroll a panel in order for an option to be into view.
 * @param optionOffset Offset of the option from the top of the panel.
 * @param optionHeight Height of the options.
 * @param currentScrollPosition Current scroll position of the panel.
 * @param panelHeight Height of the panel.
 * @docs-private
 */
function _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {
    if (optionOffset < currentScrollPosition) {
        return optionOffset;
    }
    if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
        return Math.max(0, optionOffset - panelHeight + optionHeight);
    }
    return currentScrollPosition;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class TDSOptionModule {
}
TDSOptionModule.ɵfac = function TDSOptionModule_Factory(t) { return new (t || TDSOptionModule)(); };
TDSOptionModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSOptionModule });
TDSOptionModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[CommonModule, TDSPseudoCheckboxModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSOptionModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, TDSPseudoCheckboxModule],
                exports: [TDSOption, TDSOptgroup],
                declarations: [TDSOption, TDSOptgroup]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSOptionModule, { declarations: [TDSOption, TDSOptgroup], imports: [CommonModule, TDSPseudoCheckboxModule], exports: [TDSOption, TDSOptgroup] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSOptgroup, TDSOption, TDSOptionModule, TDSOptionSelectionChange, TDS_OPTGROUP, TDS_OPTION_PARENT_COMPONENT, _TDSOptgroupBase, _TDSOptionBase, _countGroupLabelsBeforeOption, _getOptionScrollPosition };
//# sourceMappingURL=tds-ui-core-option.mjs.map
