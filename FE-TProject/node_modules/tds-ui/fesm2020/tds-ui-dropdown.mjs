import { __decorate } from 'tslib';
import { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import * as i0 from '@angular/core';
import { EventEmitter, Directive, Input, Output, NgModule, TemplateRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Optional, Host, ViewChild, Injectable } from '@angular/core';
import { Subject, BehaviorSubject, merge, fromEvent, EMPTY, combineLatest, Subscription } from 'rxjs';
import { mapTo, map, switchMap, filter, auditTime, distinctUntilChanged, takeUntil, take } from 'rxjs/operators';
import { POSITION_MAP, TDSOverlayModule } from 'tds-ui/core/overlay';
import { InputBoolean } from 'tds-ui/shared/utility';
import * as i1 from '@angular/cdk/overlay';
import { OverlayModule, ConnectionPositionPair } from '@angular/cdk/overlay';
import * as i2 from '@angular/cdk/platform';
import { PlatformModule } from '@angular/cdk/platform';
import * as i2$1 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i4 from '@angular/common';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { TDSButtonModule } from 'tds-ui/button';
import * as i3 from 'tds-ui/core/no-animation';
import { TDSNoAnimationModule } from 'tds-ui/core/no-animation';
import { TDSOutletModule } from 'tds-ui/core/outlet';
import * as i1$1 from 'tds-ui/menu';
import { TDSMenuService, TDSMenuModule } from 'tds-ui/menu';
import { slideMotion } from 'tds-ui/core/animation';

const listOfPositions$1 = [POSITION_MAP.bottomLeft, POSITION_MAP.bottomRight, POSITION_MAP.topRight, POSITION_MAP.topLeft];
class TDSDropDownDirective {
    constructor(elementRef, overlay, renderer, viewContainerRef, platform) {
        this.elementRef = elementRef;
        this.overlay = overlay;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.platform = platform;
        this.overlayRef = null;
        this.destroy$ = new Subject();
        this.positionStrategy = this.overlay
            .position()
            .flexibleConnectedTo(this.elementRef.nativeElement)
            .withLockedPosition()
            .withTransformOriginOn('.tds-dropdown');
        this.inputVisible$ = new BehaviorSubject(false);
        this.trigger$ = new BehaviorSubject('hover');
        this.overlayClose$ = new Subject();
        this.tdsDropdownMenu = null;
        this.trigger = 'hover';
        this.matchWidthElement = null;
        this.backdrop = false;
        this.clickHide = true;
        this.disabled = false;
        this.visible = false;
        this.autoClose = true;
        this.overlayClassName = '';
        this.overlayStyle = {};
        this.placement = 'bottomLeft';
        this.visibleChange = new EventEmitter();
        this.tdsDropdownOutsideClick = new EventEmitter();
        // TODO: move to host after View Engine deprecation
        this.elementRef.nativeElement.classList.add('tds-dropdown-trigger');
    }
    setDropdownMenuValue(key, value) {
        if (this.tdsDropdownMenu) {
            this.tdsDropdownMenu.setValue(key, value);
        }
    }
    ngOnInit() { }
    ngAfterViewInit() {
        if (this.tdsDropdownMenu) {
            const nativeElement = this.elementRef.nativeElement;
            /** host mouse state **/
            const hostMouseState$ = merge(fromEvent(nativeElement, 'mouseenter').pipe(mapTo(true)), fromEvent(nativeElement, 'mouseleave').pipe(mapTo(false)));
            /** menu mouse state **/
            const menuMouseState$ = this.tdsDropdownMenu.mouseState$;
            /** merged mouse state **/
            const mergedMouseState$ = merge(menuMouseState$, hostMouseState$);
            /** host click state **/
            const hostClickState$ = fromEvent(nativeElement, 'click').pipe(map(() => !this.visible));
            /** visible state switch by trigger **/
            const visibleStateByTrigger$ = this.trigger$.pipe(switchMap(trigger => {
                if (trigger === 'hover') {
                    return mergedMouseState$;
                }
                else if (trigger === 'click') {
                    return hostClickState$;
                }
                else {
                    return EMPTY;
                }
            }));
            const descendantMenuItemClick$ = this.tdsDropdownMenu.descendantMenuItemClick$.pipe(filter(() => this.clickHide), mapTo(false));
            const domTriggerVisible$ = merge(visibleStateByTrigger$, descendantMenuItemClick$, this.overlayClose$).pipe(filter(() => !this.disabled));
            const visible$ = merge(this.inputVisible$, domTriggerVisible$);
            combineLatest([visible$, this.tdsDropdownMenu.isChildSubMenuOpen$])
                .pipe(map(([visible, sub]) => visible || sub), auditTime(150), distinctUntilChanged(), filter(() => this.platform.isBrowser), takeUntil(this.destroy$))
                .subscribe((visible) => {
                const element = this.matchWidthElement ? this.matchWidthElement.nativeElement : nativeElement;
                const triggerWidth = element.getBoundingClientRect().width;
                if (this.visible !== visible) {
                    this.visibleChange.emit(visible);
                }
                this.visible = visible;
                if (visible) {
                    /** set up overlayRef **/
                    if (!this.overlayRef) {
                        /** new overlay **/
                        this.overlayRef = this.overlay.create({
                            positionStrategy: this.positionStrategy,
                            minWidth: triggerWidth,
                            disposeOnNavigation: true,
                            hasBackdrop: (this.backdrop) && this.trigger === 'click',
                            scrollStrategy: this.autoClose ? this.overlay.scrollStrategies.close() : this.overlay.scrollStrategies.reposition()
                        });
                        merge(this.overlayRef.backdropClick(), this.overlayRef.detachments(), this.overlayRef.outsidePointerEvents().pipe(filter((e) => !this.elementRef.nativeElement.contains(e.target))), this.overlayRef.keydownEvents().pipe(filter(e => e.keyCode === ESCAPE && !hasModifierKey(e))))
                            .pipe(filter(() => this.autoClose), takeUntil(this.destroy$))
                            .subscribe(() => {
                            this.overlayClose$.next(false);
                        });
                        merge(this.overlayRef.backdropClick(), this.overlayRef.outsidePointerEvents().pipe(filter((e) => !this.elementRef.nativeElement.contains(e.target))))
                            .pipe(takeUntil(this.destroy$))
                            .subscribe(() => {
                            this.tdsDropdownOutsideClick.next();
                        });
                    }
                    else {
                        /** update overlay config **/
                        const overlayConfig = this.overlayRef.getConfig();
                        overlayConfig.minWidth = triggerWidth;
                    }
                    /** open dropdown with animation **/
                    this.positionStrategy.withPositions([POSITION_MAP[this.placement], ...listOfPositions$1]);
                    /** reset portal if needed **/
                    if (!this.portal || this.portal.templateRef !== this.tdsDropdownMenu.templateRef) {
                        this.portal = new TemplatePortal(this.tdsDropdownMenu.templateRef, this.viewContainerRef);
                    }
                    this.overlayRef.attach(this.portal);
                }
                else {
                    /** detach overlayRef if needed **/
                    if (this.overlayRef) {
                        this.overlayRef.detach();
                    }
                }
            });
            this.tdsDropdownMenu.animationStateChange$.pipe(takeUntil(this.destroy$)).subscribe(event => {
                if (event.toState === 'void') {
                    if (this.overlayRef) {
                        this.overlayRef.dispose();
                    }
                    this.overlayRef = null;
                }
            });
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        if (this.overlayRef) {
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
    }
    ngOnChanges(changes) {
        const { visible, disabled, overlayClassName, overlayStyle, trigger, backdrop } = changes;
        if (trigger) {
            this.trigger$.next(this.trigger);
        }
        if (visible) {
            this.inputVisible$.next(this.visible);
        }
        if (disabled) {
            const nativeElement = this.elementRef.nativeElement;
            if (this.disabled) {
                this.renderer.setAttribute(nativeElement, 'disabled', '');
                this.inputVisible$.next(false);
            }
            else {
                this.renderer.removeAttribute(nativeElement, 'disabled');
            }
        }
        if (overlayClassName) {
            this.setDropdownMenuValue('overlayClassName', this.overlayClassName);
        }
        if (overlayStyle) {
            this.setDropdownMenuValue('overlayStyle', this.overlayStyle);
        }
        if (backdrop) {
            // console.warn('`backdrop` in dropdown component will be removed in 12.0.0, please use `hasBackdrop` instead.');
        }
    }
}
TDSDropDownDirective.ɵfac = function TDSDropDownDirective_Factory(t) { return new (t || TDSDropDownDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.Overlay), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i2.Platform)); };
TDSDropDownDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSDropDownDirective, selectors: [["", "tds-dropdown", ""]], inputs: { tdsDropdownMenu: "tdsDropdownMenu", trigger: "trigger", matchWidthElement: "matchWidthElement", backdrop: "backdrop", clickHide: "clickHide", disabled: "disabled", visible: "visible", autoClose: "autoClose", overlayClassName: "overlayClassName", overlayStyle: "overlayStyle", placement: "placement" }, outputs: { visibleChange: "visibleChange", tdsDropdownOutsideClick: "tdsDropdownOutsideClick" }, exportAs: ["tdsDropdown"], features: [i0.ɵɵNgOnChangesFeature] });
__decorate([
    InputBoolean()
], TDSDropDownDirective.prototype, "backdrop", void 0);
__decorate([
    InputBoolean()
], TDSDropDownDirective.prototype, "clickHide", void 0);
__decorate([
    InputBoolean()
], TDSDropDownDirective.prototype, "disabled", void 0);
__decorate([
    InputBoolean()
], TDSDropDownDirective.prototype, "visible", void 0);
__decorate([
    InputBoolean()
], TDSDropDownDirective.prototype, "autoClose", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDropDownDirective, [{
        type: Directive,
        args: [{
                selector: '[tds-dropdown]',
                exportAs: 'tdsDropdown'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i1.Overlay }, { type: i0.Renderer2 }, { type: i0.ViewContainerRef }, { type: i2.Platform }]; }, { tdsDropdownMenu: [{
            type: Input
        }], trigger: [{
            type: Input
        }], matchWidthElement: [{
            type: Input
        }], backdrop: [{
            type: Input
        }], clickHide: [{
            type: Input
        }], disabled: [{
            type: Input
        }], visible: [{
            type: Input
        }], autoClose: [{
            type: Input
        }], overlayClassName: [{
            type: Input
        }], overlayStyle: [{
            type: Input
        }], placement: [{
            type: Input
        }], visibleChange: [{
            type: Output
        }], tdsDropdownOutsideClick: [{
            type: Output
        }] }); })();

class TDSContextMenuServiceModule {
}
TDSContextMenuServiceModule.ɵfac = function TDSContextMenuServiceModule_Factory(t) { return new (t || TDSContextMenuServiceModule)(); };
TDSContextMenuServiceModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSContextMenuServiceModule });
TDSContextMenuServiceModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSContextMenuServiceModule, [{
        type: NgModule
    }], null, null); })();

class TDSDropDownADirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        // TODO: move to host after View Engine deprecation
        this.elementRef.nativeElement.classList.add('tds-dropdown-link');
    }
}
TDSDropDownADirective.ɵfac = function TDSDropDownADirective_Factory(t) { return new (t || TDSDropDownADirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSDropDownADirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSDropDownADirective, selectors: [["a", "tds-dropdown", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDropDownADirective, [{
        type: Directive,
        args: [{
                selector: 'a[tds-dropdown]'
            }]
    }], function () { return [{ type: i0.ElementRef }]; }, null); })();

class TDSDropdownButtonDirective {
    constructor(renderer, 
    // @Host() @Optional() private nzButtonGroupComponent: NzButtonGroupComponent,
    elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
    }
    ngAfterViewInit() {
        const parentElement = this.renderer.parentNode(this.elementRef.nativeElement);
        // if (this.nzButtonGroupComponent && parentElement) {
        //   this.renderer.addClass(parentElement, 'tds-dropdown-button');
        // }
    }
}
TDSDropdownButtonDirective.ɵfac = function TDSDropdownButtonDirective_Factory(t) { return new (t || TDSDropdownButtonDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSDropdownButtonDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSDropdownButtonDirective, selectors: [["", "tds-button", "", "tds-dropdown", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDropdownButtonDirective, [{
        type: Directive,
        args: [{
                selector: '[tds-button][tds-dropdown]'
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }]; }, null); })();

class TDSDropDownItemDirective {
    constructor(TDSMenuService, cdr) {
        this.TDSMenuService = TDSMenuService;
        this.cdr = cdr;
        this.destroy$ = new Subject();
        this.selected$ = new Subject();
        this.disabled = false;
        this.selected = false;
    }
    /** clear all item selected status except this */
    clickMenuItem(e) {
        if (this.disabled) {
            e.preventDefault();
            e.stopPropagation();
        }
        else {
            this.TDSMenuService.onDescendantMenuItemClick(this);
        }
    }
    ngOnInit() {
    }
    ngAfterContentInit() {
    }
    ngOnChanges(changes) {
        if (changes.disabled) {
            this.cdr.markForCheck();
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
TDSDropDownItemDirective.ɵfac = function TDSDropDownItemDirective_Factory(t) { return new (t || TDSDropDownItemDirective)(i0.ɵɵdirectiveInject(i1$1.TDSMenuService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
TDSDropDownItemDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSDropDownItemDirective, selectors: [["", "tds-dropdown-item", ""]], hostAttrs: [1, "tds-dropdown-item", "text-neutral-1-900", "dark:text-d-neutral-1-900", "text-body-2", "px-3", "py-1.5", "font-regular", "dark:hover:bg-d-neutral-3-400", "hover:bg-neutral-3-50", "w-full"], hostVars: 2, hostBindings: function TDSDropDownItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("click", function TDSDropDownItemDirective_click_HostBindingHandler($event) { return ctx.clickMenuItem($event); });
    } if (rf & 2) {
        i0.ɵɵclassProp("cursor-pointer", !ctx.disabled);
    } }, inputs: { disabled: "disabled", selected: "selected" }, exportAs: ["tdsDropdownItem"], features: [i0.ɵɵNgOnChangesFeature] });
__decorate([
    InputBoolean()
], TDSDropDownItemDirective.prototype, "disabled", void 0);
__decorate([
    InputBoolean()
], TDSDropDownItemDirective.prototype, "selected", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDropDownItemDirective, [{
        type: Directive,
        args: [{
                selector: '[tds-dropdown-item]',
                exportAs: 'tdsDropdownItem',
                host: {
                    class: "tds-dropdown-item text-neutral-1-900  dark:text-d-neutral-1-900  text-body-2 px-3 py-1.5 font-regular dark:hover:bg-d-neutral-3-400 hover:bg-neutral-3-50  w-full",
                    '[class.cursor-pointer]': "!disabled",
                    '(click)': 'clickMenuItem($event)'
                }
            }]
    }], function () { return [{ type: i1$1.TDSMenuService }, { type: i0.ChangeDetectorRef }]; }, { disabled: [{
            type: Input
        }], selected: [{
            type: Input
        }] }); })();

function TDSDropdownMenuComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 0);
    i0.ɵɵlistener("@slideMotion.done", function TDSDropdownMenuComponent_ng_template_0_Template_div_animation_slideMotion_done_0_listener($event) { i0.ɵɵrestoreView(_r2); const ctx_r1 = i0.ɵɵnextContext(); return ctx_r1.onAnimationEvent($event); })("mouseenter", function TDSDropdownMenuComponent_ng_template_0_Template_div_mouseenter_0_listener() { i0.ɵɵrestoreView(_r2); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.setMouseState(true); })("mouseleave", function TDSDropdownMenuComponent_ng_template_0_Template_div_mouseleave_0_listener() { i0.ɵɵrestoreView(_r2); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.setMouseState(false); });
    i0.ɵɵelementStart(1, "div", 1)(2, "div", 2);
    i0.ɵɵprojection(3);
    i0.ɵɵelementEnd()()();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("tds-dropdown-rtl", ctx_r0.dir === "rtl");
    i0.ɵɵproperty("ngClass", ctx_r0.overlayClassName)("ngStyle", ctx_r0.overlayStyle)("@slideMotion", undefined);
} }
const _c0 = ["*"];
class TDSDropdownMenuComponent {
    constructor(cdr, elementRef, renderer, viewContainerRef, tdsMenuService, directionality, noAnimation) {
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.tdsMenuService = tdsMenuService;
        this.directionality = directionality;
        this.noAnimation = noAnimation;
        this.mouseState$ = new BehaviorSubject(false);
        this.isChildSubMenuOpen$ = this.tdsMenuService.isChildSubMenuOpen$;
        this.descendantMenuItemClick$ = this.tdsMenuService.descendantMenuItemClick$;
        this.animationStateChange$ = new EventEmitter();
        this.overlayClassName = '';
        this.overlayStyle = {};
        this.dir = 'ltr';
        this.destroy$ = new Subject();
    }
    onAnimationEvent(event) {
        this.animationStateChange$.emit(event);
    }
    setMouseState(visible) {
        this.mouseState$.next(visible);
    }
    setValue(key, value) {
        this[key] = value;
        this.cdr.markForCheck();
    }
    ngOnInit() {
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
        this.dir = this.directionality.value;
    }
    ngAfterContentInit() {
        this.renderer.removeChild(this.renderer.parentNode(this.elementRef.nativeElement), this.elementRef.nativeElement);
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
TDSDropdownMenuComponent.ɵfac = function TDSDropdownMenuComponent_Factory(t) { return new (t || TDSDropdownMenuComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i1$1.TDSMenuService), i0.ɵɵdirectiveInject(i2$1.Directionality, 8), i0.ɵɵdirectiveInject(i3.TDSNoAnimationDirective, 9)); };
TDSDropdownMenuComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSDropdownMenuComponent, selectors: [["tds-dropdown-menu"]], viewQuery: function TDSDropdownMenuComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(TemplateRef, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, exportAs: ["tdsDropdownMenu"], features: [i0.ɵɵProvidersFeature([
            TDSMenuService,
            // /** menu is inside dropdown-menu component **/
            // {
            //   provide: TDSIsMenuInsideDropDownToken,
            //   useValue: true
            // }
        ])], ngContentSelectors: _c0, decls: 1, vars: 0, consts: [[1, "tds-dropdown", "min-w-full", "relative", 3, "ngClass", "ngStyle", "mouseenter", "mouseleave"], [1, "py-1", "w-full"], [1, "w-full", "bg-white", "dark:bg-d-neutral-3-300", "shadow-1-lg", "rounded", "py-1"]], template: function TDSDropdownMenuComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtemplate(0, TDSDropdownMenuComponent_ng_template_0_Template, 4, 5, "ng-template");
    } }, directives: [i4.NgClass, i4.NgStyle], encapsulation: 2, data: { animation: [slideMotion] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDropdownMenuComponent, [{
        type: Component,
        args: [{
                selector: `tds-dropdown-menu`,
                exportAs: `tdsDropdownMenu`,
                animations: [slideMotion],
                providers: [
                    TDSMenuService,
                    // /** menu is inside dropdown-menu component **/
                    // {
                    //   provide: TDSIsMenuInsideDropDownToken,
                    //   useValue: true
                    // }
                ],
                template: `
    <ng-template>
      <div 
        class="tds-dropdown   min-w-full relative"
        [class.tds-dropdown-rtl]="dir === 'rtl'"
        [ngClass]="overlayClassName"
        [ngStyle]="overlayStyle"
        @slideMotion
        (@slideMotion.done)="onAnimationEvent($event)"       
        (mouseenter)="setMouseState(true)"
        (mouseleave)="setMouseState(false)"
      >
      <div class="py-1 w-full" >
        <div class='w-full bg-white dark:bg-d-neutral-3-300  shadow-1-lg rounded py-1'>
          <ng-content></ng-content>
        </div>        
      </div>
        
      </div>
    </ng-template>
  `,
                preserveWhitespaces: false,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ViewContainerRef }, { type: i1$1.TDSMenuService }, { type: i2$1.Directionality, decorators: [{
                type: Optional
            }] }, { type: i3.TDSNoAnimationDirective, decorators: [{
                type: Host
            }, {
                type: Optional
            }] }]; }, { templateRef: [{
            type: ViewChild,
            args: [TemplateRef, { static: true }]
        }] }); })();

class TDSDropDownModule {
}
TDSDropDownModule.ɵfac = function TDSDropDownModule_Factory(t) { return new (t || TDSDropDownModule)(); };
TDSDropDownModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSDropDownModule });
TDSDropDownModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            BidiModule,
            CommonModule,
            OverlayModule,
            FormsModule,
            TDSButtonModule,
            TDSMenuModule,
            TDSNoAnimationModule,
            PlatformModule,
            TDSOverlayModule,
            TDSContextMenuServiceModule,
            TDSOutletModule
        ], TDSMenuModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDropDownModule, [{
        type: NgModule,
        args: [{
                imports: [
                    BidiModule,
                    CommonModule,
                    OverlayModule,
                    FormsModule,
                    TDSButtonModule,
                    TDSMenuModule,
                    TDSNoAnimationModule,
                    PlatformModule,
                    TDSOverlayModule,
                    TDSContextMenuServiceModule,
                    TDSOutletModule
                ],
                declarations: [TDSDropDownDirective,
                    TDSDropDownADirective,
                    TDSDropdownMenuComponent,
                    TDSDropdownButtonDirective,
                    TDSDropDownItemDirective
                ],
                exports: [TDSMenuModule,
                    TDSDropDownDirective,
                    TDSDropDownADirective,
                    TDSDropdownMenuComponent,
                    TDSDropdownButtonDirective,
                    TDSDropDownItemDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSDropDownModule, { declarations: [TDSDropDownDirective,
        TDSDropDownADirective,
        TDSDropdownMenuComponent,
        TDSDropdownButtonDirective,
        TDSDropDownItemDirective], imports: [BidiModule,
        CommonModule,
        OverlayModule,
        FormsModule,
        TDSButtonModule,
        TDSMenuModule,
        TDSNoAnimationModule,
        PlatformModule,
        TDSOverlayModule,
        TDSContextMenuServiceModule,
        TDSOutletModule], exports: [TDSMenuModule,
        TDSDropDownDirective,
        TDSDropDownADirective,
        TDSDropdownMenuComponent,
        TDSDropdownButtonDirective,
        TDSDropDownItemDirective] }); })();

const listOfPositions = [
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'top' }),
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
];
class TDSContextMenuService {
    constructor(overlay) {
        this.overlay = overlay;
        this.overlayRef = null;
        this.closeSubscription = Subscription.EMPTY;
    }
    create($event, tdsDropdownMenuComponent) {
        this.close(true);
        const { x, y } = $event;
        if ($event instanceof MouseEvent) {
            $event.preventDefault();
        }
        const positionStrategy = this.overlay
            .position()
            .flexibleConnectedTo({ x, y })
            .withPositions(listOfPositions)
            .withTransformOriginOn('.tds-dropdown');
        this.overlayRef = this.overlay.create({
            positionStrategy,
            disposeOnNavigation: true,
            scrollStrategy: this.overlay.scrollStrategies.close()
        });
        this.closeSubscription = merge(tdsDropdownMenuComponent.descendantMenuItemClick$, fromEvent(document, 'click').pipe(filter(event => !!this.overlayRef && !this.overlayRef.overlayElement.contains(event.target)), 
        /** handle firefox contextmenu event **/
        filter(event => event.button !== 2), take(1))).subscribe(() => {
            this.close();
        });
        this.overlayRef.attach(new TemplatePortal(tdsDropdownMenuComponent.templateRef, tdsDropdownMenuComponent.viewContainerRef));
    }
    close(clear = false) {
        if (this.overlayRef) {
            this.overlayRef.detach();
            if (clear) {
                this.overlayRef.dispose();
            }
            this.overlayRef = null;
            this.closeSubscription.unsubscribe();
        }
    }
}
TDSContextMenuService.ɵfac = function TDSContextMenuService_Factory(t) { return new (t || TDSContextMenuService)(i0.ɵɵinject(i1.Overlay)); };
TDSContextMenuService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TDSContextMenuService, factory: TDSContextMenuService.ɵfac, providedIn: TDSContextMenuServiceModule });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSContextMenuService, [{
        type: Injectable,
        args: [{
                providedIn: TDSContextMenuServiceModule
            }]
    }], function () { return [{ type: i1.Overlay }]; }, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSContextMenuService, TDSContextMenuServiceModule, TDSDropDownADirective, TDSDropDownDirective, TDSDropDownItemDirective, TDSDropDownModule, TDSDropdownButtonDirective, TDSDropdownMenuComponent };
//# sourceMappingURL=tds-ui-dropdown.mjs.map
