import * as i5$1 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i1 from '@angular/cdk/clipboard';
import { ClipboardModule } from '@angular/cdk/clipboard';
import * as i2$2 from '@angular/cdk/platform';
import { PlatformModule } from '@angular/cdk/platform';
import * as i2$1 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Input, Output, ViewChild, Inject, Optional, NgModule } from '@angular/core';
import { TDSButtonModule } from 'tds-ui/button';
import * as i4 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';
import * as i2 from 'tds-ui/i18n';
import { TDSI18nModule } from 'tds-ui/i18n';
import * as i5 from 'tds-ui/tds-input';
import { TDSAutosizeDirective, TDSInputModule } from 'tds-ui/tds-input';
import * as i3 from 'tds-ui/tooltip';
import { TDSToolTipModule } from 'tds-ui/tooltip';
import { Subject, Subscription } from 'rxjs';
import { takeUntil, take } from 'rxjs/operators';
import { __decorate } from 'tslib';
import { cancelRequestAnimationFrame, reqAnimFrame } from 'tds-ui/core/animation';
import * as i1$1 from 'tds-ui/core/config';
import { WithConfig } from 'tds-ui/core/config';
import { isStyleSupport, measure } from 'tds-ui/core/util';
import { InputBoolean, InputNumber } from 'tds-ui/shared/utility';
import * as i4$1 from 'tds-ui/core/services';

function TDSTextCopyComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "i", 2);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const icon_r1 = ctx.$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", icon_r1);
} }
class TDSTextCopyComponent {
    constructor(host, cdr, clipboard, i18n) {
        this.host = host;
        this.cdr = cdr;
        this.clipboard = clipboard;
        this.i18n = i18n;
        this.copied = false;
        this.copyId = -1;
        this.nativeElement = this.host.nativeElement;
        this.copyTooltip = null;
        this.copedTooltip = null;
        this.copyIcon = 'tdsi-copy-fill';
        this.copedIcon = 'tdsi-tick-fill';
        this.destroy$ = new Subject();
        this.icons = ['tdsi-copy-fill', 'tdsi-tick-fill'];
        this.textCopy = new EventEmitter();
    }
    ngOnInit() {
        this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.locale = this.i18n.getLocaleData('Text');
            this.updateTooltips();
            this.cdr.markForCheck();
        });
    }
    ngOnChanges(changes) {
        const { tooltips, icons } = changes;
        if (tooltips) {
            this.updateTooltips();
        }
        if (icons) {
            this.updateIcons();
        }
    }
    ngOnDestroy() {
        clearTimeout(this.copyId);
        this.destroy$.next();
        this.destroy$.complete();
    }
    onClick() {
        if (this.copied) {
            return;
        }
        this.copied = true;
        this.cdr.detectChanges();
        const text = this.text;
        this.textCopy.emit(text);
        this.clipboard.copy(text);
        this.onCopied();
    }
    onCopied() {
        clearTimeout(this.copyId);
        this.copyId = setTimeout(() => {
            this.copied = false;
            this.cdr.detectChanges();
        }, 3000);
    }
    updateTooltips() {
        if (this.tooltips === null) {
            this.copedTooltip = null;
            this.copyTooltip = null;
        }
        else if (Array.isArray(this.tooltips)) {
            const [copyTooltip, copedTooltip] = this.tooltips;
            this.copyTooltip = copyTooltip || this.locale?.copy;
            this.copedTooltip = copedTooltip || this.locale?.copied;
        }
        else {
            this.copyTooltip = this.locale?.copy;
            this.copedTooltip = this.locale?.copied;
        }
        this.cdr.markForCheck();
    }
    updateIcons() {
        const [copyIcon, copedIcon] = this.icons;
        this.copyIcon = copyIcon;
        this.copedIcon = copedIcon;
        this.cdr.markForCheck();
    }
}
TDSTextCopyComponent.ɵfac = function TDSTextCopyComponent_Factory(t) { return new (t || TDSTextCopyComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.Clipboard), i0.ɵɵdirectiveInject(i2.TDSI18nService)); };
TDSTextCopyComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTextCopyComponent, selectors: [["tds-text-copy"]], inputs: { text: "text", tooltips: "tooltips", icons: "icons" }, outputs: { textCopy: "textCopy" }, exportAs: ["tdsTextCopy"], features: [i0.ɵɵNgOnChangesFeature], decls: 2, vars: 4, consts: [["type", "button", "tds-tooltip", "", 1, "tds-typography-copy", "cursor-pointer", "bg-transparent", "border-0", "no-underline", "outline-none", "ml-1", 3, "tooltipTitle", "click"], [4, "tdsStringTemplateOutlet"], [1, "text-xl", "text-primary-1", 2, "display", "inline-block", "font-style", "normal", "line-height", "0", "text-align", "center", "text-transform", "none", "vertical-align", "-.125em", "text-rendering", "optimizeLegibility", "-webkit-font-smoothing", "antialiased", 3, "ngClass"]], template: function TDSTextCopyComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "button", 0);
        i0.ɵɵlistener("click", function TDSTextCopyComponent_Template_button_click_0_listener() { return ctx.onClick(); });
        i0.ɵɵtemplate(1, TDSTextCopyComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵclassProp("tds-typography-copy-success", ctx.copied);
        i0.ɵɵproperty("tooltipTitle", ctx.copied ? ctx.copedTooltip : ctx.copyTooltip);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("tdsStringTemplateOutlet", ctx.copied ? ctx.copedIcon : ctx.copyIcon);
    } }, directives: [i3.TDSTooltipDirective, i4.TDSStringTemplateOutletDirective, i2$1.NgClass], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTextCopyComponent, [{
        type: Component,
        args: [{
                selector: 'tds-text-copy',
                exportAs: 'tdsTextCopy',
                template: `
    <button
      type="button"
      tds-tooltip
      [tooltipTitle]="copied ? copedTooltip : copyTooltip"
      class="tds-typography-copy cursor-pointer bg-transparent border-0 no-underline outline-none ml-1"
      [class.tds-typography-copy-success]="copied"
      (click)="onClick()"
    >
      <ng-container *tdsStringTemplateOutlet="copied ? copedIcon : copyIcon; let icon">
        <i class="text-xl text-primary-1" [ngClass]="icon" style="display: inline-block;       
        font-style: normal;
        line-height: 0;
        text-align: center;
        text-transform: none;
        vertical-align: -.125em;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;"></i>
      </ng-container>
    </button>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.Clipboard }, { type: i2.TDSI18nService }]; }, { text: [{
            type: Input
        }], tooltips: [{
            type: Input
        }], icons: [{
            type: Input
        }], textCopy: [{
            type: Output
        }] }); })();

const _c0$1 = ["textarea"];
function TDSTextEditComponent_button_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "i", 4);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const icon_r3 = ctx.$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", icon_r3);
} }
function TDSTextEditComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 2);
    i0.ɵɵlistener("click", function TDSTextEditComponent_button_0_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.onClick(); });
    i0.ɵɵtemplate(1, TDSTextEditComponent_button_0_ng_container_1_Template, 2, 1, "ng-container", 3);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("tooltipTitle", ctx_r0.tooltip === null ? null : ctx_r0.tooltip || (ctx_r0.locale == null ? null : ctx_r0.locale.edit));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r0.icon);
} }
function TDSTextEditComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "textarea", 5, 6);
    i0.ɵɵlistener("input", function TDSTextEditComponent_ng_container_1_Template_textarea_input_1_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.onInput($event); })("blur", function TDSTextEditComponent_ng_container_1_Template_textarea_blur_1_listener() { i0.ɵɵrestoreView(_r8); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.confirm(); })("keydown.esc", function TDSTextEditComponent_ng_container_1_Template_textarea_keydown_esc_1_listener() { i0.ɵɵrestoreView(_r8); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.onCancel(); })("keydown.enter", function TDSTextEditComponent_ng_container_1_Template_textarea_keydown_enter_1_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.onEnter($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} }
class TDSTextEditComponent {
    constructor(zone, host, cdr, i18n) {
        this.zone = zone;
        this.host = host;
        this.cdr = cdr;
        this.i18n = i18n;
        this.editing = false;
        this.destroy$ = new Subject();
        this.icon = 'tdsi-edit-fill';
        this.startEditing = new EventEmitter();
        this.endEditing = new EventEmitter(true);
        this.nativeElement = this.host.nativeElement;
    }
    ngOnInit() {
        this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.locale = this.i18n.getLocaleData('Text');
            this.cdr.markForCheck();
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    onClick() {
        this.beforeText = this.text;
        this.currentText = this.beforeText;
        this.editing = true;
        this.startEditing.emit();
        this.focusAndSetValue();
    }
    confirm() {
        this.editing = false;
        this.endEditing.emit(this.currentText);
    }
    onInput(event) {
        const target = event.target;
        this.currentText = target.value;
    }
    onEnter(event) {
        event.stopPropagation();
        event.preventDefault();
        this.confirm();
    }
    onCancel() {
        this.currentText = this.beforeText;
        this.confirm();
    }
    focusAndSetValue() {
        this.zone.onStable.pipe(take(1), takeUntil(this.destroy$)).subscribe(() => {
            if (this.textarea?.nativeElement) {
                this.textarea.nativeElement.focus();
                this.textarea.nativeElement.value = this.currentText || '';
                this.autosizeDirective.resizeToFitContent();
                this.cdr.markForCheck();
            }
        });
    }
}
TDSTextEditComponent.ɵfac = function TDSTextEditComponent_Factory(t) { return new (t || TDSTextEditComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.TDSI18nService)); };
TDSTextEditComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTextEditComponent, selectors: [["tds-text-edit"]], viewQuery: function TDSTextEditComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$1, 5);
        i0.ɵɵviewQuery(TDSAutosizeDirective, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textarea = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.autosizeDirective = _t.first);
    } }, inputs: { text: "text", icon: "icon", tooltip: "tooltip" }, outputs: { startEditing: "startEditing", endEditing: "endEditing" }, exportAs: ["tdsTextEdit"], decls: 2, vars: 2, consts: [["tds-tooltip", "", "class", "tds-typography-edit cursor-pointer bg-transparent border-0 no-underline outline-none ml-1", 3, "tooltipTitle", "click", 4, "ngIf"], [4, "ngIf"], ["tds-tooltip", "", 1, "tds-typography-edit", "cursor-pointer", "bg-transparent", "border-0", "no-underline", "outline-none", "ml-1", 3, "tooltipTitle", "click"], [4, "tdsStringTemplateOutlet"], [1, "text-xl", "text-primary-1", 2, "display", "inline-block", "font-style", "normal", "line-height", "0", "text-align", "center", "text-transform", "none", "vertical-align", "-.125em", "text-rendering", "optimizeLegibility", "-webkit-font-smoothing", "antialiased", 3, "ngClass"], ["tdsAutosize", "", 1, "w-full", "p-1", "rounded", "border", "border-primary-1", "focus:ring-primary-1", "focus:outline-none", "focus:border-transparent", "shadow-none", "bg-transparent", "text-current", "outline-none", "box-border", 3, "input", "blur", "keydown.esc", "keydown.enter"], ["textarea", ""]], template: function TDSTextEditComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TDSTextEditComponent_button_0_Template, 2, 2, "button", 0);
        i0.ɵɵtemplate(1, TDSTextEditComponent_ng_container_1_Template, 3, 0, "ng-container", 1);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", !ctx.editing);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.editing);
    } }, directives: [i2$1.NgIf, i3.TDSTooltipDirective, i4.TDSStringTemplateOutletDirective, i2$1.NgClass, i5.TDSAutosizeDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTextEditComponent, [{
        type: Component,
        args: [{
                selector: 'tds-text-edit',
                exportAs: 'tdsTextEdit',
                template: `
    <button
      *ngIf="!editing"
      tds-tooltip
      class="tds-typography-edit cursor-pointer bg-transparent border-0 no-underline outline-none ml-1"
      [tooltipTitle]="tooltip === null ? null : tooltip || locale?.edit"
      (click)="onClick()"
    >
      <ng-container *tdsStringTemplateOutlet="icon; let icon">
        <i class="text-xl text-primary-1" [ngClass]="icon" style="display: inline-block;      
        font-style: normal;
        line-height: 0;
        text-align: center;
        text-transform: none;
        vertical-align: -.125em;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;"></i>
      </ng-container>
    </button>
    <ng-container *ngIf="editing">
      <textarea
        #textarea        
        class="w-full p-1 rounded border border-primary-1 focus:ring-primary-1 focus:outline-none focus:border-transparent shadow-none  bg-transparent text-current  outline-none  box-border"
        tdsAutosize
        (input)="onInput($event)"
        (blur)="confirm()"
        (keydown.esc)="onCancel()"
        (keydown.enter)="onEnter($event)"
      ></textarea>
      <!-- <button class="tds-typography-edit-content-confirm" (click)="confirm()">
      lưu
    </button> -->
      
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false
            }]
    }], function () { return [{ type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i2.TDSI18nService }]; }, { text: [{
            type: Input
        }], icon: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], startEditing: [{
            type: Output
        }], endEditing: [{
            type: Output
        }], textarea: [{
            type: ViewChild,
            args: ['textarea', { static: false }]
        }], autosizeDirective: [{
            type: ViewChild,
            args: [TDSAutosizeDirective, { static: false }]
        }] }); })();

const _c0 = ["ellipsisContainer"];
const _c1 = ["expandable"];
const _c2 = ["contentTemplate"];
function TDSTypographyComponent_ng_template_0_ng_content_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵprojection(0, 0, ["*ngIf", "!content"]);
} }
function TDSTypographyComponent_ng_template_0_a_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "span", 7);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", ctx_r8.contentCollapse, " ");
} }
function TDSTypographyComponent_ng_template_0_a_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 5);
    i0.ɵɵlistener("click", function TDSTypographyComponent_ng_template_0_a_2_Template_a_click_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.onCollapse($event); });
    i0.ɵɵtemplate(1, TDSTypographyComponent_ng_template_0_a_2_ng_container_1_Template, 3, 1, "ng-container", 6);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r7.contentCollapse);
} }
function TDSTypographyComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, TDSTypographyComponent_ng_template_0_ng_content_0_Template, 1, 0, "ng-content", 1);
    i0.ɵɵtext(1);
    i0.ɵɵtemplate(2, TDSTypographyComponent_ng_template_0_a_2_Template, 2, 1, "a", 4);
} if (rf & 2) {
    const content_r5 = ctx.content;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", !content_r5);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", content_r5, " ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r1.expandable && !ctx_r1.isEllipsis);
} }
function TDSTypographyComponent_ng_container_2_ng_container_1_ng_template_1_Template(rf, ctx) { }
function TDSTypographyComponent_ng_container_2_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r15 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r15.suffix);
} }
const _c3 = function (a0) { return { content: a0 }; };
function TDSTypographyComponent_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, TDSTypographyComponent_ng_container_2_ng_container_1_ng_template_1_Template, 0, 0, "ng-template", 10);
    i0.ɵɵtemplate(2, TDSTypographyComponent_ng_container_2_ng_container_1_ng_container_2_Template, 2, 1, "ng-container", 1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext(2);
    const _r0 = i0.ɵɵreference(1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r0)("ngTemplateOutletContext", i0.ɵɵpureFunction1(3, _c3, ctx_r11.content));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r11.suffix);
} }
function TDSTypographyComponent_ng_container_2_ng_template_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r17 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r17.ellipsisStr);
} }
function TDSTypographyComponent_ng_container_2_ng_template_2_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r18 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r18.suffix);
} }
function TDSTypographyComponent_ng_container_2_ng_template_2_a_4_Template(rf, ctx) { if (rf & 1) {
    const _r22 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 13, 14);
    i0.ɵɵlistener("click", function TDSTypographyComponent_ng_container_2_ng_template_2_a_4_Template_a_click_0_listener($event) { i0.ɵɵrestoreView(_r22); const ctx_r21 = i0.ɵɵnextContext(3); return ctx_r21.onExpand($event); });
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r19 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1(" ", ctx_r19.locale == null ? null : ctx_r19.locale.expand, " ");
} }
function TDSTypographyComponent_ng_container_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", null, 11);
    i0.ɵɵtemplate(2, TDSTypographyComponent_ng_container_2_ng_template_2_ng_container_2_Template, 2, 1, "ng-container", 1);
    i0.ɵɵtemplate(3, TDSTypographyComponent_ng_container_2_ng_template_2_ng_container_3_Template, 2, 1, "ng-container", 1);
    i0.ɵɵtemplate(4, TDSTypographyComponent_ng_container_2_ng_template_2_a_4_Template, 3, 1, "a", 12);
} if (rf & 2) {
    const ctx_r13 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r13.isEllipsis);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r13.suffix);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r13.expandable && ctx_r13.isEllipsis);
} }
function TDSTypographyComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, TDSTypographyComponent_ng_container_2_ng_container_1_Template, 3, 5, "ng-container", 8);
    i0.ɵɵtemplate(2, TDSTypographyComponent_ng_container_2_ng_template_2_Template, 5, 3, "ng-template", null, 9, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r12 = i0.ɵɵreference(3);
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.expanded || !ctx_r2.hasOperationsWithEllipsis && ctx_r2.ellipsisRows === 1 && !ctx_r2.hasEllipsisObservers || ctx_r2.canCssEllipsis || ctx_r2.suffix && ctx_r2.expanded)("ngIfElse", _r12);
} }
function TDSTypographyComponent_tds_text_edit_3_Template(rf, ctx) { if (rf & 1) {
    const _r24 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "tds-text-edit", 15);
    i0.ɵɵlistener("endEditing", function TDSTypographyComponent_tds_text_edit_3_Template_tds_text_edit_endEditing_0_listener($event) { i0.ɵɵrestoreView(_r24); const ctx_r23 = i0.ɵɵnextContext(); return ctx_r23.onEndEditing($event); })("startEditing", function TDSTypographyComponent_tds_text_edit_3_Template_tds_text_edit_startEditing_0_listener() { i0.ɵɵrestoreView(_r24); const ctx_r25 = i0.ɵɵnextContext(); return ctx_r25.onStartEditing(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("text", ctx_r3.content)("icon", ctx_r3.editIcon)("tooltip", ctx_r3.editTooltip);
} }
function TDSTypographyComponent_tds_text_copy_4_Template(rf, ctx) { if (rf & 1) {
    const _r27 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "tds-text-copy", 16);
    i0.ɵɵlistener("textCopy", function TDSTypographyComponent_tds_text_copy_4_Template_tds_text_copy_textCopy_0_listener($event) { i0.ɵɵrestoreView(_r27); const ctx_r26 = i0.ɵɵnextContext(); return ctx_r26.onTextCopy($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("text", ctx_r4.onCopyText)("tooltips", ctx_r4.copyTooltips)("icons", ctx_r4.copyIcons);
} }
const _c4 = ["*"];
const TDS_CONFIG_MODULE_NAME = 'typography';
const EXPAND_ELEMENT_CLASSNAME = 'tds-typography-expand';
class TDSTypographyComponent {
    constructor(tdsConfigService, host, cdr, viewContainerRef, renderer, platform, i18n, document, resizeService, directionality) {
        this.tdsConfigService = tdsConfigService;
        this.host = host;
        this.cdr = cdr;
        this.viewContainerRef = viewContainerRef;
        this.renderer = renderer;
        this.platform = platform;
        this.i18n = i18n;
        this.resizeService = resizeService;
        this.directionality = directionality;
        this._tdsModuleName = TDS_CONFIG_MODULE_NAME;
        this.copyable = false;
        this.editable = false;
        this.disabled = false;
        this.expandable = false;
        this.ellipsis = false;
        this.copyTooltips = undefined;
        this.copyIcons = ['tdsi-copy-fill', 'tdsi-tick-fill'];
        this.editTooltip = undefined;
        this.editIcon = 'tdsi-edit-fill';
        this.ellipsisRows = 1;
        this.contentChange = new EventEmitter();
        this.copy = new EventEmitter();
        this.expandChange = new EventEmitter();
        // This is not a two-way binding output with {@link ellipsis}
        this.ellipsisChange = new EventEmitter();
        this.expandableBtnElementCache = null;
        this.editing = false;
        this.cssEllipsis = false;
        this.isEllipsis = true;
        this.expanded = false;
        this.ellipsisStr = '...';
        this.dir = 'ltr';
        this.viewInit = false;
        this.rfaId = -1;
        this.destroy$ = new Subject();
        this.windowResizeSubscription = Subscription.EMPTY;
        this.document = document;
    }
    get hasEllipsisObservers() {
        return this.ellipsisChange.observers.length > 0;
    }
    get canCssEllipsis() {
        return this.ellipsis && this.cssEllipsis && !this.expanded && !this.hasEllipsisObservers;
    }
    get hasOperationsWithEllipsis() {
        return (this.copyable || this.editable || this.expandable) && this.ellipsis;
    }
    get onCopyText() {
        return (typeof this.copyText === 'string' ? this.copyText : this.content);
    }
    onTextCopy(text) {
        this.copy.emit(text);
    }
    onStartEditing() {
        this.editing = true;
    }
    onEndEditing(text) {
        this.editing = false;
        this.contentChange.emit(text);
        if (this.content === text) {
            this.renderOnNextFrame();
        }
        this.cdr.markForCheck();
    }
    onExpand(event) {
        if (event) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
        this.isEllipsis = false;
        this.expanded = true;
        this.expandChange.emit();
        this.ellipsisChange.emit(false);
    }
    canUseCSSEllipsis() {
        if (this.editable || this.copyable || this.expandable || this.suffix) {
            return false;
        }
        // make sure {@link ellipsisChange} works, will force use JS to calculations
        if (this.hasEllipsisObservers) {
            return false;
        }
        if (this.ellipsisRows === 1) {
            return isStyleSupport('textOverflow');
        }
        else {
            return isStyleSupport('webkitLineClamp');
        }
    }
    renderOnNextFrame() {
        cancelRequestAnimationFrame(this.rfaId);
        if (!this.viewInit || !this.ellipsis || this.ellipsisRows < 0 || this.expanded || !this.platform.isBrowser) {
            return;
        }
        this.rfaId = reqAnimFrame(() => {
            this.syncEllipsis();
        });
    }
    getOriginContentViewRef() {
        const viewRef = this.viewContainerRef.createEmbeddedView(this.contentTemplate, {
            content: this.content
        });
        viewRef.detectChanges();
        return {
            viewRef,
            removeView: () => {
                this.viewContainerRef.remove(this.viewContainerRef.indexOf(viewRef));
            }
        };
    }
    syncEllipsis() {
        if (this.cssEllipsis) {
            return;
        }
        const { viewRef, removeView } = this.getOriginContentViewRef();
        const fixedNodes = [this.textCopyRef, this.textEditRef]
            .filter(e => e && e.nativeElement)
            .map(e => e.nativeElement);
        const expandableBtnElement = this.getExpandableBtnElement();
        if (expandableBtnElement) {
            fixedNodes.push(expandableBtnElement);
        }
        const { contentNodes, text, ellipsis } = measure(this.host.nativeElement, this.ellipsisRows, viewRef.rootNodes, fixedNodes, this.ellipsisStr, this.suffix);
        removeView();
        this.ellipsisText = text;
        if (ellipsis !== this.isEllipsis) {
            this.isEllipsis = ellipsis;
            this.ellipsisChange.emit(ellipsis);
        }
        const ellipsisContainerNativeElement = this.ellipsisContainer.nativeElement;
        while (ellipsisContainerNativeElement.firstChild) {
            this.renderer.removeChild(ellipsisContainerNativeElement, ellipsisContainerNativeElement.firstChild);
        }
        contentNodes.forEach(n => {
            this.renderer.appendChild(ellipsisContainerNativeElement, n.cloneNode(true));
        });
        this.cdr.markForCheck();
    }
    // Need to create the element for calculation size before view init
    getExpandableBtnElement() {
        if (this.expandable) {
            const expandText = this.locale ? this.locale.expand : '';
            const cache = this.expandableBtnElementCache;
            if (!cache || cache.innerText === expandText) {
                const el = this.document.createElement('a');
                el.className = EXPAND_ELEMENT_CLASSNAME;
                el.innerText = expandText;
                this.expandableBtnElementCache = el;
            }
            return this.expandableBtnElementCache;
        }
        else {
            this.expandableBtnElementCache = null;
            return null;
        }
    }
    renderAndSubscribeWindowResize() {
        if (this.platform.isBrowser) {
            this.windowResizeSubscription.unsubscribe();
            this.cssEllipsis = this.canUseCSSEllipsis();
            this.renderOnNextFrame();
            this.windowResizeSubscription = this.resizeService
                .subscribe()
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => this.renderOnNextFrame());
        }
    }
    ngOnInit() {
        this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.locale = this.i18n.getLocaleData('Text');
            this.cdr.markForCheck();
        });
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
        this.dir = this.directionality.value;
    }
    ngAfterViewInit() {
        this.viewInit = true;
        this.renderAndSubscribeWindowResize();
    }
    ngOnChanges(changes) {
        const { copyable, editable, expandable, ellipsis, content, ellipsisRows, suffix } = changes;
        if (copyable || editable || expandable || ellipsis || content || ellipsisRows || suffix) {
            if (this.ellipsis) {
                if (this.expanded) {
                    this.windowResizeSubscription.unsubscribe();
                }
                else {
                    this.renderAndSubscribeWindowResize();
                }
            }
        }
    }
    onCollapse(event) {
        if (event) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
        if (this.expanded && !this.isEllipsis) {
            this.expanded = false;
            this.isEllipsis = true;
            this.ellipsis = true;
            this.ellipsisChange.emit(true);
            this.renderAndSubscribeWindowResize();
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.expandableBtnElementCache = null;
        this.windowResizeSubscription.unsubscribe();
    }
}
TDSTypographyComponent.ɵfac = function TDSTypographyComponent_Factory(t) { return new (t || TDSTypographyComponent)(i0.ɵɵdirectiveInject(i1$1.TDSConfigService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i2$2.Platform), i0.ɵɵdirectiveInject(i2.TDSI18nService), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i4$1.TDSResizeService), i0.ɵɵdirectiveInject(i5$1.Directionality, 8)); };
TDSTypographyComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTypographyComponent, selectors: [["tds-typography"], ["", "tds-typography", ""], ["p", "tds-paragraph", ""], ["span", "tds-text", ""], ["h1", "tds-title", ""], ["h2", "tds-title", ""], ["h3", "tds-title", ""], ["h4", "tds-title", ""]], viewQuery: function TDSTypographyComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(TDSTextEditComponent, 5);
        i0.ɵɵviewQuery(TDSTextCopyComponent, 5);
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 5);
        i0.ɵɵviewQuery(_c2, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textEditRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textCopyRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ellipsisContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.expandableBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    } }, hostVars: 34, hostBindings: function TDSTypographyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵstyleProp("-webkit-line-clamp", ctx.canCssEllipsis && ctx.ellipsisRows > 1 ? ctx.ellipsisRows : null);
        i0.ɵɵclassProp("tds-typography", !ctx.editing)("break-words", !ctx.editing)("tds-typography-rtl", ctx.dir === "rtl")("tds-typography-edit-content", ctx.editing)("text-neutral-1-400", ctx.color === "secondary")("text-warning-400", ctx.color === "warning")("text-error-400", ctx.color === "danger")("text-success-400", ctx.color === "success")("tds-typography-disabled", ctx.disabled)("tds-typography-ellipsis", ctx.ellipsis && !ctx.expanded)("tds-typography-single-line", ctx.ellipsis && ctx.ellipsisRows === 1)("whitespace-nowrap", ctx.ellipsis && ctx.ellipsisRows === 1)("tds-typography-ellipsis-single-line", ctx.canCssEllipsis && ctx.ellipsisRows === 1)("overflow-hidden", ctx.canCssEllipsis && ctx.ellipsisRows === 1)("overflow-ellipsis", ctx.canCssEllipsis && ctx.ellipsisRows === 1)("tds-typography-ellipsis-multiple-line", ctx.canCssEllipsis && ctx.ellipsisRows > 1);
    } }, inputs: { copyable: "copyable", editable: "editable", disabled: "disabled", expandable: "expandable", ellipsis: "ellipsis", copyTooltips: "copyTooltips", copyIcons: "copyIcons", editTooltip: "editTooltip", editIcon: "editIcon", content: "content", ellipsisRows: "ellipsisRows", color: "color", copyText: "copyText", suffix: "suffix", contentCollapse: "contentCollapse" }, outputs: { contentChange: "contentChange", copy: "copy", expandChange: "expandChange", ellipsisChange: "ellipsisChange" }, exportAs: ["tdsTypography"], features: [i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c4, decls: 5, vars: 3, consts: [["contentTemplate", ""], [4, "ngIf"], [3, "text", "icon", "tooltip", "endEditing", "startEditing", 4, "ngIf"], [3, "text", "tooltips", "icons", "textCopy", 4, "ngIf"], ["class", "inline-block", 3, "click", 4, "ngIf"], [1, "inline-block", 3, "click"], [4, "tdsStringTemplateOutlet"], [1, "tds-typography-collapse", "text-info-500", "cursor-pointer", "text-body-2"], [4, "ngIf", "ngIfElse"], ["jsEllipsis", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["ellipsisContainer", ""], ["class", "tds-typography-expand text-info-500 cursor-pointer text-body-2", 3, "click", 4, "ngIf"], [1, "tds-typography-expand", "text-info-500", "cursor-pointer", "text-body-2", 3, "click"], ["expandable", ""], [3, "text", "icon", "tooltip", "endEditing", "startEditing"], [3, "text", "tooltips", "icons", "textCopy"]], template: function TDSTypographyComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtemplate(0, TDSTypographyComponent_ng_template_0_Template, 3, 3, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtemplate(2, TDSTypographyComponent_ng_container_2_Template, 4, 2, "ng-container", 1);
        i0.ɵɵtemplate(3, TDSTypographyComponent_tds_text_edit_3_Template, 1, 3, "tds-text-edit", 2);
        i0.ɵɵtemplate(4, TDSTypographyComponent_tds_text_copy_4_Template, 1, 3, "tds-text-copy", 3);
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.editing);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.editable);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.copyable && !ctx.editing);
    } }, directives: [i2$1.NgIf, i4.TDSStringTemplateOutletDirective, i2$1.NgTemplateOutlet, TDSTextEditComponent, TDSTextCopyComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSTypographyComponent.prototype, "copyable", void 0);
__decorate([
    InputBoolean()
], TDSTypographyComponent.prototype, "editable", void 0);
__decorate([
    InputBoolean()
], TDSTypographyComponent.prototype, "disabled", void 0);
__decorate([
    InputBoolean()
], TDSTypographyComponent.prototype, "expandable", void 0);
__decorate([
    InputBoolean()
], TDSTypographyComponent.prototype, "ellipsis", void 0);
__decorate([
    WithConfig()
], TDSTypographyComponent.prototype, "copyTooltips", void 0);
__decorate([
    WithConfig()
], TDSTypographyComponent.prototype, "copyIcons", void 0);
__decorate([
    WithConfig()
], TDSTypographyComponent.prototype, "editTooltip", void 0);
__decorate([
    WithConfig()
], TDSTypographyComponent.prototype, "editIcon", void 0);
__decorate([
    WithConfig(),
    InputNumber()
], TDSTypographyComponent.prototype, "ellipsisRows", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTypographyComponent, [{
        type: Component,
        args: [{
                selector: `
  tds-typography,
  [tds-typography],
  p[tds-paragraph],
  span[tds-text],
  h1[tds-title], h2[tds-title], h3[tds-title], h4[tds-title]
  `,
                exportAs: 'tdsTypography',
                template: `
    <ng-template #contentTemplate let-content="content">
      <ng-content *ngIf="!content"></ng-content>
      {{ content }}    
      <a *ngIf="expandable && !isEllipsis" class="inline-block" (click)="onCollapse($event)">      
      <ng-container *tdsStringTemplateOutlet="contentCollapse">
      <span
        class="tds-typography-collapse text-info-500 cursor-pointer text-body-2">
        {{ contentCollapse }}
      </span>
     
      </ng-container>
    </a>
    </ng-template>
    <ng-container *ngIf="!editing">
      <ng-container
        *ngIf="
          expanded ||
            (!hasOperationsWithEllipsis && ellipsisRows === 1 && !hasEllipsisObservers) ||
            canCssEllipsis ||
            (suffix && expanded);
          else jsEllipsis
        "
      >
        <ng-template
          [ngTemplateOutlet]="contentTemplate"
          [ngTemplateOutletContext]="{ content: content }"
        ></ng-template>
        <ng-container *ngIf="suffix">{{ suffix }}</ng-container>
      </ng-container>
      <ng-template #jsEllipsis>
        <span #ellipsisContainer></span>
        <ng-container *ngIf="isEllipsis">{{ ellipsisStr }}</ng-container>
        <ng-container *ngIf="suffix">{{ suffix }}</ng-container>
        <a #expandable *ngIf="expandable && isEllipsis" class="tds-typography-expand text-info-500 cursor-pointer text-body-2" (click)="onExpand($event)">
          {{ locale?.expand }}
        </a>
      </ng-template>
    </ng-container>

    <tds-text-edit
      *ngIf="editable"
      [text]="content"
      [icon]="editIcon"
      [tooltip]="editTooltip"
      (endEditing)="onEndEditing($event)"
      (startEditing)="onStartEditing()"
     
    ></tds-text-edit>

    <tds-text-copy
      *ngIf="copyable && !editing"
      [text]="onCopyText"
      [tooltips]="copyTooltips"
      [icons]="copyIcons"
      (textCopy)="onTextCopy($event)"
    ></tds-text-copy>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false,
                host: {
                    '[class.tds-typography]': '!editing',
                    '[class.break-words]': '!editing',
                    '[class.tds-typography-rtl]': 'dir === "rtl"',
                    '[class.tds-typography-edit-content]': 'editing',
                    '[class.text-neutral-1-400]': 'color === "secondary"',
                    '[class.text-warning-400]': 'color === "warning"',
                    '[class.text-error-400]': 'color === "danger"',
                    '[class.text-success-400]': 'color === "success"',
                    '[class.tds-typography-disabled]': 'disabled',
                    '[class.tds-typography-ellipsis]': 'ellipsis && !expanded',
                    '[class.tds-typography-single-line]': 'ellipsis && ellipsisRows === 1',
                    '[class.whitespace-nowrap]': 'ellipsis && ellipsisRows === 1',
                    '[class.tds-typography-ellipsis-single-line]': 'canCssEllipsis && ellipsisRows === 1',
                    '[class.overflow-hidden]': 'canCssEllipsis && ellipsisRows === 1',
                    '[class.overflow-ellipsis]': 'canCssEllipsis && ellipsisRows === 1',
                    '[class.tds-typography-ellipsis-multiple-line]': 'canCssEllipsis && ellipsisRows > 1',
                    '[style.-webkit-line-clamp]': '(canCssEllipsis && ellipsisRows > 1) ? ellipsisRows : null'
                }
            }]
    }], function () { return [{ type: i1$1.TDSConfigService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.ViewContainerRef }, { type: i0.Renderer2 }, { type: i2$2.Platform }, { type: i2.TDSI18nService }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: i4$1.TDSResizeService }, { type: i5$1.Directionality, decorators: [{
                type: Optional
            }] }]; }, { copyable: [{
            type: Input
        }], editable: [{
            type: Input
        }], disabled: [{
            type: Input
        }], expandable: [{
            type: Input
        }], ellipsis: [{
            type: Input
        }], copyTooltips: [{
            type: Input
        }], copyIcons: [{
            type: Input
        }], editTooltip: [{
            type: Input
        }], editIcon: [{
            type: Input
        }], content: [{
            type: Input
        }], ellipsisRows: [{
            type: Input
        }], color: [{
            type: Input
        }], copyText: [{
            type: Input
        }], suffix: [{
            type: Input
        }], contentCollapse: [{
            type: Input
        }], contentChange: [{
            type: Output
        }], copy: [{
            type: Output
        }], expandChange: [{
            type: Output
        }], ellipsisChange: [{
            type: Output
        }], textEditRef: [{
            type: ViewChild,
            args: [TDSTextEditComponent, { static: false }]
        }], textCopyRef: [{
            type: ViewChild,
            args: [TDSTextCopyComponent, { static: false }]
        }], ellipsisContainer: [{
            type: ViewChild,
            args: ['ellipsisContainer', { static: false }]
        }], expandableBtn: [{
            type: ViewChild,
            args: ['expandable', { static: false }]
        }], contentTemplate: [{
            type: ViewChild,
            args: ['contentTemplate', { static: false }]
        }] }); })();

class TDSTypographyModule {
}
TDSTypographyModule.ɵfac = function TDSTypographyModule_Factory(t) { return new (t || TDSTypographyModule)(); };
TDSTypographyModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSTypographyModule });
TDSTypographyModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            BidiModule,
            CommonModule,
            TDSToolTipModule,
            TDSInputModule,
            TDSI18nModule,
            ClipboardModule,
            TDSOutletModule,
            TDSButtonModule
        ], PlatformModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTypographyModule, [{
        type: NgModule,
        args: [{
                imports: [
                    BidiModule,
                    CommonModule,
                    TDSToolTipModule,
                    TDSInputModule,
                    TDSI18nModule,
                    ClipboardModule,
                    TDSOutletModule,
                    TDSButtonModule
                ],
                exports: [TDSTypographyComponent, TDSTextCopyComponent, TDSTextEditComponent, PlatformModule],
                declarations: [TDSTypographyComponent, TDSTextCopyComponent, TDSTextEditComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSTypographyModule, { declarations: [TDSTypographyComponent, TDSTextCopyComponent, TDSTextEditComponent], imports: [BidiModule,
        CommonModule,
        TDSToolTipModule,
        TDSInputModule,
        TDSI18nModule,
        ClipboardModule,
        TDSOutletModule,
        TDSButtonModule], exports: [TDSTypographyComponent, TDSTextCopyComponent, TDSTextEditComponent, PlatformModule] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSTextCopyComponent, TDSTextEditComponent, TDSTypographyComponent, TDSTypographyModule };
//# sourceMappingURL=tds-ui-typography.mjs.map
