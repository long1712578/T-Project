import { __decorate } from 'tslib';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import * as i1 from '@angular/cdk/platform';
import { getSupportedInputTypes } from '@angular/cdk/platform';
import * as i0 from '@angular/core';
import { InjectionToken, Directive, Optional, Self, Inject, Input, HostListener, EventEmitter, Output, NgModule } from '@angular/core';
import { Subject, fromEvent } from 'rxjs';
import * as i6 from 'tds-ui/form-field';
import { TDS_FORM_FIELD, TDSFormFieldControl, TDSFormFieldModule } from 'tds-ui/form-field';
import * as i3 from 'tds-ui/shared/common';
import { mixinErrorState, ErrorStateMatcher } from 'tds-ui/shared/common';
import { InputBoolean } from 'tds-ui/shared/utility';
import * as i2 from '@angular/forms';
import { ReactiveFormsModule, FormsModule } from '@angular/forms';
import * as i4 from '@angular/cdk/text-field';
import * as i5 from '@angular/cdk/a11y';
import { takeUntil, debounceTime, distinctUntilChanged } from 'rxjs/operators';
import * as i2$1 from 'tds-ui/core/services';

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** @docs-private */
function getTDSInputUnsupportedTypeError(type) {
    return Error(`Input type "${type}" isn't supported by tdsInput.`);
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * This token is used to inject the object whose value should be set into `MatInput`. If none is
 * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide
 * themselves for this token, in order to make `MatInput` delegate the getting and setting of the
 * value to them.
 */
const TDS_INPUT_VALUE_ACCESSOR = new InjectionToken('TDS_INPUT_VALUE_ACCESSOR');

// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.
const TA_INPUT_INVALID_TYPES = [
    'button',
    'checkbox',
    'file',
    'hidden',
    'image',
    'radio',
    'range',
    'reset',
    'submit'
];
let nextUniqueId = 0;
// Boilerplate for applying mixins to MatInput.
/** @docs-private */
class TDSInputBase {
    constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, 
    /** @docs-private */
    ngControl) {
        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this.ngControl = ngControl;
    }
}
const _TDSInputMixinBase = mixinErrorState(TDSInputBase);
/** Directive that allows a native input to work inside a `TDSFormField`. */
class TDSInput extends _TDSInputMixinBase {
    constructor(_elementRef, _platform, 
    /** @docs-private */
    ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, host, focusMonitor, ngZone, 
    // TODO: Remove this once the legacy appearance has been removed. We only need
    // to inject the form-field for determining whether the placeholder has been promoted.
    _formField) {
        super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);
        this._elementRef = _elementRef;
        this._platform = _platform;
        this.ngControl = ngControl;
        this._autofillMonitor = _autofillMonitor;
        this.host = host;
        this.focusMonitor = focusMonitor;
        this._formField = _formField;
        this._uid = `tds-input-${nextUniqueId++}`;
        /**
         * Implemented as part of TDSFormFieldControl.
         * @docs-private
         */
        this.focused = false;
        /**
         * Implemented as part of TDSFormFieldControl.
         * @docs-private
         */
        this.stateChanges = new Subject();
        /**
         * Implemented as part of TDSFormFieldControl.
         * @docs-private
         */
        this.controlType = 'tds-input';
        /**
         * Implemented as part of TDSFormFieldControl.
         * @docs-private
         */
        this.autofilled = false;
        this._size = 'md';
        this._disabled = false;
        this._required = false;
        this._type = 'text';
        this.autofocus = false;
        this._readonly = false;
        this._neverEmptyInputTypes = [
            'date',
            'datetime',
            'datetime-local',
            'month',
            'time',
            'week'
        ].filter(t => getSupportedInputTypes().has(t));
        const element = this._elementRef.nativeElement;
        const nodeName = element.nodeName.toLowerCase();
        // If no input value accessor was explicitly specified, use the element as the input value
        // accessor.
        this._inputValueAccessor = inputValueAccessor || element;
        this._previousNativeValue = this.value;
        // Force setter to be called in case id was not specified.
        this.id = this.id;
        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete
        // key. In order to get around this we need to "jiggle" the caret loose. Since this bug only
        // exists on iOS, we only bother to install the listener on iOS.
        if (_platform.IOS) {
            ngZone.runOutsideAngular(() => {
                _elementRef.nativeElement.addEventListener('keyup', (event) => {
                    let el = event.target;
                    if (!el.value && !el.selectionStart && !el.selectionEnd) {
                        // Note: Just setting `0, 0` doesn't fix the issue. Setting
                        // `1, 1` fixes it for the first time that you type text and
                        // then hold delete. Toggling to `1, 1` and then back to
                        // `0, 0` seems to completely fix it.
                        el.setSelectionRange(1, 1);
                        el.setSelectionRange(0, 0);
                    }
                });
            });
        }
        this._isServer = !this._platform.isBrowser;
        this._isNativeSelect = nodeName === 'select';
        this._isTextarea = nodeName === 'textarea';
        if (this._isNativeSelect) {
            this.controlType = element.multiple ? 'tds-native-select-multiple' :
                'tds-native-select';
        }
    }
    get size() {
        return this._size;
    }
    set size(value) {
        if (this._size != value) {
            this._size = value;
            this.stateChanges.next();
        }
    }
    /**
     * Implemented as part of TDSFormFieldControl.
     * @docs-private
     */
    get disabled() {
        if (this.ngControl && this.ngControl.disabled !== null) {
            return this.ngControl.disabled;
        }
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        // Browsers may not fire the blur event if the input is disabled too quickly.
        // Reset from here to ensure that the element doesn't become stuck.
        if (this.focused) {
            this.focused = false;
            this.stateChanges.next();
        }
    }
    /**
     * Implemented as part of TDSFormFieldControl.
     * @docs-private
     */
    get id() { return this._id; }
    set id(value) { this._id = value || this._uid; }
    /**
     * Implemented as part of TDSFormFieldControl.
     * @docs-private
     */
    get required() { return this._required; }
    set required(value) { this._required = coerceBooleanProperty(value); }
    /** Input type of the element. */
    get type() { return this._type; }
    set type(value) {
        this._type = value || 'text';
        this._validateType();
        // When using Angular inputs, developers are no longer able to set the properties on the native
        // input element. To ensure that bindings for `type` work, we need to sync the setter
        // with the native property. Textarea elements don't support the type property or attribute.
        if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {
            this._elementRef.nativeElement.type = this._type;
        }
    }
    /**
     * Implemented as part of TDSFormFieldControl.
     * @docs-private
     */
    get value() { return this._inputValueAccessor.value; }
    set value(value) {
        if (value !== this.value) {
            this._inputValueAccessor.value = value;
            this.stateChanges.next();
        }
    }
    /** Whether the element is readonly. */
    get readonly() { return this._readonly; }
    set readonly(value) { this._readonly = coerceBooleanProperty(value); }
    ngAfterViewInit() {
        if (this._platform.isBrowser) {
            this._autofillMonitor.monitor(this.host).subscribe(event => {
                this.autofilled = event.isAutofilled;
                this.stateChanges.next();
            });
            this.focusMonitor.monitor(this.host, true).subscribe(event => {
                this._focusChanged(event != null);
            });
            if (this.autofocus && !this.focused && (!this.readonly)) {
                this.focused = true;
                this.focus();
                this.stateChanges.next();
            }
        }
        this.setPaddingRight();
        this.setpaddingLeft();
        this.setStyle();
    }
    ngOnChanges() {
        this.setStyle();
        this.stateChanges.next();
    }
    ngOnDestroy() {
        this.stateChanges.complete();
        if (this._platform.isBrowser) {
            this._autofillMonitor.stopMonitoring(this.host);
            this.focusMonitor.stopMonitoring(this.host);
        }
    }
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
        // We need to dirty-check the native element's value, because there are some cases where
        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're
        // updating the value using `emitEvent: false`).
        this._dirtyCheckNativeValue();
    }
    /** Focuses the input. */
    focus(options) {
        this._elementRef.nativeElement.focus(options);
    }
    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
    // In Ivy the `host` bindings will be merged when this class is extended, whereas in
    // ViewEngine they're overwritten.
    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
    /** Callback for the cases where the focused state of the input changes. */
    // tslint:disable:no-host-decorator-in-concrete
    // @HostListener('focus', ['true'])
    // @HostListener('blur', ['false'])
    // tslint:enable:no-host-decorator-in-concrete
    _focusChanged(isFocused) {
        if (isFocused !== this.focused && (!this.readonly || !isFocused)) {
            this.focused = isFocused;
            this.stateChanges.next();
        }
    }
    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
    // In Ivy the `host` bindings will be merged when this class is extended, whereas in
    // ViewEngine they're overwritten.
    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
    // tslint:disable-next-line:no-host-decorator-in-concrete
    _onInput() {
        // This is a noop function and is used to let Angular know whenever the value changes.
        // Angular will run a new change detection each time the `input` event has been dispatched.
        // It's necessary that Angular recognizes the value change, because when floatingLabel
        // is set to false and Angular forms aren't used, the placeholder won't recognize the
        // value changes and will not disappear.
        // Listening to the input event wouldn't be necessary when the input is using the
        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.
    }
    /** Does some manual dirty checking on the native input `value` property. */
    _dirtyCheckNativeValue() {
        const newValue = this._elementRef.nativeElement.value;
        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this.stateChanges.next();
        }
    }
    /** Make sure the input is a supported type. */
    _validateType() {
        if (TA_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {
            throw getTDSInputUnsupportedTypeError(this._type);
        }
    }
    /** Checks whether the input type is one of the types that are never empty. */
    _isNeverEmpty() {
        return this._neverEmptyInputTypes.indexOf(this._type) > -1;
    }
    /** Checks whether the input is invalid based on the native validation. */
    _isBadInput() {
        // The `validity` property won't be present on platform-server.
        let validity = this._elementRef.nativeElement.validity;
        return validity && validity.badInput;
    }
    /**
     * Implemented as part of TDSFormFieldControl.
     * @docs-private
     */
    get empty() {
        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&
            !this.autofilled;
    }
    /**
     * Implemented as part of TDSFormFieldControl.
     * @docs-private
     */
    get shouldLabelFloat() {
        if (this._isNativeSelect) {
            // For a single-selection `<select>`, the label should float when the selected option has
            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid
            // overlapping the label with the options.
            const selectElement = this._elementRef.nativeElement;
            const firstOption = selectElement.options[0];
            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be
            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.
            return this.focused || selectElement.multiple || !this.empty ||
                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);
        }
        else {
            return this.focused || !this.empty;
        }
    }
    /**
     * Implemented as part of TDSFormFieldControl.
     * @docs-private
     */
    setDescribedByIds(ids) {
        if (ids.length) {
            this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));
        }
        else {
            this._elementRef.nativeElement.removeAttribute('aria-describedby');
        }
    }
    /**
     * Implemented as part of TDSFormFieldControl.
     * @docs-private
     */
    onContainerClick() {
        // Do not re-focus the input element if the element is already focused. Otherwise it can happen
        // that someone clicks on a time input and the cursor resets to the "hours" field while the
        // "minutes" field was actually clicked. See: https://github.com/angular/components/issues/12849
        // if (!this.focused) {
        //   this.focus();
        // }
    }
    setStyle() {
        switch (this.size) {
            case 'sm':
                this._elementRef.nativeElement.classList.add("my-1");
                break;
            case 'md':
                this._elementRef.nativeElement.classList.add("my-1.5");
                break;
            case 'lg':
                this._elementRef.nativeElement.classList.add("my-2");
                break;
            default:
                this._elementRef.nativeElement.classList.add("my-1.5");
                break;
        }
    }
    setPaddingRight() {
        if (this._hasPaddingRight()) {
            switch (this.size) {
                case 'sm':
                    this._elementRef.nativeElement.classList.add("pr-2.5");
                    break;
                case 'md':
                    this._elementRef.nativeElement.classList.add("pr-3");
                    break;
                case 'lg':
                    this._elementRef.nativeElement.classList.add("pr-4");
                    break;
                default:
                    this._elementRef.nativeElement.classList.add("pr-3");
                    break;
            }
        }
        else {
            this._elementRef.nativeElement.classList.add("pr-0");
        }
    }
    _hasPaddingRight() {
        if (!this._formField) {
            return true;
        }
        return !(this._formField._hasAddOnRightChildren() || this._formField._hasSuffixChildren());
    }
    setpaddingLeft() {
        if (this._hasAddOneftChildren()) {
            this._elementRef.nativeElement.classList.add("pl-2");
        }
        else if (!this._hasPrefixChildren()) {
            switch (this.size) {
                case 'sm':
                    this._elementRef.nativeElement.classList.add("pl-2.5");
                    break;
                case 'md':
                    this._elementRef.nativeElement.classList.add("pl-3");
                    break;
                case 'lg':
                    this._elementRef.nativeElement.classList.add("pl-4");
                    break;
                default:
                    this._elementRef.nativeElement.classList.add("pr-3");
                    break;
            }
        }
    }
    _hasAddOneftChildren() {
        if (!this._formField) {
            return false;
        }
        return this._formField._hasAddOnLeftChildren();
    }
    _hasPrefixChildren() {
        if (!this._formField) {
            return false;
        }
        return this._formField._hasPrefixChildren();
    }
}
TDSInput.ɵfac = function TDSInput_Factory(t) { return new (t || TDSInput)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.Platform), i0.ɵɵdirectiveInject(i2.NgControl, 10), i0.ɵɵdirectiveInject(i2.NgForm, 8), i0.ɵɵdirectiveInject(i2.FormGroupDirective, 8), i0.ɵɵdirectiveInject(i3.ErrorStateMatcher), i0.ɵɵdirectiveInject(TDS_INPUT_VALUE_ACCESSOR, 10), i0.ɵɵdirectiveInject(i4.AutofillMonitor), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i5.FocusMonitor), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(TDS_FORM_FIELD, 8)); };
TDSInput.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSInput, selectors: [["input", "tdsInput", ""], ["textarea", "tdsInput", ""], ["select", "tdsNativeControl", ""], ["input", "tdsNativeControl", ""], ["textarea", "tdsNativeControl", ""]], hostAttrs: [1, "flex", "items-center", "text-body-2", "tds-input-element", "tds-form-field-autofill-control", "focus:outline-none", "focus:border-transparent", "shadow-none", "border-0", "bg-transparent", "text-current", "p-0", "m-0", "w-full", "outline-none", "box-border", "placeholder:text-neutral-1-400", "dark:placeholder:text-d-neutral-1-400"], hostVars: 15, hostBindings: function TDSInput_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("input", function TDSInput_input_HostBindingHandler() { return ctx._onInput(); });
    } if (rf & 2) {
        i0.ɵɵhostProperty("disabled", ctx.disabled)("required", ctx.required);
        i0.ɵɵattribute("id", ctx.id)("data-placeholder", ctx.placeholder)("placeholder", ctx.placeholder)("readonly", ctx.readonly && !ctx._isNativeSelect || null)("aria-invalid", ctx.errorState && !ctx.empty)("aria-required", ctx.required)("autofocus", ctx.autofocus ? "autofocus" : null);
        i0.ɵɵstyleProp("box-shadow", "unset");
        i0.ɵɵclassProp("tds-input-server", ctx._isServer)("cursor-not-allowed", ctx.disabled);
    } }, inputs: { size: "size", disabled: "disabled", id: "id", placeholder: "placeholder", required: "required", type: "type", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"], value: "value", autofocus: "autofocus", readonly: "readonly" }, exportAs: ["tdsInput"], features: [i0.ɵɵProvidersFeature([{ provide: TDSFormFieldControl, useExisting: TDSInput }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature] });
__decorate([
    InputBoolean()
], TDSInput.prototype, "autofocus", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSInput, [{
        type: Directive,
        args: [{
                selector: `input[tdsInput], textarea[tdsInput], select[tdsNativeControl],
      input[tdsNativeControl], textarea[tdsNativeControl]`,
                exportAs: 'tdsInput',
                host: {
                    'class': 'flex  items-center text-body-2 tds-input-element tds-form-field-autofill-control focus:outline-none focus:border-transparent shadow-none border-0 bg-transparent text-current  p-0  m-0 w-full outline-none  box-border placeholder:text-neutral-1-400 dark:placeholder:text-d-neutral-1-400',
                    '[class.tds-input-server]': '_isServer',
                    '[class.cursor-not-allowed]': 'disabled',
                    // Native input properties that are overwritten by Angular inputs need to be synced with
                    // the native input element. Otherwise property bindings for those don't work.
                    '[attr.id]': 'id',
                    // At the time of writing, we have a lot of customer tests that look up the input based on its
                    // placeholder. Since we sometimes omit the placeholder attribute from the DOM to prevent screen
                    // readers from reading it twice, we have to keep it somewhere in the DOM for the lookup.
                    '[attr.data-placeholder]': 'placeholder',
                    '[attr.placeholder]': 'placeholder',
                    '[disabled]': 'disabled',
                    '[required]': 'required',
                    '[attr.readonly]': 'readonly && !_isNativeSelect || null',
                    // Only mark the input as invalid for assistive technology if it has a value since the
                    // state usually overlaps with `aria-required` when the input is empty and can be redundant.
                    '[attr.aria-invalid]': 'errorState && !empty',
                    '[attr.aria-required]': 'required',
                    '[style.boxShadow]': '"unset"',
                    '[attr.autofocus]': "autofocus ? 'autofocus' : null"
                },
                providers: [{ provide: TDSFormFieldControl, useExisting: TDSInput }],
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i1.Platform }, { type: i2.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i2.NgForm, decorators: [{
                type: Optional
            }] }, { type: i2.FormGroupDirective, decorators: [{
                type: Optional
            }] }, { type: i3.ErrorStateMatcher }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Self
            }, {
                type: Inject,
                args: [TDS_INPUT_VALUE_ACCESSOR]
            }] }, { type: i4.AutofillMonitor }, { type: i0.ElementRef }, { type: i5.FocusMonitor }, { type: i0.NgZone }, { type: i6.TDSFormField, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TDS_FORM_FIELD]
            }] }]; }, { size: [{
            type: Input
        }], disabled: [{
            type: Input
        }], id: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], required: [{
            type: Input
        }], type: [{
            type: Input
        }], errorStateMatcher: [{
            type: Input
        }], userAriaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }], value: [{
            type: Input
        }], autofocus: [{
            type: Input
        }], readonly: [{
            type: Input
        }], _onInput: [{
            type: HostListener,
            args: ['input']
        }] }); })();

class TDSAutosizeDirective {
    constructor(elementRef, ngZone, platform, resizeService) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.platform = platform;
        this.resizeService = resizeService;
        this.autosize = false;
        this.el = this.elementRef.nativeElement;
        this.maxHeight = null;
        this.minHeight = null;
        this.destroy$ = new Subject();
        this.inputGap = 10;
    }
    set tdsAutosize(value) {
        const isAutoSizeType = (data) => typeof data !== 'string' && typeof data !== 'boolean' && (!!data.maxRows || !!data.minRows);
        if (typeof value === 'string' || value === true) {
            this.autosize = true;
        }
        else if (isAutoSizeType(value)) {
            this.autosize = true;
            this.minRows = value.minRows;
            this.maxRows = value.maxRows;
            this.maxHeight = this.setMaxHeight();
            this.minHeight = this.setMinHeight();
        }
    }
    resizeToFitContent(force = false) {
        this.cacheTextareaLineHeight();
        // If we haven't determined the line-height yet, we know we're still hidden and there's no point
        // in checking the height of the textarea.
        if (!this.cachedLineHeight) {
            return;
        }
        const textarea = this.el;
        const value = textarea.value;
        // Only resize if the value or minRows have changed since these calculations can be expensive.
        if (!force && this.minRows === this.previousMinRows && value === this.previousValue) {
            return;
        }
        const placeholderText = textarea.placeholder;
        // Reset the textarea height to auto in order to shrink back to its default size.
        // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.
        // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight
        // value. To ensure that the scrollHeight is not bigger than the content, the placeholders
        // need to be removed temporarily.
        textarea.classList.add('nz-textarea-autosize-measuring');
        textarea.placeholder = '';
        let height = Math.round((textarea.scrollHeight - this.inputGap) / this.cachedLineHeight) * this.cachedLineHeight +
            this.inputGap;
        if (this.maxHeight !== null && height > this.maxHeight) {
            height = this.maxHeight;
        }
        if (this.minHeight !== null && height < this.minHeight) {
            height = this.minHeight;
        }
        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.
        textarea.style.height = `${height}px`;
        textarea.classList.remove('nz-textarea-autosize-measuring');
        textarea.placeholder = placeholderText;
        // On Firefox resizing the textarea will prevent it from scrolling to the caret position.
        // We need to re-set the selection in order for it to scroll to the proper position.
        if (typeof requestAnimationFrame !== 'undefined') {
            this.ngZone.runOutsideAngular(() => requestAnimationFrame(() => {
                const { selectionStart, selectionEnd } = textarea;
                // IE will throw an "Unspecified error" if we try to set the selection range after the
                // element has been removed from the DOM. Assert that the directive hasn't been destroyed
                // between the time we requested the animation frame and when it was executed.
                // Also note that we have to assert that the textarea is focused before we set the
                // selection range. Setting the selection range on a non-focused textarea will cause
                // it to receive focus on IE and Edge.
                if (!this.destroy$.isStopped && document.activeElement === textarea) {
                    textarea.setSelectionRange(selectionStart, selectionEnd);
                }
            }));
        }
        this.previousValue = value;
        this.previousMinRows = this.minRows;
    }
    cacheTextareaLineHeight() {
        if (this.cachedLineHeight >= 0 || !this.el.parentNode) {
            return;
        }
        // Use a clone element because we have to override some styles.
        const textareaClone = this.el.cloneNode(false);
        textareaClone.rows = 1;
        // Use `position: absolute` so that this doesn't cause a browser layout and use
        // `visibility: hidden` so that nothing is rendered. Clear any other styles that
        // would affect the height.
        textareaClone.style.position = 'absolute';
        textareaClone.style.visibility = 'hidden';
        textareaClone.style.border = 'none';
        textareaClone.style.padding = '0';
        textareaClone.style.height = '';
        textareaClone.style.minHeight = '';
        textareaClone.style.maxHeight = '';
        // In Firefox it happens that textarea elements are always bigger than the specified amount
        // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.
        // As a workaround that removes the extra space for the scrollbar, we can just set overflow
        // to hidden. This ensures that there is no invalid calculation of the line height.
        // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654
        textareaClone.style.overflow = 'hidden';
        this.el.parentNode.appendChild(textareaClone);
        this.cachedLineHeight = textareaClone.clientHeight - this.inputGap;
        this.el.parentNode.removeChild(textareaClone);
        // Min and max heights have to be re-calculated if the cached line height changes
        this.maxHeight = this.setMaxHeight();
        this.minHeight = this.setMinHeight();
    }
    setMinHeight() {
        const minHeight = this.minRows && this.cachedLineHeight ? this.minRows * this.cachedLineHeight + this.inputGap : null;
        if (minHeight !== null) {
            this.el.style.minHeight = `${minHeight}px`;
        }
        return minHeight;
    }
    setMaxHeight() {
        const maxHeight = this.maxRows && this.cachedLineHeight ? this.maxRows * this.cachedLineHeight + this.inputGap : null;
        if (maxHeight !== null) {
            this.el.style.maxHeight = `${maxHeight}px`;
        }
        return maxHeight;
    }
    noopInputHandler() {
        // no-op handler that ensures we're running change detection on input events.
    }
    ngAfterViewInit() {
        if (this.autosize && this.platform.isBrowser) {
            this.resizeToFitContent();
            this.resizeService
                .subscribe()
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => this.resizeToFitContent(true));
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    ngDoCheck() {
        if (this.autosize && this.platform.isBrowser) {
            this.resizeToFitContent();
        }
    }
}
TDSAutosizeDirective.ɵfac = function TDSAutosizeDirective_Factory(t) { return new (t || TDSAutosizeDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.Platform), i0.ɵɵdirectiveInject(i2$1.TDSResizeService)); };
TDSAutosizeDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSAutosizeDirective, selectors: [["textarea", "tdsAutosize", ""]], hostAttrs: ["rows", "1"], hostBindings: function TDSAutosizeDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("input", function TDSAutosizeDirective_input_HostBindingHandler() { return ctx.noopInputHandler(); });
    } }, inputs: { tdsAutosize: "tdsAutosize" }, exportAs: ["tdsAutosize"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSAutosizeDirective, [{
        type: Directive,
        args: [{
                selector: 'textarea[tdsAutosize]',
                exportAs: 'tdsAutosize',
                host: {
                    // Textarea elements that have the directive applied should have a single row by default.
                    // Browsers normally show two rows by default and therefore this limits the minRows binding.
                    rows: '1',
                    '(input)': 'noopInputHandler()'
                }
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i1.Platform }, { type: i2$1.TDSResizeService }]; }, { tdsAutosize: [{
            type: Input
        }] }); })();

class TDSDisabledControlDirective {
    constructor(ngControl) {
        this.ngControl = ngControl;
    }
    set disabledControl(state) {
        const action = state ? 'disable' : 'enable';
        this.ngControl.control[action]();
    }
}
TDSDisabledControlDirective.ɵfac = function TDSDisabledControlDirective_Factory(t) { return new (t || TDSDisabledControlDirective)(i0.ɵɵdirectiveInject(i2.NgControl)); };
TDSDisabledControlDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSDisabledControlDirective, selectors: [["", "formControlName", ""], ["", "formControl", "", "disabledControl", ""]], inputs: { disabledControl: "disabledControl" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSDisabledControlDirective, [{
        type: Directive,
        args: [{
                selector: '([formControlName], [formControl])[disabledControl]',
            }]
    }], function () { return [{ type: i2.NgControl }]; }, { disabledControl: [{
            type: Input
        }] }); })();

class TDSInputDebounceDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.tdsInputDebounce = 300;
        this.inputKeyup = new EventEmitter();
        this.destroy$ = new Subject();
    }
    ngOnInit() {
        const eventStream = fromEvent(this.elementRef.nativeElement, 'keyup').pipe(debounceTime(this.tdsInputDebounce), distinctUntilChanged());
        eventStream.pipe(takeUntil(this.destroy$)).subscribe(event => this.inputKeyup.emit({
            value: this.elementRef.nativeElement.value,
            keyupEvent: event
        }));
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
TDSInputDebounceDirective.ɵfac = function TDSInputDebounceDirective_Factory(t) { return new (t || TDSInputDebounceDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSInputDebounceDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSInputDebounceDirective, selectors: [["", "tdsInputDebounce", ""]], inputs: { tdsInputDebounce: "tdsInputDebounce" }, outputs: { inputKeyup: "inputKeyup" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSInputDebounceDirective, [{
        type: Directive,
        args: [{
                selector: '[tdsInputDebounce]'
            }]
    }], function () { return [{ type: i0.ElementRef }]; }, { tdsInputDebounce: [{
            type: Input
        }], inputKeyup: [{
            type: Output
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class TDSInputModule {
}
TDSInputModule.ɵfac = function TDSInputModule_Factory(t) { return new (t || TDSInputModule)(); };
TDSInputModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSInputModule });
TDSInputModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [ErrorStateMatcher], imports: [[
            ReactiveFormsModule,
            FormsModule,
            TDSFormFieldModule,
        ], TDSFormFieldModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSInputModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TDSInput,
                    TDSDisabledControlDirective,
                    TDSAutosizeDirective,
                    TDSInputDebounceDirective
                ],
                imports: [
                    ReactiveFormsModule,
                    FormsModule,
                    TDSFormFieldModule,
                ],
                exports: [
                    TDSFormFieldModule,
                    TDSInput,
                    TDSDisabledControlDirective,
                    TDSAutosizeDirective,
                    TDSInputDebounceDirective
                ],
                providers: [ErrorStateMatcher],
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSInputModule, { declarations: [TDSInput,
        TDSDisabledControlDirective,
        TDSAutosizeDirective,
        TDSInputDebounceDirective], imports: [ReactiveFormsModule,
        FormsModule,
        TDSFormFieldModule], exports: [TDSFormFieldModule,
        TDSInput,
        TDSDisabledControlDirective,
        TDSAutosizeDirective,
        TDSInputDebounceDirective] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSAutosizeDirective, TDSDisabledControlDirective, TDSInput, TDSInputDebounceDirective, TDSInputModule, TDS_INPUT_VALUE_ACCESSOR, getTDSInputUnsupportedTypeError };
//# sourceMappingURL=tds-ui-tds-input.mjs.map
