import { __decorate } from 'tslib';
import * as i0 from '@angular/core';
import { Directive, Optional, Self, Input, Component, ViewEncapsulation, ChangeDetectionStrategy, ContentChildren, isDevMode, ContentChild, NgModule } from '@angular/core';
import { Subject, merge, EMPTY } from 'rxjs';
import { filter, takeUntil, startWith, switchMap, mergeMap, map } from 'rxjs/operators';
import { InputBoolean } from 'tds-ui/shared/utility';
import * as i1 from '@angular/forms';
import * as i2 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';
import * as i1$1 from '@angular/cdk/a11y';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2$1 from 'tds-ui/core/outlet';
import { TDSOutletModule } from 'tds-ui/core/outlet';
import * as i1$2 from '@angular/cdk/platform';
import { PlatformModule } from '@angular/cdk/platform';
import * as i2$2 from 'tds-ui/core/services';
import { isNotNil } from 'tds-ui/core/util';

class TDSInputDirective {
    constructor(ngControl, renderer, elementRef, directionality) {
        this.ngControl = ngControl;
        this.directionality = directionality;
        this.tdsBorderless = false;
        this.tdsSize = 'md';
        this._disabled = false;
        this.disabled$ = new Subject();
        this.dir = 'ltr';
        this.destroy$ = new Subject();
        renderer.addClass(elementRef.nativeElement, 'tds-input');
    }
    get disabled() {
        if (this.ngControl && this.ngControl.disabled !== null) {
            return this.ngControl.disabled;
        }
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = value != null && `${value}` !== 'false';
    }
    ngOnInit() {
        if (this.ngControl) {
            this.ngControl.statusChanges
                ?.pipe(filter(() => this.ngControl.disabled !== null), takeUntil(this.destroy$))
                .subscribe(() => {
                this.disabled$.next(this.ngControl.disabled);
            });
        }
        this.dir = this.directionality.value;
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
        });
    }
    ngOnChanges(changes) {
        const { disabled } = changes;
        if (disabled) {
            this.disabled$.next(this.disabled);
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
TDSInputDirective.ɵfac = function TDSInputDirective_Factory(t) { return new (t || TDSInputDirective)(i0.ɵɵdirectiveInject(i1.NgControl, 10), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.Directionality, 8)); };
TDSInputDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSInputDirective, selectors: [["input", "tds-input", ""], ["textarea", "tds-input", ""]], hostVars: 15, hostBindings: function TDSInputDirective_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("disabled", ctx.disabled || null);
        i0.ɵɵclassProp("tds-input-disabled", ctx.disabled)("tds-input-borderless", ctx.tdsBorderless)("tds-input-rtl", ctx.dir === "rtl")("tds-input-sm", ctx.tdsSize === "sm")("tds-input-md", ctx.tdsSize === "md")("tds-input-lg", ctx.tdsSize === "lg")("tds-input-xl", ctx.tdsSize === "xl");
    } }, inputs: { tdsBorderless: "tdsBorderless", tdsSize: "tdsSize", disabled: "disabled" }, exportAs: ["tdsinput"], features: [i0.ɵɵNgOnChangesFeature] });
__decorate([
    InputBoolean()
], TDSInputDirective.prototype, "tdsBorderless", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSInputDirective, [{
        type: Directive,
        args: [{
                selector: 'input[tds-input],textarea[tds-input]',
                exportAs: 'tdsinput',
                host: {
                    '[class.tds-input-disabled]': 'disabled',
                    '[class.tds-input-borderless]': 'tdsBorderless',
                    '[attr.disabled]': 'disabled || null',
                    '[class.tds-input-rtl]': `dir=== 'rtl'`,
                    '[class.tds-input-sm]': `tdsSize=== 'sm'`,
                    '[class.tds-input-md]': `tdsSize=== 'md'`,
                    '[class.tds-input-lg]': `tdsSize=== 'lg'`,
                    '[class.tds-input-xl]': `tdsSize=== 'xl'`
                }
            }]
    }], function () { return [{ type: i1.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i2.Directionality, decorators: [{
                type: Optional
            }] }]; }, { tdsBorderless: [{
            type: Input
        }], tdsSize: [{
            type: Input
        }], disabled: [{
            type: Input
        }] }); })();

const _c0$2 = ["tds-input-group-slot", ""];
function TDSInputGroupSlotComponent_i_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "i");
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r0.icon);
} }
function TDSInputGroupSlotComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.template);
} }
class TDSInputGroupSlotComponent {
    constructor() {
        this.icon = null;
        this.type = null;
        this.template = null;
    }
}
TDSInputGroupSlotComponent.ɵfac = function TDSInputGroupSlotComponent_Factory(t) { return new (t || TDSInputGroupSlotComponent)(); };
TDSInputGroupSlotComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSInputGroupSlotComponent, selectors: [["", "tds-input-group-slot", ""]], hostVars: 6, hostBindings: function TDSInputGroupSlotComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("tds-input-group-addon", ctx.type === "addon")("tds-input-prefix", ctx.type === "prefix")("tds-input-suffix", ctx.type === "suffix");
    } }, inputs: { icon: "icon", type: "type", template: "template" }, attrs: _c0$2, decls: 2, vars: 2, consts: [[3, "class", 4, "ngIf"], [4, "tdsStringTemplateOutlet"]], template: function TDSInputGroupSlotComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TDSInputGroupSlotComponent_i_0_Template, 1, 2, "i", 0);
        i0.ɵɵtemplate(1, TDSInputGroupSlotComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.icon);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("tdsStringTemplateOutlet", ctx.template);
    } }, directives: [i3.NgIf, i2$1.TDSStringTemplateOutletDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSInputGroupSlotComponent, [{
        type: Component,
        args: [{
                selector: '[tds-input-group-slot]',
                preserveWhitespaces: false,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <i  [class]="icon" *ngIf="icon"></i>
    <ng-container *tdsStringTemplateOutlet="template">{{ template }}</ng-container>
  `,
                host: {
                    '[class.tds-input-group-addon]': `type === 'addon'`,
                    '[class.tds-input-prefix]': `type === 'prefix'`,
                    '[class.tds-input-suffix]': `type === 'suffix'`
                }
            }]
    }], null, { icon: [{
            type: Input
        }], type: [{
            type: Input
        }], template: [{
            type: Input
        }] }); })();

function TDSInputGroupComponent_span_0_span_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 7);
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("icon", ctx_r7.tdsAddOnBeforeIcon)("template", ctx_r7.tdsAddOnBefore);
} }
function TDSInputGroupComponent_span_0_span_2_ng_template_1_Template(rf, ctx) { }
function TDSInputGroupComponent_span_0_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 8);
    i0.ɵɵtemplate(1, TDSInputGroupComponent_span_0_span_2_ng_template_1_Template, 0, 0, "ng-template", 9);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    const _r3 = i0.ɵɵreference(4);
    i0.ɵɵclassProp("tds-input-affix-wrapper-disabled", ctx_r8.disabled)("tds-input-affix-wrapper-sm", ctx_r8.isSmall)("tds-input-affix-wrapper-lg", ctx_r8.isLarge);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function TDSInputGroupComponent_span_0_span_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 7);
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("icon", ctx_r9.tdsAddOnAfterIcon)("template", ctx_r9.tdsAddOnAfter);
} }
function TDSInputGroupComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 4);
    i0.ɵɵtemplate(1, TDSInputGroupComponent_span_0_span_1_Template, 1, 2, "span", 5);
    i0.ɵɵtemplate(2, TDSInputGroupComponent_span_0_span_2_Template, 2, 7, "span", 6);
    i0.ɵɵtemplate(3, TDSInputGroupComponent_span_0_span_3_Template, 1, 2, "span", 5);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    const _r5 = i0.ɵɵreference(6);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.tdsAddOnBefore || ctx_r0.tdsAddOnBeforeIcon);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.isAffix)("ngIfElse", _r5);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.tdsAddOnAfter || ctx_r0.tdsAddOnAfterIcon);
} }
function TDSInputGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template(rf, ctx) { }
function TDSInputGroupComponent_ng_template_1_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, TDSInputGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template, 0, 0, "ng-template", 9);
} if (rf & 2) {
    i0.ɵɵnextContext(2);
    const _r3 = i0.ɵɵreference(4);
    i0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function TDSInputGroupComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, TDSInputGroupComponent_ng_template_1_ng_template_0_Template, 1, 1, "ng-template", 10);
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    const _r5 = i0.ɵɵreference(6);
    i0.ɵɵproperty("ngIf", ctx_r2.isAffix)("ngIfElse", _r5);
} }
function TDSInputGroupComponent_ng_template_3_span_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 13);
} if (rf & 2) {
    const ctx_r13 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("icon", ctx_r13.tdsPrefixIcon)("template", ctx_r13.tdsPrefix);
} }
function TDSInputGroupComponent_ng_template_3_ng_template_1_Template(rf, ctx) { }
function TDSInputGroupComponent_ng_template_3_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 14);
} if (rf & 2) {
    const ctx_r15 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("icon", ctx_r15.tdsSuffixIcon)("template", ctx_r15.tdsSuffix);
} }
function TDSInputGroupComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, TDSInputGroupComponent_ng_template_3_span_0_Template, 1, 2, "span", 11);
    i0.ɵɵtemplate(1, TDSInputGroupComponent_ng_template_3_ng_template_1_Template, 0, 0, "ng-template", 9);
    i0.ɵɵtemplate(2, TDSInputGroupComponent_ng_template_3_span_2_Template, 1, 2, "span", 12);
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    const _r5 = i0.ɵɵreference(6);
    i0.ɵɵproperty("ngIf", ctx_r4.tdsPrefix || ctx_r4.tdsPrefixIcon);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r5);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r4.tdsSuffix || ctx_r4.tdsSuffixIcon);
} }
function TDSInputGroupComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵprojection(0);
} }
const _c0$1 = ["*"];
class TDSInputGroupWhitSuffixOrPrefixDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
}
TDSInputGroupWhitSuffixOrPrefixDirective.ɵfac = function TDSInputGroupWhitSuffixOrPrefixDirective_Factory(t) { return new (t || TDSInputGroupWhitSuffixOrPrefixDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSInputGroupWhitSuffixOrPrefixDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSInputGroupWhitSuffixOrPrefixDirective, selectors: [["tds-input-group", "tdsSuffix", ""], ["tds-input-group", "tdsPrefix", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSInputGroupWhitSuffixOrPrefixDirective, [{
        type: Directive,
        args: [{
                selector: `tds-input-group[tdsSuffix], tds-input-group[tdsPrefix]`
            }]
    }], function () { return [{ type: i0.ElementRef }]; }, null); })();
class TDSInputGroupComponent {
    constructor(focusMonitor, elementRef, cdr, directionality) {
        this.focusMonitor = focusMonitor;
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.directionality = directionality;
        this.tdsAddOnBeforeIcon = null;
        this.tdsAddOnAfterIcon = null;
        this.tdsPrefixIcon = null;
        this.tdsSuffixIcon = null;
        this.tdsSize = 'md';
        this.tdsSearch = false;
        this.tdsCompact = false;
        this.isLarge = false;
        this.isSmall = false;
        this.isAffix = false;
        this.isAddOn = false;
        this.focused = false;
        this.disabled = false;
        this.dir = 'ltr';
        this.destroy$ = new Subject();
    }
    updateChildrenInputSize() {
        if (this.listOfTDSInputDirective) {
            this.listOfTDSInputDirective.forEach(item => (item.tdsSize = this.tdsSize));
        }
    }
    ngOnInit() {
        this.focusMonitor
            .monitor(this.elementRef, true)
            .pipe(takeUntil(this.destroy$))
            .subscribe(focusOrigin => {
            this.focused = !!focusOrigin;
            this.cdr.markForCheck();
        });
        this.dir = this.directionality.value;
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
        });
    }
    ngAfterContentInit() {
        this.updateChildrenInputSize();
        const listOfInputChange$ = this.listOfTDSInputDirective.changes.pipe(startWith(this.listOfTDSInputDirective));
        listOfInputChange$
            .pipe(switchMap(list => merge(...[listOfInputChange$, ...list.map((input) => input.disabled$)])), mergeMap(() => listOfInputChange$), map(list => list.some((input) => input.disabled)), takeUntil(this.destroy$))
            .subscribe(disabled => {
            this.disabled = disabled;
            this.cdr.markForCheck();
        });
    }
    ngOnChanges(changes) {
        const { tdsSize, tdsSuffix, tdsPrefix, tdsPrefixIcon, tdsSuffixIcon, tdsAddOnAfter, tdsAddOnBefore, tdsAddOnAfterIcon, tdsAddOnBeforeIcon } = changes;
        if (tdsSize) {
            this.updateChildrenInputSize();
            this.isLarge = this.tdsSize === 'xl';
            this.isSmall = this.tdsSize === 'sm';
        }
        if (tdsSuffix || tdsPrefix || tdsPrefixIcon || tdsSuffixIcon) {
            this.isAffix = !!(this.tdsSuffix || this.tdsPrefix || this.tdsPrefixIcon || this.tdsSuffixIcon);
        }
        if (tdsAddOnAfter || tdsAddOnBefore || tdsAddOnAfterIcon || tdsAddOnBeforeIcon) {
            this.isAddOn = !!(this.tdsAddOnAfter || this.tdsAddOnBefore || this.tdsAddOnAfterIcon || this.tdsAddOnBeforeIcon);
        }
    }
    ngOnDestroy() {
        this.focusMonitor.stopMonitoring(this.elementRef);
        this.destroy$.next();
        this.destroy$.complete();
    }
}
TDSInputGroupComponent.ɵfac = function TDSInputGroupComponent_Factory(t) { return new (t || TDSInputGroupComponent)(i0.ɵɵdirectiveInject(i1$1.FocusMonitor), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.Directionality, 8)); };
TDSInputGroupComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSInputGroupComponent, selectors: [["tds-input-group"]], contentQueries: function TDSInputGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, TDSInputDirective, 4);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.listOfTDSInputDirective = _t);
    } }, hostVars: 40, hostBindings: function TDSInputGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("tds-input-group-compact", ctx.tdsCompact)("tds-input-search-enter-button", ctx.tdsSearch)("tds-input-search", ctx.tdsSearch)("tds-input-search-rtl", ctx.dir === "rtl")("tds-input-search-sm", ctx.tdsSearch && ctx.isSmall)("tds-input-search-large", ctx.tdsSearch && ctx.isLarge)("tds-input-group-wrapper", ctx.isAddOn)("tds-input-group-wrapper-rtl", ctx.dir === "rtl")("tds-input-group-wrapper-lg", ctx.isAddOn && ctx.isLarge)("tds-input-group-wrapper-sm", ctx.isAddOn && ctx.isSmall)("tds-input-affix-wrapper", ctx.isAffix && !ctx.isAddOn)("tds-input-affix-wrapper-rtl", ctx.dir === "rtl")("tds-input-affix-wrapper-focused", ctx.isAffix && ctx.focused)("tds-input-affix-wrapper-disabled", ctx.isAffix && ctx.disabled)("tds-input-affix-wrapper-lg", ctx.isAffix && !ctx.isAddOn && ctx.isLarge)("tds-input-affix-wrapper-sm", ctx.isAffix && !ctx.isAddOn && ctx.isSmall)("tds-input-group", !ctx.isAffix && !ctx.isAddOn)("tds-input-group-rtl", ctx.dir === "rtl")("tds-input-group-lg", !ctx.isAffix && !ctx.isAddOn && ctx.isLarge)("tds-input-group-sm", !ctx.isAffix && !ctx.isAddOn && ctx.isSmall);
    } }, inputs: { tdsAddOnBeforeIcon: "tdsAddOnBeforeIcon", tdsAddOnAfterIcon: "tdsAddOnAfterIcon", tdsPrefixIcon: "tdsPrefixIcon", tdsSuffixIcon: "tdsSuffixIcon", tdsAddOnBefore: "tdsAddOnBefore", tdsAddOnAfter: "tdsAddOnAfter", tdsPrefix: "tdsPrefix", tdsSuffix: "tdsSuffix", tdsSize: "tdsSize", tdsSearch: "tdsSearch", tdsCompact: "tdsCompact" }, exportAs: ["tdsInputGroup"], features: [i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0$1, decls: 7, vars: 2, consts: [["class", "tds-input-wrapper tds-input-group", 4, "ngIf", "ngIfElse"], ["noAddOnTemplate", ""], ["affixTemplate", ""], ["contentTemplate", ""], [1, "tds-input-wrapper", "tds-input-group"], ["tds-input-group-slot", "", "type", "addon", 3, "icon", "template", 4, "ngIf"], ["class", "tds-input-affix-wrapper", 3, "tds-input-affix-wrapper-disabled", "tds-input-affix-wrapper-sm", "tds-input-affix-wrapper-lg", 4, "ngIf", "ngIfElse"], ["tds-input-group-slot", "", "type", "addon", 3, "icon", "template"], [1, "tds-input-affix-wrapper"], [3, "ngTemplateOutlet"], [3, "ngIf", "ngIfElse"], ["tds-input-group-slot", "", "type", "prefix", 3, "icon", "template", 4, "ngIf"], ["tds-input-group-slot", "", "type", "suffix", 3, "icon", "template", 4, "ngIf"], ["tds-input-group-slot", "", "type", "prefix", 3, "icon", "template"], ["tds-input-group-slot", "", "type", "suffix", 3, "icon", "template"]], template: function TDSInputGroupComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtemplate(0, TDSInputGroupComponent_span_0_Template, 4, 4, "span", 0);
        i0.ɵɵtemplate(1, TDSInputGroupComponent_ng_template_1_Template, 1, 2, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtemplate(3, TDSInputGroupComponent_ng_template_3_Template, 3, 3, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtemplate(5, TDSInputGroupComponent_ng_template_5_Template, 1, 0, "ng-template", null, 3, i0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(2);
        i0.ɵɵproperty("ngIf", ctx.isAddOn)("ngIfElse", _r1);
    } }, directives: [i3.NgIf, TDSInputGroupSlotComponent, i3.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSInputGroupComponent.prototype, "tdsSearch", void 0);
__decorate([
    InputBoolean()
], TDSInputGroupComponent.prototype, "tdsCompact", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSInputGroupComponent, [{
        type: Component,
        args: [{
                selector: 'tds-input-group',
                exportAs: 'tdsInputGroup',
                preserveWhitespaces: false,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <span class="tds-input-wrapper tds-input-group" *ngIf="isAddOn; else noAddOnTemplate">
      <span
        *ngIf="tdsAddOnBefore || tdsAddOnBeforeIcon"
        tds-input-group-slot
        type="addon"
        [icon]="tdsAddOnBeforeIcon"
        [template]="tdsAddOnBefore"
      ></span>
      <span
        *ngIf="isAffix; else contentTemplate"
        class="tds-input-affix-wrapper"
        [class.tds-input-affix-wrapper-disabled]="disabled"
        [class.tds-input-affix-wrapper-sm]="isSmall"
        [class.tds-input-affix-wrapper-lg]="isLarge"
      >
        <ng-template [ngTemplateOutlet]="affixTemplate"></ng-template>
      </span>
      <span
        *ngIf="tdsAddOnAfter || tdsAddOnAfterIcon"
        tds-input-group-slot
        type="addon"
        [icon]="tdsAddOnAfterIcon"
        [template]="tdsAddOnAfter"
      ></span>
    </span>
    <ng-template #noAddOnTemplate>
      <ng-template [ngIf]="isAffix" [ngIfElse]="contentTemplate">
        <ng-template [ngTemplateOutlet]="affixTemplate"></ng-template>
      </ng-template>
    </ng-template>
    <ng-template #affixTemplate>
      <span
        *ngIf="tdsPrefix || tdsPrefixIcon"
        tds-input-group-slot
        type="prefix"
        [icon]="tdsPrefixIcon"
        [template]="tdsPrefix"
      ></span>
      <ng-template [ngTemplateOutlet]="contentTemplate"></ng-template>
      <span
        *ngIf="tdsSuffix || tdsSuffixIcon"
        tds-input-group-slot
        type="suffix"
        [icon]="tdsSuffixIcon"
        [template]="tdsSuffix"
      ></span>
    </ng-template>
    <ng-template #contentTemplate>
      <ng-content></ng-content>
    </ng-template>
  `,
                host: {
                    '[class.tds-input-group-compact]': `tdsCompact`,
                    '[class.tds-input-search-enter-button]': `tdsSearch`,
                    '[class.tds-input-search]': `tdsSearch`,
                    '[class.tds-input-search-rtl]': `dir === 'rtl'`,
                    '[class.tds-input-search-sm]': `tdsSearch && isSmall`,
                    '[class.tds-input-search-large]': `tdsSearch && isLarge`,
                    '[class.tds-input-group-wrapper]': `isAddOn`,
                    '[class.tds-input-group-wrapper-rtl]': `dir === 'rtl'`,
                    '[class.tds-input-group-wrapper-lg]': `isAddOn && isLarge`,
                    '[class.tds-input-group-wrapper-sm]': `isAddOn && isSmall`,
                    '[class.tds-input-affix-wrapper]': `isAffix && !isAddOn`,
                    '[class.tds-input-affix-wrapper-rtl]': `dir === 'rtl'`,
                    '[class.tds-input-affix-wrapper-focused]': `isAffix && focused`,
                    '[class.tds-input-affix-wrapper-disabled]': `isAffix && disabled`,
                    '[class.tds-input-affix-wrapper-lg]': `isAffix && !isAddOn && isLarge`,
                    '[class.tds-input-affix-wrapper-sm]': `isAffix && !isAddOn && isSmall`,
                    '[class.tds-input-group]': `!isAffix && !isAddOn`,
                    '[class.tds-input-group-rtl]': `dir === 'rtl'`,
                    '[class.tds-input-group-lg]': `!isAffix && !isAddOn && isLarge`,
                    '[class.tds-input-group-sm]': `!isAffix && !isAddOn && isSmall`
                }
            }]
    }], function () { return [{ type: i1$1.FocusMonitor }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i2.Directionality, decorators: [{
                type: Optional
            }] }]; }, { listOfTDSInputDirective: [{
            type: ContentChildren,
            args: [TDSInputDirective]
        }], tdsAddOnBeforeIcon: [{
            type: Input
        }], tdsAddOnAfterIcon: [{
            type: Input
        }], tdsPrefixIcon: [{
            type: Input
        }], tdsSuffixIcon: [{
            type: Input
        }], tdsAddOnBefore: [{
            type: Input
        }], tdsAddOnAfter: [{
            type: Input
        }], tdsPrefix: [{
            type: Input
        }], tdsSuffix: [{
            type: Input
        }], tdsSize: [{
            type: Input
        }], tdsSearch: [{
            type: Input
        }], tdsCompact: [{
            type: Input
        }] }); })();

class TDSAutosizeDirective {
    constructor(elementRef, ngZone, platform, resizeService) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.platform = platform;
        this.resizeService = resizeService;
        this.autosize = false;
        this.el = this.elementRef.nativeElement;
        this.maxHeight = null;
        this.minHeight = null;
        this.destroy$ = new Subject();
        this.inputGap = 10;
    }
    set tdsAutosize(value) {
        const isAutoSizeType = (data) => typeof data !== 'string' && typeof data !== 'boolean' && (!!data.maxRows || !!data.minRows);
        if (typeof value === 'string' || value === true) {
            this.autosize = true;
        }
        else if (isAutoSizeType(value)) {
            this.autosize = true;
            this.minRows = value.minRows;
            this.maxRows = value.maxRows;
            this.maxHeight = this.setMaxHeight();
            this.minHeight = this.setMinHeight();
        }
    }
    resizeToFitContent(force = false) {
        this.cacheTextareaLineHeight();
        // If we haven't determined the line-height yet, we know we're still hidden and there's no point
        // in checking the height of the textarea.
        if (!this.cachedLineHeight) {
            return;
        }
        const textarea = this.el;
        const value = textarea.value;
        // Only resize if the value or minRows have changed since these calculations can be expensive.
        if (!force && this.minRows === this.previousMinRows && value === this.previousValue) {
            return;
        }
        const placeholderText = textarea.placeholder;
        // Reset the textarea height to auto in order to shrink back to its default size.
        // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.
        // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight
        // value. To ensure that the scrollHeight is not bigger than the content, the placeholders
        // need to be removed temporarily.
        textarea.classList.add('tds-textarea-autosize-measuring');
        textarea.placeholder = '';
        let height = Math.round((textarea.scrollHeight - this.inputGap) / this.cachedLineHeight) * this.cachedLineHeight +
            this.inputGap;
        if (this.maxHeight !== null && height > this.maxHeight) {
            height = this.maxHeight;
        }
        if (this.minHeight !== null && height < this.minHeight) {
            height = this.minHeight;
        }
        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.
        textarea.style.height = `${height}px`;
        textarea.classList.remove('tds-textarea-autosize-measuring');
        textarea.placeholder = placeholderText;
        // On Firefox resizing the textarea will prevent it from scrolling to the caret position.
        // We need to re-set the selection in order for it to scroll to the proper position.
        if (typeof requestAnimationFrame !== 'undefined') {
            this.ngZone.runOutsideAngular(() => requestAnimationFrame(() => {
                const { selectionStart, selectionEnd } = textarea;
                // IE will throw an "Unspecified error" if we try to set the selection range after the
                // element has been removed from the DOM. Assert that the directive hasn't been destroyed
                // between the time we requested the animation frame and when it was executed.
                // Also note that we have to assert that the textarea is focused before we set the
                // selection range. Setting the selection range on a non-focused textarea will cause
                // it to receive focus on IE and Edge.
                if (!this.destroy$.isStopped && document.activeElement === textarea) {
                    textarea.setSelectionRange(selectionStart, selectionEnd);
                }
            }));
        }
        this.previousValue = value;
        this.previousMinRows = this.minRows;
    }
    cacheTextareaLineHeight() {
        if (this.cachedLineHeight >= 0 || !this.el.parentNode) {
            return;
        }
        // Use a clone element because we have to override some styles.
        const textareaClone = this.el.cloneNode(false);
        textareaClone.rows = 1;
        // Use `position: absolute` so that this doesn't cause a browser layout and use
        // `visibility: hidden` so that nothing is rendered. Clear any other styles that
        // would affect the height.
        textareaClone.style.position = 'absolute';
        textareaClone.style.visibility = 'hidden';
        textareaClone.style.border = 'none';
        textareaClone.style.padding = '0';
        textareaClone.style.height = '';
        textareaClone.style.minHeight = '';
        textareaClone.style.maxHeight = '';
        // In Firefox it happens that textarea elements are always bigger than the specified amount
        // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.
        // As a workaround that removes the extra space for the scrollbar, we can just set overflow
        // to hidden. This ensures that there is no invalid calculation of the line height.
        // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654
        textareaClone.style.overflow = 'hidden';
        this.el.parentNode.appendChild(textareaClone);
        this.cachedLineHeight = textareaClone.clientHeight - this.inputGap;
        this.el.parentNode.removeChild(textareaClone);
        // Min and max heights have to be re-calculated if the cached line height changes
        this.maxHeight = this.setMaxHeight();
        this.minHeight = this.setMinHeight();
    }
    setMinHeight() {
        const minHeight = this.minRows && this.cachedLineHeight ? this.minRows * this.cachedLineHeight + this.inputGap : null;
        if (minHeight !== null) {
            this.el.style.minHeight = `${minHeight}px`;
        }
        return minHeight;
    }
    setMaxHeight() {
        const maxHeight = this.maxRows && this.cachedLineHeight ? this.maxRows * this.cachedLineHeight + this.inputGap : null;
        if (maxHeight !== null) {
            this.el.style.maxHeight = `${maxHeight}px`;
        }
        return maxHeight;
    }
    noopInputHandler() {
        // no-op handler that ensures we're running change detection on input events.
    }
    ngAfterViewInit() {
        if (this.autosize && this.platform.isBrowser) {
            this.resizeToFitContent();
            this.resizeService
                .subscribe()
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => this.resizeToFitContent(true));
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    ngDoCheck() {
        if (this.autosize && this.platform.isBrowser) {
            this.resizeToFitContent();
        }
    }
}
TDSAutosizeDirective.ɵfac = function TDSAutosizeDirective_Factory(t) { return new (t || TDSAutosizeDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$2.Platform), i0.ɵɵdirectiveInject(i2$2.TDSResizeService)); };
TDSAutosizeDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: TDSAutosizeDirective, selectors: [["textarea", "tdsAutosize", ""]], hostAttrs: ["rows", "1"], hostBindings: function TDSAutosizeDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("input", function TDSAutosizeDirective_input_HostBindingHandler() { return ctx.noopInputHandler(); });
    } }, inputs: { tdsAutosize: "tdsAutosize" }, exportAs: ["tdsAutosize"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSAutosizeDirective, [{
        type: Directive,
        args: [{
                selector: 'textarea[tdsAutosize]',
                exportAs: 'tdsAutosize',
                host: {
                    // Textarea elements that have the directive applied should have a single row by default.
                    // Browsers normally show two rows by default and therefore this limits the minRows binding.
                    rows: '1',
                    '(input)': 'noopInputHandler()'
                }
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i1$2.Platform }, { type: i2$2.TDSResizeService }]; }, { tdsAutosize: [{
            type: Input
        }] }); })();

const _c0 = [[["textarea", "tds-input", ""]]];
const _c1 = ["textarea[tds-input]"];
class TDSTextareaCountComponent {
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.tdsMaxCharacterCount = 0;
        this.tdsComputeCharacterCount = v => v.length;
        this.tdsFormatter = (c, m) => `${c}${m > 0 ? `/${m}` : ``}`;
        this.configChange$ = new Subject();
        this.destroy$ = new Subject();
    }
    ngAfterContentInit() {
        if (!this.TDSInputDirective && isDevMode()) {
            throw new Error('[tds-textarea-count]: Could not find matching textarea[tds-input] child.');
        }
        if (this.TDSInputDirective.ngControl) {
            const valueChanges = this.TDSInputDirective.ngControl.valueChanges || EMPTY;
            merge(valueChanges, this.configChange$)
                .pipe(takeUntil(this.destroy$), map(() => this.TDSInputDirective.ngControl.value), startWith(this.TDSInputDirective.ngControl.value))
                .subscribe(value => {
                this.setDataCount(value);
            });
        }
    }
    setDataCount(value) {
        const inputValue = isNotNil(value) ? String(value) : '';
        const currentCount = this.tdsComputeCharacterCount(inputValue);
        const dataCount = this.tdsFormatter(currentCount, this.tdsMaxCharacterCount);
        this.renderer.setAttribute(this.elementRef.nativeElement, 'data-count', dataCount);
    }
    ngOnDestroy() {
        this.configChange$.complete();
        this.destroy$.next();
        this.destroy$.complete();
    }
}
TDSTextareaCountComponent.ɵfac = function TDSTextareaCountComponent_Factory(t) { return new (t || TDSTextareaCountComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef)); };
TDSTextareaCountComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTextareaCountComponent, selectors: [["tds-textarea-count"]], contentQueries: function TDSTextareaCountComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, TDSInputDirective, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.TDSInputDirective = _t.first);
    } }, hostAttrs: [1, "tds-input-textarea-show-count"], inputs: { tdsMaxCharacterCount: "tdsMaxCharacterCount", tdsComputeCharacterCount: "tdsComputeCharacterCount", tdsFormatter: "tdsFormatter" }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function TDSTextareaCountComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c0);
        i0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTextareaCountComponent, [{
        type: Component,
        args: [{
                selector: 'tds-textarea-count',
                template: ` <ng-content select="textarea[tds-input]"></ng-content> `,
                host: {
                    class: 'tds-input-textarea-show-count'
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }]; }, { TDSInputDirective: [{
            type: ContentChild,
            args: [TDSInputDirective, { static: true }]
        }], tdsMaxCharacterCount: [{
            type: Input
        }], tdsComputeCharacterCount: [{
            type: Input
        }], tdsFormatter: [{
            type: Input
        }] }); })();

class TDSFormInputModule {
}
TDSFormInputModule.ɵfac = function TDSFormInputModule_Factory(t) { return new (t || TDSFormInputModule)(); };
TDSFormInputModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSFormInputModule });
TDSFormInputModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[BidiModule, CommonModule, PlatformModule, TDSOutletModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSFormInputModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TDSTextareaCountComponent,
                    TDSInputDirective,
                    TDSInputGroupComponent,
                    TDSAutosizeDirective,
                    TDSInputGroupSlotComponent,
                    TDSInputGroupWhitSuffixOrPrefixDirective
                ],
                exports: [
                    TDSTextareaCountComponent,
                    TDSInputDirective,
                    TDSInputGroupComponent,
                    TDSAutosizeDirective,
                    TDSInputGroupSlotComponent,
                    TDSInputGroupWhitSuffixOrPrefixDirective
                ],
                imports: [BidiModule, CommonModule, PlatformModule, TDSOutletModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSFormInputModule, { declarations: [TDSTextareaCountComponent,
        TDSInputDirective,
        TDSInputGroupComponent,
        TDSAutosizeDirective,
        TDSInputGroupSlotComponent,
        TDSInputGroupWhitSuffixOrPrefixDirective], imports: [BidiModule, CommonModule, PlatformModule, TDSOutletModule], exports: [TDSTextareaCountComponent,
        TDSInputDirective,
        TDSInputGroupComponent,
        TDSAutosizeDirective,
        TDSInputGroupSlotComponent,
        TDSInputGroupWhitSuffixOrPrefixDirective] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { TDSAutosizeDirective, TDSFormInputModule, TDSInputDirective, TDSInputGroupComponent, TDSInputGroupSlotComponent, TDSInputGroupWhitSuffixOrPrefixDirective, TDSTextareaCountComponent };
//# sourceMappingURL=tds-ui-input.mjs.map
