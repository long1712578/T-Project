import { __decorate } from 'tslib';
import { RIGHT_ARROW, UP_ARROW, LEFT_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';
import * as i0 from '@angular/core';
import { Injectable, Component, ChangeDetectionStrategy, ViewEncapsulation, ViewChild, Input, EventEmitter, forwardRef, Optional, ViewChildren, Output, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subject, fromEvent, merge } from 'rxjs';
import { takeUntil, filter, tap, pluck, map, distinctUntilChanged } from 'rxjs/operators';
import { ensureNumberInRange, silentEvent, getPrecision, getPercent, getElementOffset, isNil, arraysEqual } from 'tds-ui/core/util';
import { InputBoolean, InputNumber } from 'tds-ui/shared/utility';
import * as i2 from 'tds-ui/tooltip';
import { TDSTooltipDirective, TDSToolTipModule } from 'tds-ui/tooltip';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2$1 from '@angular/cdk/platform';
import { PlatformModule } from '@angular/cdk/platform';
import * as i3 from '@angular/cdk/bidi';
import { BidiModule } from '@angular/cdk/bidi';

class TDSSliderService {
    constructor() {
        this.isDragging = false;
    }
}
TDSSliderService.ɵfac = function TDSSliderService_Factory(t) { return new (t || TDSSliderService)(); };
TDSSliderService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TDSSliderService, factory: TDSSliderService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSSliderService, [{
        type: Injectable
    }], null, null); })();

const _c0$4 = ["handle"];
const _c1$2 = function (a0, a1) { return { "-mt-1.5": a0, "-ml-1.5": a1 }; };
class TDSSliderHandleComponent {
    constructor(sliderService, cdr) {
        this.sliderService = sliderService;
        this.cdr = cdr;
        this.tooltipVisible = 'default';
        this.active = false;
        this.dir = 'ltr';
        this.style = {};
        this.enterHandle = () => {
            if (!this.sliderService.isDragging) {
                this.toggleTooltip(true);
                this.updateTooltipPosition();
                this.cdr.detectChanges();
            }
        };
        this.leaveHandle = () => {
            if (!this.sliderService.isDragging) {
                this.toggleTooltip(false);
                this.cdr.detectChanges();
            }
        };
    }
    ngOnChanges(changes) {
        const { offset, value, active, tooltipVisible, reverse, dir } = changes;
        if (offset || reverse || dir) {
            this.updateStyle();
        }
        if (value) {
            this.updateTooltipTitle();
            this.updateTooltipPosition();
        }
        if (active) {
            if (active.currentValue) {
                this.toggleTooltip(true);
            }
            else {
                this.toggleTooltip(false);
            }
        }
        if (tooltipVisible?.currentValue === 'always') {
            Promise.resolve().then(() => this.toggleTooltip(true, true));
        }
    }
    focus() {
        this.handleEl?.nativeElement.focus();
    }
    toggleTooltip(show, force = false) {
        if (!force && (this.tooltipVisible !== 'default' || !this.tooltip)) {
            return;
        }
        if (show) {
            this.tooltip?.show();
        }
        else {
            this.tooltip?.hide();
        }
    }
    updateTooltipTitle() {
        this.tooltipTitle = this.tooltipFormatter ? this.tooltipFormatter(this.value) : `${this.value}`;
    }
    updateTooltipPosition() {
        if (this.tooltip) {
            Promise.resolve().then(() => this.tooltip?.updatePosition());
        }
    }
    updateStyle() {
        const vertical = this.vertical;
        const reverse = this.reverse;
        const offset = this.offset;
        const positionStyle = vertical
            ? {
                [reverse ? 'top' : 'bottom']: `${offset}%`,
                [reverse ? 'bottom' : 'top']: 'auto',
                transform: reverse ? null : `translateY(+50%)`
            }
            : {
                ...this.getHorizontalStylePosition(),
                transform: `translateX(${reverse ? (this.dir === 'rtl' ? '-' : '+') : this.dir === 'rtl' ? '+' : '-'}50%)`
            };
        this.style = positionStyle;
        this.cdr.markForCheck();
    }
    getHorizontalStylePosition() {
        let left = this.reverse ? 'auto' : `${this.offset}%`;
        let right = this.reverse ? `${this.offset}%` : 'auto';
        if (this.dir === 'rtl') {
            const tmp = left;
            left = right;
            right = tmp;
        }
        return { left, right };
    }
}
TDSSliderHandleComponent.ɵfac = function TDSSliderHandleComponent_Factory(t) { return new (t || TDSSliderHandleComponent)(i0.ɵɵdirectiveInject(TDSSliderService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
TDSSliderHandleComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSSliderHandleComponent, selectors: [["tds-slider-handle"]], viewQuery: function TDSSliderHandleComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$4, 5);
        i0.ɵɵviewQuery(TDSTooltipDirective, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.handleEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltip = _t.first);
    } }, hostBindings: function TDSSliderHandleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("mouseenter", function TDSSliderHandleComponent_mouseenter_HostBindingHandler() { return ctx.enterHandle(); })("mouseleave", function TDSSliderHandleComponent_mouseleave_HostBindingHandler() { return ctx.leaveHandle(); });
    } }, inputs: { vertical: "vertical", reverse: "reverse", offset: "offset", value: "value", tooltipVisible: "tooltipVisible", tooltipPlacement: "tooltipPlacement", tooltipFormatter: "tooltipFormatter", active: "active", dir: "dir" }, exportAs: ["tdsSliderHandle"], features: [i0.ɵɵNgOnChangesFeature], decls: 2, vars: 8, consts: [["tabindex", "0", "tds-tooltip", "", 1, "tds-slider-handle", "absolute", "w-5", "h-5", "rounded-full", "border-2", "border-primary-1", "dark:border-d-primary-1", "bg-white", "focus:outline-none", "focus:border-primary-1", "dark:focus:border-d-primary-1", 3, "ngStyle", "tooltipTitle", "tooltipTrigger", "tooltipPlacement", "ngClass"], ["handle", ""]], template: function TDSSliderHandleComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        i0.ɵɵproperty("ngStyle", ctx.style)("tooltipTitle", ctx.tooltipFormatter === null || ctx.tooltipVisible === "never" ? null : ctx.tooltipTitle)("tooltipTrigger", null)("tooltipPlacement", ctx.tooltipPlacement)("ngClass", i0.ɵɵpureFunction2(5, _c1$2, !ctx.vertical, ctx.vertical));
    } }, directives: [i2.TDSTooltipDirective, i1.NgStyle, i1.NgClass], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSSliderHandleComponent.prototype, "active", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSSliderHandleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                selector: 'tds-slider-handle',
                exportAs: 'tdsSliderHandle',
                preserveWhitespaces: false,
                template: `
    <div
      #handle
      class="tds-slider-handle absolute w-5 h-5 rounded-full  border-2 border-primary-1 dark:border-d-primary-1 bg-white  
        focus:outline-none focus:border-primary-1 dark:focus:border-d-primary-1"
      tabindex="0"
      tds-tooltip
      [ngStyle]="style"
      [tooltipTitle]="tooltipFormatter === null || tooltipVisible === 'never' ? null : tooltipTitle"
      [tooltipTrigger]="null"
      [tooltipPlacement]="tooltipPlacement"
      [ngClass]="{'-mt-1.5':!vertical,'-ml-1.5':vertical}"
    ></div>
  `,
                host: {
                    '(mouseenter)': 'enterHandle()',
                    '(mouseleave)': 'leaveHandle()'
                }
            }]
    }], function () { return [{ type: TDSSliderService }, { type: i0.ChangeDetectorRef }]; }, { handleEl: [{
            type: ViewChild,
            args: ['handle', { static: false }]
        }], tooltip: [{
            type: ViewChild,
            args: [TDSTooltipDirective, { static: false }]
        }], vertical: [{
            type: Input
        }], reverse: [{
            type: Input
        }], offset: [{
            type: Input
        }], value: [{
            type: Input
        }], tooltipVisible: [{
            type: Input
        }], tooltipPlacement: [{
            type: Input
        }], tooltipFormatter: [{
            type: Input
        }], active: [{
            type: Input
        }], dir: [{
            type: Input
        }] }); })();

const _c0$3 = function (a0, a1) { return { "h-2": a0, "w-2": a1 }; };
class TDSSliderTrackComponent {
    constructor() {
        this.offset = 0;
        this.reverse = false;
        this.dir = 'ltr';
        this.length = 0;
        this.vertical = false;
        this.included = false;
        this.style = {};
    }
    ngOnChanges() {
        const vertical = this.vertical;
        const reverse = this.reverse;
        const visibility = this.included ? 'visible' : 'hidden';
        const offset = this.offset;
        const length = this.length;
        const positonStyle = vertical
            ? {
                [reverse ? 'top' : 'bottom']: `${offset}%`,
                [reverse ? 'bottom' : 'top']: 'auto',
                height: `${length}%`,
                visibility
            }
            : {
                ...this.getHorizontalStylePosition(),
                width: `${length}%`,
                visibility
            };
        this.style = positonStyle;
    }
    getHorizontalStylePosition() {
        let left = this.reverse ? 'auto' : `${this.offset}%`;
        let right = this.reverse ? `${this.offset}%` : 'auto';
        if (this.dir === 'rtl') {
            const tmp = left;
            left = right;
            right = tmp;
        }
        return { left, right };
    }
}
TDSSliderTrackComponent.ɵfac = function TDSSliderTrackComponent_Factory(t) { return new (t || TDSSliderTrackComponent)(); };
TDSSliderTrackComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSSliderTrackComponent, selectors: [["tds-slider-track"]], inputs: { offset: "offset", reverse: "reverse", dir: "dir", length: "length", vertical: "vertical", included: "included" }, exportAs: ["tdsSliderTrack"], features: [i0.ɵɵNgOnChangesFeature], decls: 1, vars: 5, consts: [[1, "tds-slider-track", "absolute", "rounded-full", "transition-colors", "duration-300", "bg-primary-1", "dark:bg-d-primary-1", 3, "ngStyle", "ngClass"]], template: function TDSSliderTrackComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelement(0, "div", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngStyle", ctx.style)("ngClass", i0.ɵɵpureFunction2(2, _c0$3, !ctx.vertical, ctx.vertical));
    } }, directives: [i1.NgStyle, i1.NgClass], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputNumber()
], TDSSliderTrackComponent.prototype, "offset", void 0);
__decorate([
    InputBoolean()
], TDSSliderTrackComponent.prototype, "reverse", void 0);
__decorate([
    InputNumber()
], TDSSliderTrackComponent.prototype, "length", void 0);
__decorate([
    InputBoolean()
], TDSSliderTrackComponent.prototype, "vertical", void 0);
__decorate([
    InputBoolean()
], TDSSliderTrackComponent.prototype, "included", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSSliderTrackComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                selector: 'tds-slider-track',
                exportAs: 'tdsSliderTrack',
                preserveWhitespaces: false,
                template: ` 
  <div class="tds-slider-track absolute  rounded-full transition-colors duration-300 bg-primary-1 dark:bg-d-primary-1"
   [ngStyle]="style"
   [ngClass]="{'h-2':!vertical, 'w-2':vertical}"
   ></div> 
  `
            }]
    }], null, { offset: [{
            type: Input
        }], reverse: [{
            type: Input
        }], dir: [{
            type: Input
        }], length: [{
            type: Input
        }], vertical: [{
            type: Input
        }], included: [{
            type: Input
        }] }); })();

const _c0$2 = function (a0, a1) { return { "w-1.5 h-px left-5 -mb-0.5": a0, "h-1.5 w-px top-5 -ml-px": a1 }; };
function TDSSliderStepComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 2);
} if (rf & 2) {
    const mark_r1 = ctx.$implicit;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("tds-slider-dot-active", mark_r1.active);
    i0.ɵɵproperty("ngStyle", mark_r1.style)("ngClass", i0.ɵɵpureFunction2(4, _c0$2, ctx_r0.vertical, !ctx_r0.vertical));
} }
class TDSSliderStepComponent {
    constructor() {
        this.lowerBound = null;
        this.upperBound = null;
        this.marksArray = [];
        this.vertical = false;
        this.included = false;
        this.steps = [];
    }
    ngOnChanges(changes) {
        const { marksArray, lowerBound, upperBound, reverse } = changes;
        if (marksArray || reverse) {
            this.buildSteps();
        }
        if (marksArray || lowerBound || upperBound || reverse) {
            this.togglePointActive();
        }
    }
    trackById(_index, step) {
        return step.value;
    }
    buildSteps() {
        const orient = this.vertical ? 'bottom' : 'left';
        this.steps = this.marksArray.map(mark => {
            const { value, config } = mark;
            let offset = mark.offset;
            const range = this.max - this.min;
            if (this.reverse) {
                offset = ((this.max - value) / range) * 100;
            }
            return {
                value,
                offset,
                config,
                active: false,
                style: {
                    [orient]: `${offset}%`
                }
            };
        });
    }
    togglePointActive() {
        if (this.steps && this.lowerBound !== null && this.upperBound !== null) {
            this.steps.forEach(step => {
                const value = step.value;
                const isActive = (!this.included && value === this.upperBound) ||
                    (this.included && value <= this.upperBound && value >= this.lowerBound);
                step.active = isActive;
            });
        }
    }
}
TDSSliderStepComponent.ɵfac = function TDSSliderStepComponent_Factory(t) { return new (t || TDSSliderStepComponent)(); };
TDSSliderStepComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSSliderStepComponent, selectors: [["tds-slider-step"]], inputs: { lowerBound: "lowerBound", upperBound: "upperBound", marksArray: "marksArray", min: "min", max: "max", vertical: "vertical", included: "included", reverse: "reverse" }, exportAs: ["tdsSliderStep"], features: [i0.ɵɵNgOnChangesFeature], decls: 2, vars: 2, consts: [[1, "tds-slider-step"], ["class", "tds-slider-dot absolute  bg-neutral-1-600 dark:bg-d-neutral-1-600", 3, "tds-slider-dot-active", "ngStyle", "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "tds-slider-dot", "absolute", "bg-neutral-1-600", "dark:bg-d-neutral-1-600", 3, "ngStyle", "ngClass"]], template: function TDSSliderStepComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtemplate(1, TDSSliderStepComponent_span_1_Template, 1, 7, "span", 1);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.steps)("ngForTrackBy", ctx.trackById);
    } }, directives: [i1.NgForOf, i1.NgStyle, i1.NgClass], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSSliderStepComponent.prototype, "vertical", void 0);
__decorate([
    InputBoolean()
], TDSSliderStepComponent.prototype, "included", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSSliderStepComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                selector: 'tds-slider-step',
                exportAs: 'tdsSliderStep',
                preserveWhitespaces: false,
                template: `
    <div class="tds-slider-step">
      <span
        class="tds-slider-dot absolute  bg-neutral-1-600 dark:bg-d-neutral-1-600"
        *ngFor="let mark of steps; trackBy: trackById"
        [class.tds-slider-dot-active]="mark.active"
        [ngStyle]="mark.style!"
        [ngClass]="{'w-1.5 h-px left-5 -mb-0.5':vertical,'h-1.5 w-px top-5 -ml-px':!vertical}"
      ></span>
    </div>
  `
            }]
    }], null, { lowerBound: [{
            type: Input
        }], upperBound: [{
            type: Input
        }], marksArray: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], vertical: [{
            type: Input
        }], included: [{
            type: Input
        }], reverse: [{
            type: Input
        }] }); })();

const _c0$1 = function (a0, a1) { return { "top-3.5": a0, "left-3.5": a1 }; };
function TDSSliderMarksComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 2);
} if (rf & 2) {
    const attr_r1 = ctx.$implicit;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("tds-slider-mark-active", attr_r1.active);
    i0.ɵɵproperty("ngStyle", attr_r1.style)("innerHTML", attr_r1.label, i0.ɵɵsanitizeHtml)("ngClass", i0.ɵɵpureFunction2(5, _c0$1, !ctx_r0.vertical, ctx_r0.vertical));
} }
const _c1$1 = function (a0, a1) { return { "top-3.5 left-0 w-full": a0, "top-0 left-3.5 w-4.5 h-full": a1 }; };
class TDSSliderMarksComponent {
    constructor() {
        this.lowerBound = null;
        this.upperBound = null;
        this.marksArray = [];
        this.vertical = false;
        this.included = false;
        this.marks = [];
    }
    ngOnChanges(changes) {
        const { marksArray, lowerBound, upperBound, reverse } = changes;
        if (marksArray || reverse) {
            this.buildMarks();
        }
        if (marksArray || lowerBound || upperBound || reverse) {
            this.togglePointActive();
        }
    }
    trackById(_index, mark) {
        return mark.value;
    }
    buildMarks() {
        const range = this.max - this.min;
        this.marks = this.marksArray.map(mark => {
            const { value, offset, config } = mark;
            const style = this.getMarkStyles(value, range, config);
            const label = isConfigObject(config) ? config.label : config;
            return {
                label,
                offset,
                style,
                value,
                config,
                active: false
            };
        });
    }
    getMarkStyles(value, range, config) {
        let style;
        const markValue = this.reverse ? this.max + this.min - value : value;
        if (this.vertical) {
            style = {
                marginBottom: '-50%',
                bottom: `${((markValue - this.min) / range) * 100}%`
            };
        }
        else {
            style = {
                transform: `translate3d(-50%, 0, 0)`,
                left: `${((markValue - this.min) / range) * 100}%`
            };
        }
        if (isConfigObject(config) && config.style) {
            style = { ...style, ...config.style };
        }
        return style;
    }
    togglePointActive() {
        if (this.marks && this.lowerBound !== null && this.upperBound !== null) {
            this.marks.forEach(mark => {
                const value = mark.value;
                const isActive = (!this.included && value === this.upperBound) ||
                    (this.included && value <= this.upperBound && value >= this.lowerBound);
                mark.active = isActive;
            });
        }
    }
}
TDSSliderMarksComponent.ɵfac = function TDSSliderMarksComponent_Factory(t) { return new (t || TDSSliderMarksComponent)(); };
TDSSliderMarksComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSSliderMarksComponent, selectors: [["tds-slider-marks"]], inputs: { lowerBound: "lowerBound", upperBound: "upperBound", marksArray: "marksArray", min: "min", max: "max", vertical: "vertical", included: "included", reverse: "reverse" }, exportAs: ["tdsSliderMarks"], features: [i0.ɵɵNgOnChangesFeature], decls: 2, vars: 6, consts: [[1, "tds-slider-mark", "absolute", "text-neutral-1-600", "dark:text-d-neutral-1-600", "text-caption-2", 3, "ngClass"], ["class", "tds-slider-mark-text absolute inline-block text-center cursor-pointer select-none ", 3, "tds-slider-mark-active", "ngStyle", "innerHTML", "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "tds-slider-mark-text", "absolute", "inline-block", "text-center", "cursor-pointer", "select-none", 3, "ngStyle", "innerHTML", "ngClass"]], template: function TDSSliderMarksComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtemplate(1, TDSSliderMarksComponent_span_1_Template, 1, 8, "span", 1);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(3, _c1$1, !ctx.vertical, ctx.vertical));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.marks)("ngForTrackBy", ctx.trackById);
    } }, directives: [i1.NgClass, i1.NgForOf, i1.NgStyle], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSSliderMarksComponent.prototype, "vertical", void 0);
__decorate([
    InputBoolean()
], TDSSliderMarksComponent.prototype, "included", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSSliderMarksComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false,
                selector: 'tds-slider-marks',
                exportAs: 'tdsSliderMarks',
                template: `
    <div class="tds-slider-mark absolute  text-neutral-1-600 dark:text-d-neutral-1-600 text-caption-2"
    [ngClass]="{'top-3.5 left-0 w-full':!vertical,'top-0 left-3.5 w-4.5 h-full':vertical}"
    >
      <span
        class="tds-slider-mark-text absolute inline-block text-center cursor-pointer select-none "
        *ngFor="let attr of marks; trackBy: trackById"
        [class.tds-slider-mark-active]="attr.active"       
        [ngStyle]="attr.style!"
        [innerHTML]="attr.label"
        [ngClass]="{'top-3.5':!vertical,'left-3.5':vertical}"
      ></span>
    </div>
  `
            }]
    }], null, { lowerBound: [{
            type: Input
        }], upperBound: [{
            type: Input
        }], marksArray: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], vertical: [{
            type: Input
        }], included: [{
            type: Input
        }], reverse: [{
            type: Input
        }] }); })();
function isConfigObject(config) {
    return typeof config !== 'string';
}

const _c0 = ["slider"];
function TDSSliderComponent_tds_slider_step_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "tds-slider-step", 6);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("vertical", ctx_r1.tdsVertical)("min", ctx_r1.tdsMin)("max", ctx_r1.tdsMax)("lowerBound", ctx_r1.bounds.lower)("upperBound", ctx_r1.bounds.upper)("marksArray", ctx_r1.marksArray)("included", ctx_r1.tdsIncluded)("reverse", ctx_r1.tdsReverse);
} }
function TDSSliderComponent_tds_slider_handle_5_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "tds-slider-handle", 7);
    i0.ɵɵlistener("focusin", function TDSSliderComponent_tds_slider_handle_5_Template_tds_slider_handle_focusin_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r7); const handleIndex_r5 = restoredCtx.index; const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.onHandleFocusIn(handleIndex_r5); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const handle_r4 = ctx.$implicit;
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("cursor-not-allowed", ctx_r2.tdsDisabled)("cursor-pointer", !ctx_r2.tdsDisabled);
    i0.ɵɵproperty("vertical", ctx_r2.tdsVertical)("reverse", ctx_r2.tdsReverse)("offset", handle_r4.offset)("value", handle_r4.value)("active", handle_r4.active)("tooltipFormatter", ctx_r2.tdsTipFormatter)("tooltipVisible", ctx_r2.tdsTooltipVisible)("tooltipPlacement", ctx_r2.tdsTooltipPlacement)("dir", ctx_r2.dir);
} }
function TDSSliderComponent_tds_slider_marks_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "tds-slider-marks", 6);
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("vertical", ctx_r3.tdsVertical)("min", ctx_r3.tdsMin)("max", ctx_r3.tdsMax)("lowerBound", ctx_r3.bounds.lower)("upperBound", ctx_r3.bounds.upper)("marksArray", ctx_r3.marksArray)("included", ctx_r3.tdsIncluded)("reverse", ctx_r3.tdsReverse);
} }
const _c1 = function (a0, a1, a2) { return { " mx-1.5 my-2.5 p-0 h-2": a0, "w-5 h-full mx-2.5 my-1.5 px-1 py-0": a1, "mb-7": a2 }; };
const _c2 = function (a0, a1) { return { "h-2 w-full": a0, " w-2 h-full": a1 }; };
class TDSSliderComponent {
    constructor(sliderService, cdr, platform, directionality) {
        this.sliderService = sliderService;
        this.cdr = cdr;
        this.platform = platform;
        this.directionality = directionality;
        this.tdsDisabled = false;
        this.tdsDots = false;
        this.tdsIncluded = true;
        this.tdsRange = false;
        this.tdsVertical = false;
        this.tdsReverse = false;
        this.tdsMarks = null;
        this.tdsMax = 100;
        this.tdsMin = 0;
        this.tdsStep = 1;
        this.tdsTooltipVisible = 'default';
        this.tdsTooltipPlacement = 'top';
        this.tdsOnAfterChange = new EventEmitter();
        this.value = null;
        this.cacheSliderStart = null;
        this.cacheSliderLength = null;
        this.activeValueIndex = undefined; // Current activated handle's index ONLY for range=true
        this.track = { offset: null, length: null }; // Track's offset and length
        this.handles = []; // Handles' offset
        this.marksArray = null; // "steps" in array type with more data & FILTER out the invalid mark
        this.bounds = { lower: null, upper: null }; // now for tds-slider-step
        this.dir = 'ltr';
        this.destroy$ = new Subject();
    }
    ngOnInit() {
        this.dir = this.directionality.value;
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.cdr.detectChanges();
            this.updateTrackAndHandles();
            this.onValueChange(this.getValue(true));
        });
        this.handles = generateHandlers(this.tdsRange ? 2 : 1);
        this.marksArray = this.tdsMarks ? this.generateMarkItems(this.tdsMarks) : null;
        this.bindDraggingHandlers();
        this.toggleDragDisabled(this.tdsDisabled);
        if (this.getValue() === null) {
            this.setValue(this.formatValue(null));
        }
    }
    ngOnChanges(changes) {
        const { tdsDisabled, tdsMarks, tdsRange } = changes;
        if (tdsDisabled && !tdsDisabled.firstChange) {
            this.toggleDragDisabled(tdsDisabled.currentValue);
        }
        else if (tdsMarks && !tdsMarks.firstChange) {
            this.marksArray = this.tdsMarks ? this.generateMarkItems(this.tdsMarks) : null;
        }
        else if (tdsRange && !tdsRange.firstChange) {
            this.handles = generateHandlers(tdsRange.currentValue ? 2 : 1);
            this.setValue(this.formatValue(null));
        }
    }
    ngOnDestroy() {
        this.unsubscribeDrag();
        this.destroy$.next();
        this.destroy$.complete();
    }
    writeValue(val) {
        this.setValue(val, true);
    }
    onValueChange(_value) { }
    onTouched() { }
    registerOnChange(fn) {
        this.onValueChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.tdsDisabled = isDisabled;
        this.toggleDragDisabled(isDisabled);
    }
    /**
     * Event handler is only triggered when a slider handler is focused.
     */
    onKeyDown(e) {
        if (this.tdsDisabled) {
            return;
        }
        const code = e.keyCode;
        const isIncrease = code === RIGHT_ARROW || code === UP_ARROW;
        const isDecrease = code === LEFT_ARROW || code === DOWN_ARROW;
        if (!(isIncrease || isDecrease)) {
            return;
        }
        e.preventDefault();
        let step = (isDecrease ? -this.tdsStep : this.tdsStep) * (this.tdsReverse ? -1 : 1);
        step = this.dir === 'rtl' ? step * -1 : step;
        const newVal = this.tdsRange
            ? this.value[this.activeValueIndex] + step
            : this.value + step;
        this.setActiveValue(ensureNumberInRange(newVal, this.tdsMin, this.tdsMax));
        this.tdsOnAfterChange.emit(this.getValue(true));
    }
    onHandleFocusIn(index) {
        this.activeValueIndex = index;
    }
    setValue(value, isWriteValue = false) {
        if (isWriteValue) {
            this.value = this.formatValue(value);
            this.updateTrackAndHandles();
        }
        else if (!valuesEqual(this.value, value)) {
            this.value = value;
            this.updateTrackAndHandles();
            this.onValueChange(this.getValue(true));
        }
    }
    getValue(cloneAndSort = false) {
        if (cloneAndSort && this.value && isValueRange(this.value)) {
            return [...this.value].sort((a, b) => a - b);
        }
        return this.value;
    }
    /**
     * Clone & sort current value and convert them to offsets, then return the new one.
     */
    getValueToOffset(value) {
        let normalizedValue = value;
        if (typeof normalizedValue === 'undefined') {
            normalizedValue = this.getValue(true);
        }
        return isValueRange(normalizedValue)
            ? normalizedValue.map(val => this.valueToOffset(val))
            : this.valueToOffset(normalizedValue);
    }
    /**
     * Find the closest value to be activated.
     */
    setActiveValueIndex(pointerValue) {
        const value = this.getValue();
        if (isValueRange(value)) {
            let minimal = null;
            let gap;
            let activeIndex = -1;
            value.forEach((val, index) => {
                gap = Math.abs(pointerValue - val);
                if (minimal === null || gap < minimal) {
                    minimal = gap;
                    activeIndex = index;
                }
            });
            this.activeValueIndex = activeIndex;
            this.handlerComponents.toArray()[activeIndex].focus();
        }
        else {
            this.handlerComponents.toArray()[0].focus();
        }
    }
    setActiveValue(pointerValue) {
        if (isValueRange(this.value)) {
            const newValue = [...this.value];
            newValue[this.activeValueIndex] = pointerValue;
            this.setValue(newValue);
        }
        else {
            this.setValue(pointerValue);
        }
    }
    /**
     * Update track and handles' position and length.
     */
    updateTrackAndHandles() {
        const value = this.getValue();
        const offset = this.getValueToOffset(value);
        const valueSorted = this.getValue(true);
        const offsetSorted = this.getValueToOffset(valueSorted);
        const boundParts = isValueRange(valueSorted) ? valueSorted : [0, valueSorted];
        const trackParts = isValueRange(offsetSorted)
            ? [offsetSorted[0], offsetSorted[1] - offsetSorted[0]]
            : [0, offsetSorted];
        this.handles.forEach((handle, index) => {
            handle.offset = isValueRange(offset) ? offset[index] : offset;
            handle.value = isValueRange(value) ? value[index] : value || 0;
        });
        [this.bounds.lower, this.bounds.upper] = boundParts;
        [this.track.offset, this.track.length] = trackParts;
        this.cdr.markForCheck();
    }
    onDragStart(value) {
        this.toggleDragMoving(true);
        this.cacheSliderProperty();
        this.setActiveValueIndex(this.getLogicalValue(value));
        this.setActiveValue(this.getLogicalValue(value));
        this.showHandleTooltip(this.tdsRange ? this.activeValueIndex : 0);
    }
    onDragMove(value) {
        this.setActiveValue(this.getLogicalValue(value));
        this.cdr.markForCheck();
    }
    getLogicalValue(value) {
        if (this.tdsReverse) {
            if (!this.tdsVertical && this.dir === 'rtl') {
                return value;
            }
            return this.tdsMax - value + this.tdsMin;
        }
        if (!this.tdsVertical && this.dir === 'rtl') {
            return this.tdsMax - value + this.tdsMin;
        }
        return value;
    }
    onDragEnd() {
        this.tdsOnAfterChange.emit(this.getValue(true));
        this.toggleDragMoving(false);
        this.cacheSliderProperty(true);
        this.hideAllHandleTooltip();
        this.cdr.markForCheck();
    }
    /**
     * Create user interactions handles.
     */
    bindDraggingHandlers() {
        if (!this.platform.isBrowser) {
            return;
        }
        const sliderDOM = this.slider.nativeElement;
        const orientField = this.tdsVertical ? 'pageY' : 'pageX';
        const mouse = {
            start: 'mousedown',
            move: 'mousemove',
            end: 'mouseup',
            pluckKey: [orientField]
        };
        const touch = {
            start: 'touchstart',
            move: 'touchmove',
            end: 'touchend',
            pluckKey: ['touches', '0', orientField],
            filter: (e) => e instanceof TouchEvent
        };
        [mouse, touch].forEach(source => {
            const { start, move, end, pluckKey, filter: filterFunc = () => true } = source;
            source.startPlucked$ = fromEvent(sliderDOM, start).pipe(filter(filterFunc), tap(silentEvent), pluck(...pluckKey), map((position) => this.findClosestValue(position)));
            source.end$ = fromEvent(document, end);
            source.moveResolved$ = fromEvent(document, move).pipe(filter(filterFunc), tap(silentEvent), pluck(...pluckKey), distinctUntilChanged(), map((position) => this.findClosestValue(position)), distinctUntilChanged(), takeUntil(source.end$));
        });
        this.dragStart$ = merge(mouse.startPlucked$, touch.startPlucked$);
        this.dragMove$ = merge(mouse.moveResolved$, touch.moveResolved$);
        this.dragEnd$ = merge(mouse.end$, touch.end$);
    }
    subscribeDrag(periods = ['start', 'move', 'end']) {
        if (periods.indexOf('start') !== -1 && this.dragStart$ && !this.dragStart_) {
            this.dragStart_ = this.dragStart$.subscribe(this.onDragStart.bind(this));
        }
        if (periods.indexOf('move') !== -1 && this.dragMove$ && !this.dragMove_) {
            this.dragMove_ = this.dragMove$.subscribe(this.onDragMove.bind(this));
        }
        if (periods.indexOf('end') !== -1 && this.dragEnd$ && !this.dragEnd_) {
            this.dragEnd_ = this.dragEnd$.subscribe(this.onDragEnd.bind(this));
        }
    }
    unsubscribeDrag(periods = ['start', 'move', 'end']) {
        if (periods.indexOf('start') !== -1 && this.dragStart_) {
            this.dragStart_.unsubscribe();
            this.dragStart_ = null;
        }
        if (periods.indexOf('move') !== -1 && this.dragMove_) {
            this.dragMove_.unsubscribe();
            this.dragMove_ = null;
        }
        if (periods.indexOf('end') !== -1 && this.dragEnd_) {
            this.dragEnd_.unsubscribe();
            this.dragEnd_ = null;
        }
    }
    toggleDragMoving(movable) {
        const periods = ['move', 'end'];
        if (movable) {
            this.sliderService.isDragging = true;
            this.subscribeDrag(periods);
        }
        else {
            this.sliderService.isDragging = false;
            this.unsubscribeDrag(periods);
        }
    }
    toggleDragDisabled(disabled) {
        if (disabled) {
            this.unsubscribeDrag();
        }
        else {
            this.subscribeDrag(['start']);
        }
    }
    findClosestValue(position) {
        const sliderStart = this.getSliderStartPosition();
        const sliderLength = this.getSliderLength();
        const ratio = ensureNumberInRange((position - sliderStart) / sliderLength, 0, 1);
        const val = (this.tdsMax - this.tdsMin) * (this.tdsVertical ? 1 - ratio : ratio) + this.tdsMin;
        const points = this.tdsMarks === null
            ? []
            : Object.keys(this.tdsMarks)
                .map(parseFloat)
                .sort((a, b) => a - b);
        if (this.tdsStep !== 0 && !this.tdsDots) {
            const closestOne = Math.round(val / this.tdsStep) * this.tdsStep;
            points.push(closestOne);
        }
        const gaps = points.map(point => Math.abs(val - point));
        const closest = points[gaps.indexOf(Math.min(...gaps))];
        // return parseFloat(closest.toFixed(getPrecision(this.tdsStep)));
        return this.tdsStep === 0 ? closest : parseFloat(closest.toFixed(getPrecision(this.tdsStep)));
    }
    valueToOffset(value) {
        return getPercent(this.tdsMin, this.tdsMax, value);
    }
    getSliderStartPosition() {
        if (this.cacheSliderStart !== null) {
            return this.cacheSliderStart;
        }
        const offset = getElementOffset(this.slider.nativeElement);
        return this.tdsVertical ? offset.top : offset.left;
    }
    getSliderLength() {
        if (this.cacheSliderLength !== null) {
            return this.cacheSliderLength;
        }
        const sliderDOM = this.slider.nativeElement;
        return this.tdsVertical ? sliderDOM.clientHeight : sliderDOM.clientWidth;
    }
    /**
     * Cache DOM layout/reflow operations for performance (may not necessary?)
     */
    cacheSliderProperty(remove = false) {
        this.cacheSliderStart = remove ? null : this.getSliderStartPosition();
        this.cacheSliderLength = remove ? null : this.getSliderLength();
    }
    formatValue(value) {
        if (isNil(value)) {
            return this.tdsRange ? [this.tdsMin, this.tdsMax] : this.tdsMin;
        }
        else if (assertValueValid(value, this.tdsRange)) {
            return isValueRange(value)
                ? value.map(val => ensureNumberInRange(val, this.tdsMin, this.tdsMax))
                : ensureNumberInRange(value, this.tdsMin, this.tdsMax);
        }
        else {
            return this.tdsDefaultValue ? this.tdsDefaultValue : this.tdsRange ? [this.tdsMin, this.tdsMax] : this.tdsMin;
        }
    }
    /**
     * Show one handle's tooltip and hide others'.
     */
    showHandleTooltip(handleIndex = 0) {
        this.handles.forEach((handle, index) => {
            handle.active = index === handleIndex;
        });
    }
    hideAllHandleTooltip() {
        this.handles.forEach(handle => (handle.active = false));
    }
    generateMarkItems(marks) {
        const marksArray = [];
        for (const key in marks) {
            if (marks.hasOwnProperty(key)) {
                const mark = marks[key];
                const val = typeof key === 'number' ? key : parseFloat(key);
                if (val >= this.tdsMin && val <= this.tdsMax) {
                    marksArray.push({ value: val, offset: this.valueToOffset(val), config: mark });
                }
            }
        }
        return marksArray.length ? marksArray : null;
    }
}
TDSSliderComponent.ɵfac = function TDSSliderComponent_Factory(t) { return new (t || TDSSliderComponent)(i0.ɵɵdirectiveInject(TDSSliderService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2$1.Platform), i0.ɵɵdirectiveInject(i3.Directionality, 8)); };
TDSSliderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSSliderComponent, selectors: [["tds-slider"]], viewQuery: function TDSSliderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(TDSSliderHandleComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.slider = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.handlerComponents = _t);
    } }, hostBindings: function TDSSliderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("keydown", function TDSSliderComponent_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); });
    } }, inputs: { tdsDisabled: "tdsDisabled", tdsDots: "tdsDots", tdsIncluded: "tdsIncluded", tdsRange: "tdsRange", tdsVertical: "tdsVertical", tdsReverse: "tdsReverse", tdsDefaultValue: "tdsDefaultValue", tdsMarks: "tdsMarks", tdsMax: "tdsMax", tdsMin: "tdsMin", tdsStep: "tdsStep", tdsTooltipVisible: "tdsTooltipVisible", tdsTooltipPlacement: "tdsTooltipPlacement", tdsTipFormatter: "tdsTipFormatter" }, outputs: { tdsOnAfterChange: "tdsOnAfterChange" }, exportAs: ["tdsSlider"], features: [i0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TDSSliderComponent),
                multi: true
            },
            TDSSliderService
        ]), i0.ɵɵNgOnChangesFeature], decls: 7, vars: 30, consts: [[1, "tds-slider", "box-border", "relative", "cursor-pointer", "touch-none", "disabled:cursor-not-allowed", 3, "ngClass"], ["slider", ""], [1, "tds-slider-rail", "absolute", "bg-neutral-2-100", "dark:bg-d-neutral-2-300", "rounded-full", "transition-colors", "duration-300", 3, "ngClass"], [3, "vertical", "included", "offset", "length", "reverse", "dir"], [3, "vertical", "min", "max", "lowerBound", "upperBound", "marksArray", "included", "reverse", 4, "ngIf"], [3, "cursor-not-allowed", "cursor-pointer", "vertical", "reverse", "offset", "value", "active", "tooltipFormatter", "tooltipVisible", "tooltipPlacement", "dir", "focusin", 4, "ngFor", "ngForOf"], [3, "vertical", "min", "max", "lowerBound", "upperBound", "marksArray", "included", "reverse"], [3, "vertical", "reverse", "offset", "value", "active", "tooltipFormatter", "tooltipVisible", "tooltipPlacement", "dir", "focusin"]], template: function TDSSliderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵelement(2, "div", 2)(3, "tds-slider-track", 3);
        i0.ɵɵtemplate(4, TDSSliderComponent_tds_slider_step_4_Template, 1, 8, "tds-slider-step", 4);
        i0.ɵɵtemplate(5, TDSSliderComponent_tds_slider_handle_5_Template, 1, 13, "tds-slider-handle", 5);
        i0.ɵɵtemplate(6, TDSSliderComponent_tds_slider_marks_6_Template, 1, 8, "tds-slider-marks", 4);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵclassProp("tds-slider-rtl", ctx.dir === "rtl")("tds-slider-disabled", ctx.tdsDisabled)("cursor-not-allowed", ctx.tdsDisabled)("cursor-pointer", !ctx.tdsDisabled)("tds-slider-vertical", ctx.tdsVertical)("tds-slider-with-marks", ctx.marksArray);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(23, _c1, !ctx.tdsVertical, ctx.tdsVertical, ctx.marksArray));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(27, _c2, !ctx.tdsVertical, ctx.tdsVertical));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("vertical", ctx.tdsVertical)("included", ctx.tdsIncluded)("offset", ctx.track.offset)("length", ctx.track.length)("reverse", ctx.tdsReverse)("dir", ctx.dir);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.marksArray);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.handles);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.marksArray);
    } }, directives: [i1.NgClass, TDSSliderTrackComponent, i3.Dir, i1.NgIf, TDSSliderStepComponent, i1.NgForOf, TDSSliderHandleComponent, TDSSliderMarksComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSSliderComponent.prototype, "tdsDisabled", void 0);
__decorate([
    InputBoolean()
], TDSSliderComponent.prototype, "tdsDots", void 0);
__decorate([
    InputBoolean()
], TDSSliderComponent.prototype, "tdsIncluded", void 0);
__decorate([
    InputBoolean()
], TDSSliderComponent.prototype, "tdsRange", void 0);
__decorate([
    InputBoolean()
], TDSSliderComponent.prototype, "tdsVertical", void 0);
__decorate([
    InputBoolean()
], TDSSliderComponent.prototype, "tdsReverse", void 0);
__decorate([
    InputNumber()
], TDSSliderComponent.prototype, "tdsMax", void 0);
__decorate([
    InputNumber()
], TDSSliderComponent.prototype, "tdsMin", void 0);
__decorate([
    InputNumber()
], TDSSliderComponent.prototype, "tdsStep", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSSliderComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                selector: 'tds-slider',
                exportAs: 'tdsSlider',
                preserveWhitespaces: false,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => TDSSliderComponent),
                        multi: true
                    },
                    TDSSliderService
                ],
                host: {
                    '(keydown)': 'onKeyDown($event)',
                },
                template: `
    <div
      #slider
      class="tds-slider box-border relative  cursor-pointer touch-none disabled:cursor-not-allowed"
      [class.tds-slider-rtl]="dir === 'rtl'"
      [class.tds-slider-disabled]="tdsDisabled"
      [class.cursor-not-allowed] ="tdsDisabled"
      [class.cursor-pointer] ="!tdsDisabled"
      [class.tds-slider-vertical]="tdsVertical"
      [class.tds-slider-with-marks]="marksArray"
      [ngClass]="{' mx-1.5 my-2.5 p-0 h-2':!tdsVertical,'w-5 h-full mx-2.5 my-1.5 px-1 py-0':tdsVertical,'mb-7':marksArray}"
    >
      <div class="tds-slider-rail absolute bg-neutral-2-100 dark:bg-d-neutral-2-300 rounded-full transition-colors duration-300 "
      [ngClass]="{'h-2 w-full':!tdsVertical,' w-2 h-full':tdsVertical}"
      ></div>
      <tds-slider-track
        [vertical]="tdsVertical"
        [included]="tdsIncluded"
        [offset]="track.offset!"
        [length]="track.length!"
        [reverse]="tdsReverse"
        [dir]="dir"
        
      ></tds-slider-track>
      <tds-slider-step
        *ngIf="marksArray"
        [vertical]="tdsVertical"
        [min]="tdsMin"
        [max]="tdsMax"
        [lowerBound]="$any(bounds.lower)"
        [upperBound]="$any(bounds.upper)"
        [marksArray]="marksArray"
        [included]="tdsIncluded"
        [reverse]="tdsReverse"
      ></tds-slider-step>
      <tds-slider-handle
      [class.cursor-not-allowed] ="tdsDisabled"
      [class.cursor-pointer] ="!tdsDisabled"
        *ngFor="let handle of handles; index as handleIndex"
        [vertical]="tdsVertical"
        [reverse]="tdsReverse"
        [offset]="handle.offset!"
        [value]="handle.value!"
        [active]="handle.active"
        [tooltipFormatter]="tdsTipFormatter"
        [tooltipVisible]="tdsTooltipVisible"
        [tooltipPlacement]="tdsTooltipPlacement"
        [dir]="dir"
        (focusin)="onHandleFocusIn(handleIndex)"
      ></tds-slider-handle>
      <tds-slider-marks
        *ngIf="marksArray"
        [vertical]="tdsVertical"
        [min]="tdsMin"
        [max]="tdsMax"
        [lowerBound]="$any(bounds.lower)"
        [upperBound]="$any(bounds.upper)"
        [marksArray]="marksArray"
        [included]="tdsIncluded"
        [reverse]="tdsReverse"
      ></tds-slider-marks>
    </div>
  `
            }]
    }], function () { return [{ type: TDSSliderService }, { type: i0.ChangeDetectorRef }, { type: i2$1.Platform }, { type: i3.Directionality, decorators: [{
                type: Optional
            }] }]; }, { slider: [{
            type: ViewChild,
            args: ['slider', { static: true }]
        }], handlerComponents: [{
            type: ViewChildren,
            args: [TDSSliderHandleComponent]
        }], tdsDisabled: [{
            type: Input
        }], tdsDots: [{
            type: Input
        }], tdsIncluded: [{
            type: Input
        }], tdsRange: [{
            type: Input
        }], tdsVertical: [{
            type: Input
        }], tdsReverse: [{
            type: Input
        }], tdsDefaultValue: [{
            type: Input
        }], tdsMarks: [{
            type: Input
        }], tdsMax: [{
            type: Input
        }], tdsMin: [{
            type: Input
        }], tdsStep: [{
            type: Input
        }], tdsTooltipVisible: [{
            type: Input
        }], tdsTooltipPlacement: [{
            type: Input
        }], tdsTipFormatter: [{
            type: Input
        }], tdsOnAfterChange: [{
            type: Output
        }] }); })();
function getValueTypeNotMatchError() {
    return new Error(`The "tdsRange" can't match the "ngModel"'s type, please check these properties: "tdsRange", "ngModel", "tdsDefaultValue".`);
}
function isValueRange(value) {
    if (value instanceof Array) {
        return value.length === 2;
    }
    else {
        return false;
    }
}
function generateHandlers(amount) {
    return Array(amount)
        .fill(0)
        .map(() => ({ offset: null, value: null, active: false }));
}
/**
 * Check if value is valid and throw error if value-type/range not match.
 */
function assertValueValid(value, isRange) {
    if ((!isValueRange(value) && isNaN(value)) || (isValueRange(value) && value.some(v => isNaN(v)))) {
        return false;
    }
    return assertValueTypeMatch(value, isRange);
}
/**
 * Assert that if `this.tdsRange` is `true`, value is also a range, vice versa.
 */
function assertValueTypeMatch(value, isRange = false) {
    if (isValueRange(value) !== isRange) {
        throw getValueTypeNotMatchError();
    }
    return true;
}
function valuesEqual(valA, valB) {
    if (typeof valA !== typeof valB) {
        return false;
    }
    return isValueRange(valA) && isValueRange(valB) ? arraysEqual(valA, valB) : valA === valB;
}

class TDSSliderModule {
}
TDSSliderModule.ɵfac = function TDSSliderModule_Factory(t) { return new (t || TDSSliderModule)(); };
TDSSliderModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TDSSliderModule });
TDSSliderModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[BidiModule, CommonModule, PlatformModule, TDSToolTipModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSSliderModule, [{
        type: NgModule,
        args: [{
                exports: [
                    TDSSliderComponent,
                    TDSSliderTrackComponent,
                    TDSSliderHandleComponent,
                    TDSSliderStepComponent,
                    TDSSliderMarksComponent
                ],
                declarations: [
                    TDSSliderComponent,
                    TDSSliderTrackComponent,
                    TDSSliderHandleComponent,
                    TDSSliderStepComponent,
                    TDSSliderMarksComponent
                ],
                imports: [BidiModule, CommonModule, PlatformModule, TDSToolTipModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TDSSliderModule, { declarations: [TDSSliderComponent,
        TDSSliderTrackComponent,
        TDSSliderHandleComponent,
        TDSSliderStepComponent,
        TDSSliderMarksComponent], imports: [BidiModule, CommonModule, PlatformModule, TDSToolTipModule], exports: [TDSSliderComponent,
        TDSSliderTrackComponent,
        TDSSliderHandleComponent,
        TDSSliderStepComponent,
        TDSSliderMarksComponent] }); })();

class TDSMarks {
}

/**
 * Generated bundle index. Do not edit.
 */

export { TDSMarks, TDSSliderComponent, TDSSliderModule, TDSSliderHandleComponent as ɵTDSSliderHandleComponent, TDSSliderMarksComponent as ɵTDSSliderMarksComponent, TDSSliderService as ɵTDSSliderService, TDSSliderStepComponent as ɵTDSSliderStepComponent, TDSSliderTrackComponent as ɵTDSSliderTrackComponent };
//# sourceMappingURL=tds-ui-slider.mjs.map
