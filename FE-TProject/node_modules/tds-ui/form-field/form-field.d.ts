import { AfterViewInit, ChangeDetectorRef, InjectionToken, QueryList } from "@angular/core";
import { AfterContentInit } from "@angular/core";
import { OnDestroy } from "@angular/core";
import { AfterContentChecked } from "@angular/core";
import { ElementRef } from "@angular/core";
import { AbstractControl, NgControl } from "@angular/forms";
import { ButtonSize } from "tds-ui/core/config";
import { TDSAddOnLeft, TDSAddOnRight } from "./add-on";
import { TDSError } from "./error";
import { InputColor } from "./form-field-color";
import { TDSFormFieldControl } from "./form-field-control";
import { TDSLabel } from "./label";
import { TDSPrefix } from "./prefix";
import { TDSSuffix } from "./suffix";
import * as i0 from "@angular/core";
export declare const TDS_FORM_FIELD: InjectionToken<TDSFormField>;
export declare class TDSFormField implements AfterContentInit, AfterContentChecked, AfterViewInit, OnDestroy {
    _elementRef: ElementRef;
    private _changeDetectorRef;
    private readonly _destroyed;
    private _color;
    private _size;
    private _tdsClass;
    private _tdsClassDefault;
    clsContainer: string;
    tdsClass: string;
    get color(): InputColor;
    set color(val: InputColor);
    get size(): ButtonSize;
    readonly _labelId: string;
    _connectionContainerRef: ElementRef;
    _inputContainerRef: ElementRef;
    _controlNonStatic: TDSFormFieldControl<any>;
    _controlStatic: TDSFormFieldControl<any>;
    get _control(): TDSFormFieldControl<any>;
    set _control(value: TDSFormFieldControl<any>);
    private _explicitFormFieldControl;
    _labelChildNonStatic: TDSLabel;
    _labelChildStatic: TDSLabel;
    _labelChildChildren: QueryList<TDSLabel>;
    _errorChildren: QueryList<TDSError>;
    _prefixChildren: QueryList<TDSPrefix>;
    _suffixChildren: QueryList<TDSSuffix>;
    _addOnLeftChildren: QueryList<TDSAddOnLeft>;
    _addOnRightChildren: QueryList<TDSAddOnRight>;
    constructor(_elementRef: ElementRef, _changeDetectorRef: ChangeDetectorRef);
    /**
  * Gets an ElementRef for the element that a overlay attached to the form-field should be
  * positioned relative to.
  */
    getConnectedOverlayOrigin(): ElementRef;
    ngAfterContentInit(): void;
    ngAfterContentChecked(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
      * Gets the id of the label element. If no label is present, returns `null`.
      */
    getLabelId(): string | null;
    /** Determines whether a class from the NgControl should be forwarded to the host element. */
    _shouldForward(prop: keyof NgControl): boolean;
    _hasPlaceholder(): boolean;
    _hasLabel(): boolean;
    /** Determines whether to display hints or errors. */
    _getDisplayedMessages(): string | undefined;
    _hasAddOnRightChildren(): boolean;
    _hasAddOnLeftChildren(): boolean;
    _hasSuffixChildren(): boolean;
    _hasPrefixChildren(): boolean;
    get hasRequired(): boolean;
    hasRequiredValidator(control: AbstractControl | null | undefined): boolean;
    /**
     * Sets the list of element IDs that describe the child control. This allows the control to update
     * its `aria-describedby` attribute accordingly.
     */
    private _syncDescribedByIds;
    /** Throws an error if the form field's control is missing. */
    protected _validateControlChild(): void;
    private updateCssContainer;
    private p_GetBorderRadius;
    private p_ClassFocus;
    private p_getClassBorderByColor;
    private p_getClassFocusByColor;
    static ɵfac: i0.ɵɵFactoryDeclaration<TDSFormField, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TDSFormField, "tds-form-field", ["taFormField"], { "tdsClass": "tdsClass"; "color": "color"; }, {}, ["_controlNonStatic", "_controlStatic", "_labelChildNonStatic", "_labelChildStatic", "_labelChildChildren", "_errorChildren", "_prefixChildren", "_suffixChildren", "_addOnLeftChildren", "_addOnRightChildren"], ["tds-label", "[tdsAddOnLeft]", "[tdsPrefix]", "*", "[tdsSuffix]", "tds-error", "tds-warning", "tds-success", "[tdsAddOnRight]"]>;
}
//# sourceMappingURL=form-field.d.ts.map