import { __decorate } from "tslib";
import { ChangeDetectionStrategy, Component, Input, Optional, ViewEncapsulation } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { InputBoolean, InputNumber, TDSHelperObject, TDSHelperString } from 'tds-ui/shared/utility';
import { handleCircleGradient, handleLinearGradient } from './utils';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/bidi";
import * as i2 from "@angular/common";
import * as i3 from "tds-ui/core/outlet";
function TDSProgressComponent_ng_template_0_span_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "span", 1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", ctx_r5.icon);
} }
function TDSProgressComponent_ng_template_0_span_0_ng_template_2_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const formatter_r9 = ctx.$implicit;
    const ctx_r8 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1(" ", formatter_r9(ctx_r8.percent), " ");
} }
const _c0 = function (a0) { return { $implicit: a0 }; };
function TDSProgressComponent_ng_template_0_span_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, TDSProgressComponent_ng_template_0_span_0_ng_template_2_ng_container_0_Template, 2, 1, "ng-container", 8);
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("tdsStringTemplateOutlet", ctx_r7.formatter)("tdsStringTemplateOutletContext", i0.ɵɵpureFunction1(2, _c0, ctx_r7.percent));
} }
const _c1 = function (a0) { return { "p-0 m-0 absolute w-full inset-0 flex items-center justify-center": a0 }; };
function TDSProgressComponent_ng_template_0_span_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 5);
    i0.ɵɵtemplate(1, TDSProgressComponent_ng_template_0_span_0_ng_container_1_Template, 2, 1, "ng-container", 6);
    i0.ɵɵtemplate(2, TDSProgressComponent_ng_template_0_span_0_ng_template_2_Template, 1, 4, "ng-template", null, 7, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r6 = i0.ɵɵreference(3);
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(3, _c1, ctx_r4.isCircleStyle));
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", (ctx_r4._status === "exception" || ctx_r4._status === "success") && !ctx_r4.format)("ngIfElse", _r6);
} }
function TDSProgressComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, TDSProgressComponent_ng_template_0_span_0_Template, 4, 5, "span", 4);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", ctx_r1.showInfo);
} }
function TDSProgressComponent_div_3_ng_container_1_div_1_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 18);
} if (rf & 2) {
    const ctx_r14 = i0.ɵɵnextContext(4);
    i0.ɵɵstyleProp("width", ctx_r14.successPercent, "%")("border-radius", ctx_r14.strokeLinecap === "round" ? "100px" : "0")("height", ctx_r14._strokeWidth, "px");
} }
function TDSProgressComponent_div_3_ng_container_1_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 14)(1, "div", 15);
    i0.ɵɵelement(2, "div", 16);
    i0.ɵɵtemplate(3, TDSProgressComponent_div_3_ng_container_1_div_1_div_3_Template, 1, 6, "div", 17);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("width", ctx_r12.percent, "%")("border-radius", ctx_r12.strokeLinecap === "round" ? "100px" : "0")("background", !ctx_r12.isGradient ? ctx_r12.strokeColor : null)("background-image", ctx_r12.isGradient ? ctx_r12.lineGradient : null)("height", ctx_r12._strokeWidth, "px");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r12.successPercent || ctx_r12.successPercent === 0);
} }
function TDSProgressComponent_div_3_ng_container_1_ng_template_2_Template(rf, ctx) { }
function TDSProgressComponent_div_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, TDSProgressComponent_div_3_ng_container_1_div_1_Template, 4, 11, "div", 12);
    i0.ɵɵtemplate(2, TDSProgressComponent_div_3_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 13);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r10 = i0.ɵɵnextContext(2);
    const _r0 = i0.ɵɵreference(1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r10.isSteps);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r0);
} }
function TDSProgressComponent_div_3_div_2_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 21);
} if (rf & 2) {
    const step_r17 = ctx.$implicit;
    i0.ɵɵproperty("ngStyle", step_r17);
} }
function TDSProgressComponent_div_3_div_2_ng_template_2_Template(rf, ctx) { }
function TDSProgressComponent_div_3_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 19);
    i0.ɵɵtemplate(1, TDSProgressComponent_div_3_div_2_div_1_Template, 1, 1, "div", 20);
    i0.ɵɵtemplate(2, TDSProgressComponent_div_3_div_2_ng_template_2_Template, 0, 0, "ng-template", 13);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext(2);
    const _r0 = i0.ɵɵreference(1);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r11._steps);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r0);
} }
function TDSProgressComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵtemplate(1, TDSProgressComponent_div_3_ng_container_1_Template, 3, 2, "ng-container", 10);
    i0.ɵɵtemplate(2, TDSProgressComponent_div_3_div_2_Template, 3, 2, "div", 11);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r2.isSteps);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r2.isSteps);
} }
function TDSProgressComponent_div_4__svg_defs_2__svg_stop_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelement(0, "stop");
} if (rf & 2) {
    const i_r23 = ctx.$implicit;
    i0.ɵɵattribute("offset", i_r23.offset)("stop-color", i_r23.color);
} }
function TDSProgressComponent_div_4__svg_defs_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "defs")(1, "linearGradient", 26);
    i0.ɵɵtemplate(2, TDSProgressComponent_div_4__svg_defs_2__svg_stop_2_Template, 1, 2, "stop", 27);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("id", "gradient-" + ctx_r19.gradientId);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r19.circleGradient);
} }
function TDSProgressComponent_div_4__svg_path_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "path", 28);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const p_r24 = ctx.$implicit;
    const ctx_r20 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngStyle", p_r24.strokePathStyle);
    i0.ɵɵattribute("d", ctx_r20.pathString)("stroke-linecap", ctx_r20.strokeLinecap)("stroke-width", ctx_r20.percent ? ctx_r20._strokeWidth : 0);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(p_r24.stroke);
} }
function TDSProgressComponent_div_4_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
} }
function TDSProgressComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 22);
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(1, "svg", 23);
    i0.ɵɵtemplate(2, TDSProgressComponent_div_4__svg_defs_2_Template, 3, 2, "defs", 10);
    i0.ɵɵelement(3, "path", 24);
    i0.ɵɵtemplate(4, TDSProgressComponent_div_4__svg_path_4_Template, 2, 5, "path", 25);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(5, TDSProgressComponent_div_4_ng_template_5_Template, 0, 0, "ng-template", 13);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    const _r0 = i0.ɵɵreference(1);
    i0.ɵɵstyleProp("width", ctx_r3.width, "px")("height", ctx_r3.width, "px")("font-size", ctx_r3.width * 0.15 + 6, "px");
    i0.ɵɵclassProp("tds-progress-circle-gradient", ctx_r3.isGradient);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.isGradient);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngStyle", ctx_r3.trailPathStyle);
    i0.ɵɵattribute("stroke-width", ctx_r3._strokeWidth)("d", ctx_r3.pathString);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r3.progressCirclePath)("ngForTrackBy", ctx_r3.trackByFn);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r0);
} }
const _c2 = function (a0) { return { "relative w-full ": a0 }; };
let gradientIdSeed = 0;
const TDS_CONFIG_MODULE_NAME = 'progress';
const statusIconNameMap = new Map([
    ['success', 'success'],
    ['exception', 'error']
]);
const statusColorMap = new Map([
    ['normal', '#28A745'],
    ['exception', '#28A745'],
    ['success', '#28A745']
]);
const defaultFormatter = (p) => `${p}%`;
export class TDSProgressComponent {
    constructor(cdr, 
    // public tdsConfigService: TDSConfigService,
    directionality) {
        this.cdr = cdr;
        this.directionality = directionality;
        this.showInfo = true;
        this.width = 132;
        this.strokeColor = undefined;
        this.size = 'default';
        this.percent = 0;
        this.strokeWidth = undefined;
        this.gapDegree = undefined;
        this.type = 'line';
        this.gapPosition = 'top';
        this.strokeLinecap = 'round';
        this.steps = 0;
        this._steps = [];
        /** Gradient style when `type` is `line`. */
        this.lineGradient = null;
        /** If user uses gradient color. */
        this.isGradient = false;
        /** If the linear progress is a step progress. */
        this.isSteps = false;
        /**
         * Each progress whose `type` is circle or dashboard should have unique id to
         * define `<linearGradient>`.
         */
        this.gradientId = gradientIdSeed++;
        /** Paths to rendered in the template. */
        this.progressCirclePath = [];
        this.trailPathStyle = null;
        this.dir = 'ltr';
        this.trackByFn = (index) => `${index}`;
        this.cachedStatus = 'normal';
        this.inferredStatus = 'normal';
        this.destroy$ = new Subject();
    }
    get formatter() {
        return this.format || defaultFormatter;
    }
    get _status() {
        return this.status || this.inferredStatus;
    }
    get _strokeWidth() {
        return this.strokeWidth || (this.type === 'line' && this.size !== 'small' ? 8 : 6);
    }
    get isCircleStyle() {
        return this.type === 'circle' || this.type === 'dashboard';
    }
    ngOnChanges(changes) {
        const { steps, gapPosition, strokeLinecap, strokeColor, gapDegree, type, status, percent, successPercent, strokeWidth } = changes;
        if (status) {
            this.cachedStatus = this.status || this.cachedStatus;
        }
        if (percent || successPercent) {
            const fillAll = parseInt(this.percent.toString(), 10) >= 100;
            if (fillAll) {
                if ((TDSHelperObject.hasValue(this.successPercent) && this.successPercent >= 100) || this.successPercent === undefined) {
                    this.inferredStatus = 'success';
                }
            }
            else {
                this.inferredStatus = this.cachedStatus;
            }
        }
        if (status || percent || successPercent || strokeColor) {
            this.updateIcon();
        }
        if (strokeColor) {
            this.setStrokeColor();
        }
        if (gapPosition || strokeLinecap || gapDegree || type || percent || strokeColor || strokeColor) {
            this.getCirclePaths();
        }
        if (percent || steps || strokeWidth) {
            this.isSteps = this.steps > 0;
            if (this.isSteps) {
                this.getSteps();
            }
        }
    }
    ngOnInit() {
        // this.tdsConfigService
        //   .getConfigChangeEventForComponent(TDS_CONFIG_MODULE_NAME)
        //   .pipe(takeUntil(this.destroy$))
        //   .subscribe(() => {
        this.updateIcon();
        this.setStrokeColor();
        this.getCirclePaths();
        // });
        this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
            this.dir = direction;
            this.cdr.detectChanges();
        });
        this.dir = this.directionality.value;
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    updateIcon() {
        const ret = statusIconNameMap.get(this._status);
        this.icon = "";
        if (TDSHelperString.hasValueString(ret)) {
            if (!this.isCircleStyle) {
                this.icon = `tdsi-${ret}-fill text-${ret}-400`;
            }
            else {
                switch (ret) {
                    case "error":
                        this.icon = `tdsi-close-fill text-${ret}-400`;
                        break;
                    default:
                        this.icon = `tdsi-tick-fill text-${ret}-400`;
                        break;
                }
            }
        }
    }
    /**
     * Calculate step render configs.
     */
    getSteps() {
        const current = Math.floor(this.steps * (this.percent / 100));
        const stepWidth = this.size === 'small' ? 2 : 14;
        const _steps = [];
        for (let i = 0; i < this.steps; i++) {
            let color;
            if (i <= current - 1) {
                color = this.strokeColor;
            }
            const stepStyle = {
                backgroundColor: `${color}`,
                width: `${stepWidth}px`,
                height: `${this._strokeWidth}px`
            };
            _steps.push(stepStyle);
        }
        this._steps = _steps;
    }
    /**
     * Calculate paths when the type is circle or dashboard.
     */
    getCirclePaths() {
        if (!this.isCircleStyle) {
            return;
        }
        const values = TDSHelperObject.hasValue(this.successPercent) ? [this.successPercent, this.percent] : [this.percent];
        // Calculate shared styles.
        const radius = 50 - this._strokeWidth / 2;
        const gapPosition = this.gapPosition || (this.type === 'circle' ? 'top' : 'bottom');
        const len = Math.PI * 2 * radius;
        const gapDegree = this.gapDegree || (this.type === 'circle' ? 0 : 75);
        let beginPositionX = 0;
        let beginPositionY = -radius;
        let endPositionX = 0;
        let endPositionY = radius * -2;
        switch (gapPosition) {
            case 'left':
                beginPositionX = -radius;
                beginPositionY = 0;
                endPositionX = radius * 2;
                endPositionY = 0;
                break;
            case 'right':
                beginPositionX = radius;
                beginPositionY = 0;
                endPositionX = radius * -2;
                endPositionY = 0;
                break;
            case 'bottom':
                beginPositionY = radius;
                endPositionY = radius * 2;
                break;
            default:
        }
        this.pathString = `M 50,50 m ${beginPositionX},${beginPositionY}
       a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
       a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
        this.trailPathStyle = {
            strokeDasharray: `${len - gapDegree}px ${len}px`,
            strokeDashoffset: `-${gapDegree / 2}px`,
            transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s'
        };
        // Calculate styles for each path.
        this.progressCirclePath = values
            .map((value, index) => {
            const isSuccessPercent = values.length === 2 && index === 0;
            return {
                stroke: this.isGradient && !isSuccessPercent ? `url(#gradient-${this.gradientId})` : null,
                strokePathStyle: {
                    stroke: !this.isGradient ? (isSuccessPercent ? statusColorMap.get('success') : this.strokeColor) : null,
                    transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s',
                    strokeDasharray: `${((value || 0) / 100) * (len - gapDegree)}px ${len}px`,
                    strokeDashoffset: `-${gapDegree / 2}px`
                }
            };
        })
            .reverse();
    }
    setStrokeColor() {
        const color = this.strokeColor;
        const isGradient = (this.isGradient = !!color && typeof color !== 'string');
        if (isGradient && !this.isCircleStyle) {
            this.lineGradient = handleLinearGradient(color);
        }
        else if (isGradient && this.isCircleStyle) {
            this.circleGradient = handleCircleGradient(this.strokeColor);
        }
        else {
            this.lineGradient = null;
            this.circleGradient = [];
        }
    }
}
TDSProgressComponent.ɵfac = function TDSProgressComponent_Factory(t) { return new (t || TDSProgressComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.Directionality, 8)); };
TDSProgressComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSProgressComponent, selectors: [["tds-progress"]], inputs: { showInfo: "showInfo", width: "width", strokeColor: "strokeColor", size: "size", format: "format", successPercent: "successPercent", percent: "percent", strokeWidth: "strokeWidth", gapDegree: "gapDegree", status: "status", type: "type", gapPosition: "gapPosition", strokeLinecap: "strokeLinecap", steps: "steps" }, exportAs: ["tdsProgress"], features: [i0.ɵɵNgOnChangesFeature], decls: 5, vars: 20, consts: [["progressInfoTemplate", ""], [3, "ngClass"], ["class", "w-full flex items-center", 4, "ngIf"], ["class", "tds-progress-inner relative", 3, "width", "height", "fontSize", "tds-progress-circle-gradient", 4, "ngIf"], ["class", "tds-progress-text pl-2 text-body-2 font-regular text-neutral-1-900 dark:text-d-neutral-1-900", 3, "ngClass", 4, "ngIf"], [1, "tds-progress-text", "pl-2", "text-body-2", "font-regular", "text-neutral-1-900", "dark:text-d-neutral-1-900", 3, "ngClass"], [4, "ngIf", "ngIfElse"], ["formatTemplate", ""], [4, "tdsStringTemplateOutlet", "tdsStringTemplateOutletContext"], [1, "w-full", "flex", "items-center"], [4, "ngIf"], ["class", "tds-progress-_steps-outer", 4, "ngIf"], ["class", "tds-progress-outer flex-auto", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "tds-progress-outer", "flex-auto"], [1, "tds-progress-inner", "relative", "w-full", "bg-neutral-2-300", "dark:bg-d-neutral-2-300", "overflow-hidden", "rounded-full"], [1, "tds-progress-bg", "bg-primary-1"], ["class", "tds-progress-success-bg  bg-primary-1", 3, "width", "border-radius", "height", 4, "ngIf"], [1, "tds-progress-success-bg", "bg-primary-1"], [1, "tds-progress-_steps-outer"], ["class", "tds-progress-_steps-item", 3, "ngStyle", 4, "ngFor", "ngForOf"], [1, "tds-progress-_steps-item", 3, "ngStyle"], [1, "tds-progress-inner", "relative"], ["viewBox", "0 0 100 100", 1, "tds-progress-circle"], ["fill-opacity", "0", 1, "tds-progress-circle-trail", "stroke-current", "text-neutral-2-300", "dark:text-d-neutral-2-300", 3, "ngStyle"], ["class", "tds-progress-circle-path stroke-current text-success-400", "fill-opacity", "0", 3, "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["x1", "100%", "y1", "0%", "x2", "0%", "y2", "0%", 3, "id"], [4, "ngFor", "ngForOf"], ["fill-opacity", "0", 1, "tds-progress-circle-path", "stroke-current", "text-success-400", 3, "ngStyle"]], template: function TDSProgressComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, TDSProgressComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵelementStart(2, "div", 1);
        i0.ɵɵtemplate(3, TDSProgressComponent_div_3_Template, 3, 2, "div", 2);
        i0.ɵɵtemplate(4, TDSProgressComponent_div_4_Template, 6, 15, "div", 3);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate1("tds-progress  m-0 p-0 border-box  ", "tds-progress-_status-" + ctx._status, "");
        i0.ɵɵclassProp("tds-progress-line", ctx.type == "line")("tds-progress-small", ctx.size == "small")("tds-progress-show-info", ctx.showInfo)("tds-progress-circle", ctx.isCircleStyle)("tds-progress-_steps", ctx.isSteps)("tds-progress-rtl", ctx.dir === "rtl");
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(18, _c2, ctx.type == "line"));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.type === "line");
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.isCircleStyle);
    } }, directives: [i2.NgIf, i2.NgClass, i3.TDSStringTemplateOutletDirective, i2.NgTemplateOutlet, i2.NgForOf, i2.NgStyle], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSProgressComponent.prototype, "showInfo", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "successPercent", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "percent", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "strokeWidth", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "gapDegree", void 0);
__decorate([
    InputNumber()
], TDSProgressComponent.prototype, "steps", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSProgressComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                selector: 'tds-progress',
                exportAs: 'tdsProgress',
                preserveWhitespaces: false,
                template: `
    <ng-template #progressInfoTemplate>
      <span class="tds-progress-text pl-2 text-body-2 font-regular text-neutral-1-900 dark:text-d-neutral-1-900" *ngIf="showInfo" [ngClass]="{'p-0 m-0 absolute w-full inset-0 flex items-center justify-center':isCircleStyle}">
        <ng-container *ngIf="(_status === 'exception' || _status === 'success') && !format; else formatTemplate">
          <span [ngClass]="icon"> </span>
        </ng-container>
        <ng-template #formatTemplate>
          <ng-container *tdsStringTemplateOutlet="formatter; context: { $implicit: percent }; let formatter">
            {{ formatter(percent) }}
          </ng-container>
        </ng-template>
      </span>
    </ng-template>

    <div
      class="tds-progress  m-0 p-0 border-box  {{'tds-progress-_status-' + _status}}"
      [ngClass]="{'relative w-full ':type == 'line'}"
      [class.tds-progress-line]="type == 'line'"
      [class.tds-progress-small]="size == 'small'"
      [class.tds-progress-show-info]="showInfo"
      [class.tds-progress-circle]="isCircleStyle"
      [class.tds-progress-_steps]="isSteps"
      [class.tds-progress-rtl]="dir === 'rtl'"
    >
      <!-- line progress -->
      <div *ngIf="type === 'line'" class="w-full flex items-center">
        <!-- normal line style -->
        <ng-container *ngIf="!isSteps">
          <div class="tds-progress-outer flex-auto" *ngIf="!isSteps">
            <div class="tds-progress-inner relative w-full bg-neutral-2-300 dark:bg-d-neutral-2-300 overflow-hidden rounded-full">
              <div
                class="tds-progress-bg bg-primary-1"
                [style.width.%]="percent"
                [style.border-radius]="strokeLinecap === 'round' ? '100px' : '0'"
                [style.background]="!isGradient ? strokeColor : null"
                [style.background-image]="isGradient ? lineGradient : null"
                [style.height.px]="_strokeWidth"
              ></div>
              <div
                *ngIf="successPercent || successPercent === 0"
                class="tds-progress-success-bg  bg-primary-1"
                [style.width.%]="successPercent"
                [style.border-radius]="strokeLinecap === 'round' ? '100px' : '0'"
                [style.height.px]="_strokeWidth"
              ></div>
            </div>
          </div>
          <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template>
        </ng-container>
        <!-- step style -->
        <div class="tds-progress-_steps-outer" *ngIf="isSteps">
          <div *ngFor="let step of _steps; let i = index" class="tds-progress-_steps-item" [ngStyle]="step"></div>
          <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template>
        </div>
      </div>

      <!-- circle / dashboard progress -->
      <div
        [style.width.px]="this.width"
        [style.height.px]="this.width"
        [style.fontSize.px]="this.width * 0.15 + 6"
        class="tds-progress-inner relative"
        [class.tds-progress-circle-gradient]="isGradient"
        *ngIf="isCircleStyle"
      >
        <svg class="tds-progress-circle " viewBox="0 0 100 100">
          <defs *ngIf="isGradient">
            <linearGradient [id]="'gradient-' + gradientId" x1="100%" y1="0%" x2="0%" y2="0%">
              <stop *ngFor="let i of circleGradient" [attr.offset]="i.offset" [attr.stop-color]="i.color"></stop>
            </linearGradient>
          </defs>
          <path
            class="tds-progress-circle-trail stroke-current text-neutral-2-300 dark:text-d-neutral-2-300"
           
            fill-opacity="0"
            [attr.stroke-width]="_strokeWidth"
            [attr.d]="pathString"
            [ngStyle]="trailPathStyle"
          ></path>
          <path
            *ngFor="let p of progressCirclePath; trackBy: trackByFn"
            class="tds-progress-circle-path stroke-current text-success-400"
            fill-opacity="0"
            [attr.d]="pathString"
            [attr.stroke-linecap]="strokeLinecap"
           
            [attr.stroke-width]="percent ? _strokeWidth : 0"
            [ngStyle]="p.strokePathStyle"
          >{{p.stroke}}</path>
        </svg>
        <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template>
      </div>
    </div>
  `
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.Directionality, decorators: [{
                type: Optional
            }] }]; }, { showInfo: [{
            type: Input
        }], width: [{
            type: Input
        }], strokeColor: [{
            type: Input
        }], size: [{
            type: Input
        }], format: [{
            type: Input
        }], successPercent: [{
            type: Input
        }], percent: [{
            type: Input
        }], strokeWidth: [{
            type: Input
        }], gapDegree: [{
            type: Input
        }], status: [{
            type: Input
        }], type: [{
            type: Input
        }], gapPosition: [{
            type: Input
        }], strokeLinecap: [{
            type: Input
        }], steps: [{
            type: Input
        }] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvdGRzLXVpL3Byb2dyZXNzL3Byb2dyZXNzLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBS0EsT0FBTyxFQUNMLHVCQUF1QixFQUV2QixTQUFTLEVBQ1QsS0FBSyxFQUlMLFFBQVEsRUFFUixpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBY3BHLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLFNBQVMsQ0FBQzs7Ozs7O0lBeUI3RCw2QkFBeUc7SUFDdkcsMEJBQStCO0lBQ2pDLDBCQUFlOzs7SUFEUCxlQUFnQjtJQUFoQixxQ0FBZ0I7OztJQUd0Qiw2QkFBbUc7SUFDakcsWUFDRjtJQUFBLDBCQUFlOzs7O0lBRGIsZUFDRjtJQURFLDZEQUNGOzs7O0lBRkEsMEhBRWU7OztJQUZBLDBEQUFvQyw4RUFBQTs7OztJQUx2RCwrQkFBMk47SUFDek4sNEdBRWU7SUFDZiwySUFJYztJQUNoQixpQkFBTzs7OztJQVRxSCwwRUFBOEY7SUFDek0sZUFBcUU7SUFBckUseUdBQXFFLGlCQUFBOzs7SUFEdEYscUZBU087OztJQVRxRyxzQ0FBYzs7O0lBb0NsSCwwQkFNTzs7O0lBSEwsb0RBQWdDLG9FQUFBLHNDQUFBOzs7SUFidEMsK0JBQTJELGNBQUE7SUFFdkQsMEJBT087SUFDUCxpR0FNTztJQUNULGlCQUFNLEVBQUE7OztJQWJGLGVBQXlCO0lBQXpCLDZDQUF5QixvRUFBQSxnRUFBQSxzRUFBQSxzQ0FBQTtJQU94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O1FBQXJCLDBDQUFxQjtRQXNDeEIsZUFBbUI7UUFBbkIsd0NBQW1COztBQXdDRDtJQUFmLFlBQVksRUFBRTtzREFBMEI7QUFLMUI7SUFBZCxXQUFXLEVBQUU7NERBQXlCO0FBQ3hCO0lBQWQsV0FBVyxFQUFFO3FEQUFxQjtBQUNwQjtJQUFkLFdBQVcsRUFBRTt5REFBa0M7QUFDakM7SUFBZCxXQUFXLEVBQUU7dURBQWdDO0FBTS9CO0lBQWQsV0FBVyxFQUFFO21EQUFtQjt1RkF0Qi9CLG9CQUFvQjtjQXJHaEMsU0FBUztlQUFDO2dCQUNULGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtnQkFDckMsUUFBUSxFQUFFLGNBQWM7Z0JBQ3hCLFFBQVEsRUFBRSxhQUFhO2dCQUN2QixtQkFBbUIsRUFBRSxLQUFLO2dCQUMxQixRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZGVDthQUNGOztzQkE0RUksUUFBUTt3QkFuRWMsUUFBUTtrQkFBaEMsS0FBSztZQUNHLEtBQUs7a0JBQWIsS0FBSztZQUNHLFdBQVc7a0JBQW5CLEtBQUs7WUFDRyxJQUFJO2tCQUFaLEtBQUs7WUFDRyxNQUFNO2tCQUFkLEtBQUs7WUFDa0IsY0FBYztrQkFBckMsS0FBSztZQUNrQixPQUFPO2tCQUE5QixLQUFLO1lBQ2tCLFdBQVc7a0JBQWxDLEtBQUs7WUFDa0IsU0FBUztrQkFBaEMsS0FBSztZQUNHLE1BQU07a0JBQWQsS0FBSztZQUNHLElBQUk7a0JBQVosS0FBSztZQUNHLFdBQVc7a0JBQW5CLEtBQUs7WUFDRyxhQUFhO2tCQUFyQixLQUFLO1lBRWtCLEtBQUs7a0JBQTVCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcbmltcG9ydCB7IERpcmVjdGlvbiwgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XHJcbmltcG9ydCB7IE51bWJlcklucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcclxuaW1wb3J0IHsgRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XHJcbmltcG9ydCB7XHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgQ29tcG9uZW50LFxyXG4gIElucHV0LFxyXG4gIE9uQ2hhbmdlcyxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT25Jbml0LFxyXG4gIE9wdGlvbmFsLFxyXG4gIFNpbXBsZUNoYW5nZXMsXHJcbiAgVmlld0VuY2Fwc3VsYXRpb25cclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IE5nU3R5bGVJbnRlcmZhY2UgfSBmcm9tICd0ZHMtdWkvY29yZS9jb25maWcnO1xyXG5pbXBvcnQgeyBJbnB1dEJvb2xlYW4sIElucHV0TnVtYmVyLCBURFNIZWxwZXJPYmplY3QsIFREU0hlbHBlclN0cmluZyB9IGZyb20gJ3Rkcy11aS9zaGFyZWQvdXRpbGl0eSc7XHJcblxyXG5pbXBvcnQge1xyXG4gIFREU1Byb2dyZXNzQ2lyY2xlUGF0aCxcclxuICBURFNQcm9ncmVzc0NvbG9yR3JhZGllbnQsXHJcbiAgVERTUHJvZ3Jlc3NGb3JtYXR0ZXIsXHJcbiAgVERTUHJvZ3Jlc3NHYXBQb3NpdGlvblR5cGUsXHJcbiAgVERTUHJvZ3Jlc3NHcmFkaWVudFByb2dyZXNzLFxyXG4gIFREU1Byb2dyZXNzU3RhdHVzVHlwZSxcclxuICBURFNQcm9ncmVzc1N0ZXBJdGVtLFxyXG4gIFREU1Byb2dyZXNzU3Ryb2tlQ29sb3JUeXBlLFxyXG4gIFREU1Byb2dyZXNzU3Ryb2tlTGluZWNhcFR5cGUsXHJcbiAgVERTUHJvZ3Jlc3NUeXBlVHlwZVxyXG59IGZyb20gJy4vdHlwaW5ncyc7XHJcbmltcG9ydCB7IGhhbmRsZUNpcmNsZUdyYWRpZW50LCBoYW5kbGVMaW5lYXJHcmFkaWVudCB9IGZyb20gJy4vdXRpbHMnO1xyXG5cclxubGV0IGdyYWRpZW50SWRTZWVkID0gMDtcclxuXHJcbmNvbnN0IFREU19DT05GSUdfTU9EVUxFX05BTUUgPSAncHJvZ3Jlc3MnO1xyXG5jb25zdCBzdGF0dXNJY29uTmFtZU1hcCA9IG5ldyBNYXAoW1xyXG4gIFsnc3VjY2VzcycsICdzdWNjZXNzJ10sXHJcbiAgWydleGNlcHRpb24nLCAnZXJyb3InXVxyXG5dKTtcclxuY29uc3Qgc3RhdHVzQ29sb3JNYXAgPSBuZXcgTWFwKFtcclxuICBbJ25vcm1hbCcsICcjMjhBNzQ1J10sXHJcbiAgWydleGNlcHRpb24nLCAnIzI4QTc0NSddLFxyXG4gIFsnc3VjY2VzcycsICcjMjhBNzQ1J11cclxuXSk7XHJcbmNvbnN0IGRlZmF1bHRGb3JtYXR0ZXI6IFREU1Byb2dyZXNzRm9ybWF0dGVyID0gKHA6IG51bWJlcik6IHN0cmluZyA9PiBgJHtwfSVgO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBzZWxlY3RvcjogJ3Rkcy1wcm9ncmVzcycsXHJcbiAgZXhwb3J0QXM6ICd0ZHNQcm9ncmVzcycsXHJcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxuZy10ZW1wbGF0ZSAjcHJvZ3Jlc3NJbmZvVGVtcGxhdGU+XHJcbiAgICAgIDxzcGFuIGNsYXNzPVwidGRzLXByb2dyZXNzLXRleHQgcGwtMiB0ZXh0LWJvZHktMiBmb250LXJlZ3VsYXIgdGV4dC1uZXV0cmFsLTEtOTAwIGRhcms6dGV4dC1kLW5ldXRyYWwtMS05MDBcIiAqbmdJZj1cInNob3dJbmZvXCIgW25nQ2xhc3NdPVwieydwLTAgbS0wIGFic29sdXRlIHctZnVsbCBpbnNldC0wIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyJzppc0NpcmNsZVN0eWxlfVwiPlxyXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIoX3N0YXR1cyA9PT0gJ2V4Y2VwdGlvbicgfHwgX3N0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSAmJiAhZm9ybWF0OyBlbHNlIGZvcm1hdFRlbXBsYXRlXCI+XHJcbiAgICAgICAgICA8c3BhbiBbbmdDbGFzc109XCJpY29uXCI+IDwvc3Bhbj5cclxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cclxuICAgICAgICA8bmctdGVtcGxhdGUgI2Zvcm1hdFRlbXBsYXRlPlxyXG4gICAgICAgICAgPG5nLWNvbnRhaW5lciAqdGRzU3RyaW5nVGVtcGxhdGVPdXRsZXQ9XCJmb3JtYXR0ZXI7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBwZXJjZW50IH07IGxldCBmb3JtYXR0ZXJcIj5cclxuICAgICAgICAgICAge3sgZm9ybWF0dGVyKHBlcmNlbnQpIH19XHJcbiAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cclxuICAgICAgICA8L25nLXRlbXBsYXRlPlxyXG4gICAgICA8L3NwYW4+XHJcbiAgICA8L25nLXRlbXBsYXRlPlxyXG5cclxuICAgIDxkaXZcclxuICAgICAgY2xhc3M9XCJ0ZHMtcHJvZ3Jlc3MgIG0tMCBwLTAgYm9yZGVyLWJveCAge3sndGRzLXByb2dyZXNzLV9zdGF0dXMtJyArIF9zdGF0dXN9fVwiXHJcbiAgICAgIFtuZ0NsYXNzXT1cInsncmVsYXRpdmUgdy1mdWxsICc6dHlwZSA9PSAnbGluZSd9XCJcclxuICAgICAgW2NsYXNzLnRkcy1wcm9ncmVzcy1saW5lXT1cInR5cGUgPT0gJ2xpbmUnXCJcclxuICAgICAgW2NsYXNzLnRkcy1wcm9ncmVzcy1zbWFsbF09XCJzaXplID09ICdzbWFsbCdcIlxyXG4gICAgICBbY2xhc3MudGRzLXByb2dyZXNzLXNob3ctaW5mb109XCJzaG93SW5mb1wiXHJcbiAgICAgIFtjbGFzcy50ZHMtcHJvZ3Jlc3MtY2lyY2xlXT1cImlzQ2lyY2xlU3R5bGVcIlxyXG4gICAgICBbY2xhc3MudGRzLXByb2dyZXNzLV9zdGVwc109XCJpc1N0ZXBzXCJcclxuICAgICAgW2NsYXNzLnRkcy1wcm9ncmVzcy1ydGxdPVwiZGlyID09PSAncnRsJ1wiXHJcbiAgICA+XHJcbiAgICAgIDwhLS0gbGluZSBwcm9ncmVzcyAtLT5cclxuICAgICAgPGRpdiAqbmdJZj1cInR5cGUgPT09ICdsaW5lJ1wiIGNsYXNzPVwidy1mdWxsIGZsZXggaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgPCEtLSBub3JtYWwgbGluZSBzdHlsZSAtLT5cclxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzU3RlcHNcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZHMtcHJvZ3Jlc3Mtb3V0ZXIgZmxleC1hdXRvXCIgKm5nSWY9XCIhaXNTdGVwc1wiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGRzLXByb2dyZXNzLWlubmVyIHJlbGF0aXZlIHctZnVsbCBiZy1uZXV0cmFsLTItMzAwIGRhcms6YmctZC1uZXV0cmFsLTItMzAwIG92ZXJmbG93LWhpZGRlbiByb3VuZGVkLWZ1bGxcIj5cclxuICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRkcy1wcm9ncmVzcy1iZyBiZy1wcmltYXJ5LTFcIlxyXG4gICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoLiVdPVwicGVyY2VudFwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYm9yZGVyLXJhZGl1c109XCJzdHJva2VMaW5lY2FwID09PSAncm91bmQnID8gJzEwMHB4JyA6ICcwJ1wiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYmFja2dyb3VuZF09XCIhaXNHcmFkaWVudCA/IHN0cm9rZUNvbG9yIDogbnVsbFwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuYmFja2dyb3VuZC1pbWFnZV09XCJpc0dyYWRpZW50ID8gbGluZUdyYWRpZW50IDogbnVsbFwiXHJcbiAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT1cIl9zdHJva2VXaWR0aFwiXHJcbiAgICAgICAgICAgICAgPjwvZGl2PlxyXG4gICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgICpuZ0lmPVwic3VjY2Vzc1BlcmNlbnQgfHwgc3VjY2Vzc1BlcmNlbnQgPT09IDBcIlxyXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ0ZHMtcHJvZ3Jlc3Mtc3VjY2Vzcy1iZyAgYmctcHJpbWFyeS0xXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aC4lXT1cInN1Y2Nlc3NQZXJjZW50XCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS5ib3JkZXItcmFkaXVzXT1cInN0cm9rZUxpbmVjYXAgPT09ICdyb3VuZCcgPyAnMTAwcHgnIDogJzAnXCJcclxuICAgICAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPVwiX3N0cm9rZVdpZHRoXCJcclxuICAgICAgICAgICAgICA+PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwicHJvZ3Jlc3NJbmZvVGVtcGxhdGVcIj48L25nLXRlbXBsYXRlPlxyXG4gICAgICAgIDwvbmctY29udGFpbmVyPlxyXG4gICAgICAgIDwhLS0gc3RlcCBzdHlsZSAtLT5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwidGRzLXByb2dyZXNzLV9zdGVwcy1vdXRlclwiICpuZ0lmPVwiaXNTdGVwc1wiPlxyXG4gICAgICAgICAgPGRpdiAqbmdGb3I9XCJsZXQgc3RlcCBvZiBfc3RlcHM7IGxldCBpID0gaW5kZXhcIiBjbGFzcz1cInRkcy1wcm9ncmVzcy1fc3RlcHMtaXRlbVwiIFtuZ1N0eWxlXT1cInN0ZXBcIj48L2Rpdj5cclxuICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJwcm9ncmVzc0luZm9UZW1wbGF0ZVwiPjwvbmctdGVtcGxhdGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgPCEtLSBjaXJjbGUgLyBkYXNoYm9hcmQgcHJvZ3Jlc3MgLS0+XHJcbiAgICAgIDxkaXZcclxuICAgICAgICBbc3R5bGUud2lkdGgucHhdPVwidGhpcy53aWR0aFwiXHJcbiAgICAgICAgW3N0eWxlLmhlaWdodC5weF09XCJ0aGlzLndpZHRoXCJcclxuICAgICAgICBbc3R5bGUuZm9udFNpemUucHhdPVwidGhpcy53aWR0aCAqIDAuMTUgKyA2XCJcclxuICAgICAgICBjbGFzcz1cInRkcy1wcm9ncmVzcy1pbm5lciByZWxhdGl2ZVwiXHJcbiAgICAgICAgW2NsYXNzLnRkcy1wcm9ncmVzcy1jaXJjbGUtZ3JhZGllbnRdPVwiaXNHcmFkaWVudFwiXHJcbiAgICAgICAgKm5nSWY9XCJpc0NpcmNsZVN0eWxlXCJcclxuICAgICAgPlxyXG4gICAgICAgIDxzdmcgY2xhc3M9XCJ0ZHMtcHJvZ3Jlc3MtY2lyY2xlIFwiIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiPlxyXG4gICAgICAgICAgPGRlZnMgKm5nSWY9XCJpc0dyYWRpZW50XCI+XHJcbiAgICAgICAgICAgIDxsaW5lYXJHcmFkaWVudCBbaWRdPVwiJ2dyYWRpZW50LScgKyBncmFkaWVudElkXCIgeDE9XCIxMDAlXCIgeTE9XCIwJVwiIHgyPVwiMCVcIiB5Mj1cIjAlXCI+XHJcbiAgICAgICAgICAgICAgPHN0b3AgKm5nRm9yPVwibGV0IGkgb2YgY2lyY2xlR3JhZGllbnRcIiBbYXR0ci5vZmZzZXRdPVwiaS5vZmZzZXRcIiBbYXR0ci5zdG9wLWNvbG9yXT1cImkuY29sb3JcIj48L3N0b3A+XHJcbiAgICAgICAgICAgIDwvbGluZWFyR3JhZGllbnQ+XHJcbiAgICAgICAgICA8L2RlZnM+XHJcbiAgICAgICAgICA8cGF0aFxyXG4gICAgICAgICAgICBjbGFzcz1cInRkcy1wcm9ncmVzcy1jaXJjbGUtdHJhaWwgc3Ryb2tlLWN1cnJlbnQgdGV4dC1uZXV0cmFsLTItMzAwIGRhcms6dGV4dC1kLW5ldXRyYWwtMi0zMDBcIlxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICBmaWxsLW9wYWNpdHk9XCIwXCJcclxuICAgICAgICAgICAgW2F0dHIuc3Ryb2tlLXdpZHRoXT1cIl9zdHJva2VXaWR0aFwiXHJcbiAgICAgICAgICAgIFthdHRyLmRdPVwicGF0aFN0cmluZ1wiXHJcbiAgICAgICAgICAgIFtuZ1N0eWxlXT1cInRyYWlsUGF0aFN0eWxlXCJcclxuICAgICAgICAgID48L3BhdGg+XHJcbiAgICAgICAgICA8cGF0aFxyXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgcCBvZiBwcm9ncmVzc0NpcmNsZVBhdGg7IHRyYWNrQnk6IHRyYWNrQnlGblwiXHJcbiAgICAgICAgICAgIGNsYXNzPVwidGRzLXByb2dyZXNzLWNpcmNsZS1wYXRoIHN0cm9rZS1jdXJyZW50IHRleHQtc3VjY2Vzcy00MDBcIlxyXG4gICAgICAgICAgICBmaWxsLW9wYWNpdHk9XCIwXCJcclxuICAgICAgICAgICAgW2F0dHIuZF09XCJwYXRoU3RyaW5nXCJcclxuICAgICAgICAgICAgW2F0dHIuc3Ryb2tlLWxpbmVjYXBdPVwic3Ryb2tlTGluZWNhcFwiXHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFthdHRyLnN0cm9rZS13aWR0aF09XCJwZXJjZW50ID8gX3N0cm9rZVdpZHRoIDogMFwiXHJcbiAgICAgICAgICAgIFtuZ1N0eWxlXT1cInAuc3Ryb2tlUGF0aFN0eWxlXCJcclxuICAgICAgICAgID57e3Auc3Ryb2tlfX08L3BhdGg+XHJcbiAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInByb2dyZXNzSW5mb1RlbXBsYXRlXCI+PC9uZy10ZW1wbGF0ZT5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICBgXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBURFNQcm9ncmVzc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25Jbml0LCBPbkRlc3Ryb3kge1xyXG5cclxuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VjY2Vzc1BlcmNlbnQ6IE51bWJlcklucHV0O1xyXG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9wZXJjZW50OiBOdW1iZXJJbnB1dDtcclxuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfcHRyb2tlV2lkdGg6IE51bWJlcklucHV0O1xyXG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9nYXBEZWdyZWU6IE51bWJlcklucHV0O1xyXG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdGVwczogTnVtYmVySW5wdXQ7XHJcblxyXG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSBzaG93SW5mbzogYm9vbGVhbiA9IHRydWU7XHJcbiAgQElucHV0KCkgd2lkdGggPSAxMzI7XHJcbiAgQElucHV0KCkgc3Ryb2tlQ29sb3I/OiBURFNQcm9ncmVzc1N0cm9rZUNvbG9yVHlwZSA9IHVuZGVmaW5lZDtcclxuICBASW5wdXQoKSBzaXplOiAnZGVmYXVsdCcgfCAnc21hbGwnID0gJ2RlZmF1bHQnO1xyXG4gIEBJbnB1dCgpIGZvcm1hdD86IFREU1Byb2dyZXNzRm9ybWF0dGVyO1xyXG4gIEBJbnB1dCgpIEBJbnB1dE51bWJlcigpIHN1Y2Nlc3NQZXJjZW50PzogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIEBJbnB1dE51bWJlcigpIHBlcmNlbnQ6IG51bWJlciA9IDA7XHJcbiAgQElucHV0KCkgQElucHV0TnVtYmVyKCkgc3Ryb2tlV2lkdGg/OiBudW1iZXIgPSB1bmRlZmluZWQ7XHJcbiAgQElucHV0KCkgQElucHV0TnVtYmVyKCkgZ2FwRGVncmVlPzogbnVtYmVyID0gdW5kZWZpbmVkO1xyXG4gIEBJbnB1dCgpIHN0YXR1cz86IFREU1Byb2dyZXNzU3RhdHVzVHlwZTtcclxuICBASW5wdXQoKSB0eXBlOiBURFNQcm9ncmVzc1R5cGVUeXBlID0gJ2xpbmUnO1xyXG4gIEBJbnB1dCgpIGdhcFBvc2l0aW9uOiBURFNQcm9ncmVzc0dhcFBvc2l0aW9uVHlwZSA9ICd0b3AnO1xyXG4gIEBJbnB1dCgpIHN0cm9rZUxpbmVjYXA6IFREU1Byb2dyZXNzU3Ryb2tlTGluZWNhcFR5cGUgPSAncm91bmQnO1xyXG5cclxuICBASW5wdXQoKSBASW5wdXROdW1iZXIoKSBzdGVwczogbnVtYmVyID0gMDtcclxuXHJcbiAgX3N0ZXBzOiBURFNQcm9ncmVzc1N0ZXBJdGVtW10gPSBbXTtcclxuXHJcbiAgLyoqIEdyYWRpZW50IHN0eWxlIHdoZW4gYHR5cGVgIGlzIGBsaW5lYC4gKi9cclxuICBsaW5lR3JhZGllbnQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xyXG5cclxuICAvKiogSWYgdXNlciB1c2VzIGdyYWRpZW50IGNvbG9yLiAqL1xyXG4gIGlzR3JhZGllbnQgPSBmYWxzZTtcclxuXHJcbiAgLyoqIElmIHRoZSBsaW5lYXIgcHJvZ3Jlc3MgaXMgYSBzdGVwIHByb2dyZXNzLiAqL1xyXG4gIGlzU3RlcHMgPSBmYWxzZTtcclxuXHJcbiAgLyoqXHJcbiAgICogRWFjaCBwcm9ncmVzcyB3aG9zZSBgdHlwZWAgaXMgY2lyY2xlIG9yIGRhc2hib2FyZCBzaG91bGQgaGF2ZSB1bmlxdWUgaWQgdG9cclxuICAgKiBkZWZpbmUgYDxsaW5lYXJHcmFkaWVudD5gLlxyXG4gICAqL1xyXG4gIGdyYWRpZW50SWQgPSBncmFkaWVudElkU2VlZCsrO1xyXG5cclxuICAvKiogUGF0aHMgdG8gcmVuZGVyZWQgaW4gdGhlIHRlbXBsYXRlLiAqL1xyXG4gIHByb2dyZXNzQ2lyY2xlUGF0aDogVERTUHJvZ3Jlc3NDaXJjbGVQYXRoW10gPSBbXTtcclxuICBjaXJjbGVHcmFkaWVudD86IEFycmF5PHsgb2Zmc2V0OiBzdHJpbmc7IGNvbG9yOiBzdHJpbmcgfT47XHJcbiAgdHJhaWxQYXRoU3R5bGU6IE5nU3R5bGVJbnRlcmZhY2UgfCBudWxsID0gbnVsbDtcclxuICBwYXRoU3RyaW5nPzogc3RyaW5nO1xyXG4gIGljb24hOiBzdHJpbmc7XHJcblxyXG4gIGRpcjogRGlyZWN0aW9uID0gJ2x0cic7XHJcblxyXG4gIHRyYWNrQnlGbiA9IChpbmRleDogbnVtYmVyKSA9PiBgJHtpbmRleH1gO1xyXG5cclxuICBnZXQgZm9ybWF0dGVyKCk6IFREU1Byb2dyZXNzRm9ybWF0dGVyIHtcclxuICAgIHJldHVybiB0aGlzLmZvcm1hdCB8fCBkZWZhdWx0Rm9ybWF0dGVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0IF9zdGF0dXMoKTogVERTUHJvZ3Jlc3NTdGF0dXNUeXBlIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXR1cyB8fCB0aGlzLmluZmVycmVkU3RhdHVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IF9zdHJva2VXaWR0aCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuc3Ryb2tlV2lkdGggfHwgKHRoaXMudHlwZSA9PT0gJ2xpbmUnICYmIHRoaXMuc2l6ZSAhPT0gJ3NtYWxsJyA/IDggOiA2KTtcclxuICB9XHJcblxyXG4gIGdldCBpc0NpcmNsZVN0eWxlKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2NpcmNsZScgfHwgdGhpcy50eXBlID09PSAnZGFzaGJvYXJkJztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2FjaGVkU3RhdHVzOiBURFNQcm9ncmVzc1N0YXR1c1R5cGUgPSAnbm9ybWFsJztcclxuICBwcml2YXRlIGluZmVycmVkU3RhdHVzOiBURFNQcm9ncmVzc1N0YXR1c1R5cGUgPSAnbm9ybWFsJztcclxuICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAvLyBwdWJsaWMgdGRzQ29uZmlnU2VydmljZTogVERTQ29uZmlnU2VydmljZSxcclxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZGlyZWN0aW9uYWxpdHk6IERpcmVjdGlvbmFsaXR5XHJcbiAgKSB7IH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBzdGVwcyxcclxuICAgICAgZ2FwUG9zaXRpb24sXHJcbiAgICAgIHN0cm9rZUxpbmVjYXAsXHJcbiAgICAgIHN0cm9rZUNvbG9yLFxyXG4gICAgICBnYXBEZWdyZWUsXHJcbiAgICAgIHR5cGUsXHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgcGVyY2VudCxcclxuICAgICAgc3VjY2Vzc1BlcmNlbnQsXHJcbiAgICAgIHN0cm9rZVdpZHRoXHJcbiAgICB9ID0gY2hhbmdlcztcclxuXHJcbiAgICBpZiAoc3RhdHVzKSB7XHJcbiAgICAgIHRoaXMuY2FjaGVkU3RhdHVzID0gdGhpcy5zdGF0dXMgfHwgdGhpcy5jYWNoZWRTdGF0dXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBlcmNlbnQgfHwgc3VjY2Vzc1BlcmNlbnQpIHtcclxuICAgICAgY29uc3QgZmlsbEFsbCA9IHBhcnNlSW50KHRoaXMucGVyY2VudC50b1N0cmluZygpLCAxMCkgPj0gMTAwO1xyXG4gICAgICBpZiAoZmlsbEFsbCkge1xyXG4gICAgICAgIGlmICgoVERTSGVscGVyT2JqZWN0Lmhhc1ZhbHVlKHRoaXMuc3VjY2Vzc1BlcmNlbnQpICYmIHRoaXMuc3VjY2Vzc1BlcmNlbnQhID49IDEwMCkgfHwgdGhpcy5zdWNjZXNzUGVyY2VudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLmluZmVycmVkU3RhdHVzID0gJ3N1Y2Nlc3MnO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmluZmVycmVkU3RhdHVzID0gdGhpcy5jYWNoZWRTdGF0dXM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdHVzIHx8IHBlcmNlbnQgfHwgc3VjY2Vzc1BlcmNlbnQgfHwgc3Ryb2tlQ29sb3IpIHtcclxuICAgICAgdGhpcy51cGRhdGVJY29uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0cm9rZUNvbG9yKSB7XHJcbiAgICAgIHRoaXMuc2V0U3Ryb2tlQ29sb3IoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ2FwUG9zaXRpb24gfHwgc3Ryb2tlTGluZWNhcCB8fCBnYXBEZWdyZWUgfHwgdHlwZSB8fCBwZXJjZW50IHx8IHN0cm9rZUNvbG9yIHx8IHN0cm9rZUNvbG9yKSB7XHJcbiAgICAgIHRoaXMuZ2V0Q2lyY2xlUGF0aHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGVyY2VudCB8fCBzdGVwcyB8fCBzdHJva2VXaWR0aCkge1xyXG4gICAgICB0aGlzLmlzU3RlcHMgPSB0aGlzLnN0ZXBzID4gMDtcclxuICAgICAgaWYgKHRoaXMuaXNTdGVwcykge1xyXG4gICAgICAgIHRoaXMuZ2V0U3RlcHMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkluaXQoKTogdm9pZCB7XHJcbiAgICAvLyB0aGlzLnRkc0NvbmZpZ1NlcnZpY2VcclxuICAgIC8vICAgLmdldENvbmZpZ0NoYW5nZUV2ZW50Rm9yQ29tcG9uZW50KFREU19DT05GSUdfTU9EVUxFX05BTUUpXHJcbiAgICAvLyAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcclxuICAgIC8vICAgLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICB0aGlzLnVwZGF0ZUljb24oKTtcclxuICAgIHRoaXMuc2V0U3Ryb2tlQ29sb3IoKTtcclxuICAgIHRoaXMuZ2V0Q2lyY2xlUGF0aHMoKTtcclxuICAgIC8vIH0pO1xyXG5cclxuICAgIHRoaXMuZGlyZWN0aW9uYWxpdHkuY2hhbmdlPy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKChkaXJlY3Rpb246IERpcmVjdGlvbikgPT4ge1xyXG4gICAgICB0aGlzLmRpciA9IGRpcmVjdGlvbjtcclxuICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kaXIgPSB0aGlzLmRpcmVjdGlvbmFsaXR5LnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcclxuICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlSWNvbigpOiB2b2lkIHtcclxuICAgIGNvbnN0IHJldCA9IHN0YXR1c0ljb25OYW1lTWFwLmdldCh0aGlzLl9zdGF0dXMpO1xyXG4gICAgdGhpcy5pY29uID0gXCJcIjtcclxuICAgIGlmIChURFNIZWxwZXJTdHJpbmcuaGFzVmFsdWVTdHJpbmcocmV0KSkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNDaXJjbGVTdHlsZSkge1xyXG4gICAgICAgIHRoaXMuaWNvbiA9IGB0ZHNpLSR7cmV0fS1maWxsIHRleHQtJHtyZXR9LTQwMGA7XHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIHN3aXRjaCAocmV0KSB7XHJcbiAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcclxuICAgICAgICAgICAgdGhpcy5pY29uID0gYHRkc2ktY2xvc2UtZmlsbCB0ZXh0LSR7cmV0fS00MDBgO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRoaXMuaWNvbiA9IGB0ZHNpLXRpY2stZmlsbCB0ZXh0LSR7cmV0fS00MDBgO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICBcclxuICAgIH1cclxuICAgXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgc3RlcCByZW5kZXIgY29uZmlncy5cclxuICAgKi9cclxuICBwcml2YXRlIGdldFN0ZXBzKCk6IHZvaWQge1xyXG4gICAgY29uc3QgY3VycmVudCA9IE1hdGguZmxvb3IodGhpcy5zdGVwcyAqICh0aGlzLnBlcmNlbnQgLyAxMDApKTtcclxuICAgIGNvbnN0IHN0ZXBXaWR0aCA9IHRoaXMuc2l6ZSA9PT0gJ3NtYWxsJyA/IDIgOiAxNDtcclxuXHJcbiAgICBjb25zdCBfc3RlcHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RlcHM7IGkrKykge1xyXG4gICAgICBsZXQgY29sb3I7XHJcbiAgICAgIGlmIChpIDw9IGN1cnJlbnQgLSAxKSB7XHJcbiAgICAgICAgY29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHN0ZXBTdHlsZSA9IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGAke2NvbG9yfWAsXHJcbiAgICAgICAgd2lkdGg6IGAke3N0ZXBXaWR0aH1weGAsXHJcbiAgICAgICAgaGVpZ2h0OiBgJHt0aGlzLl9zdHJva2VXaWR0aH1weGBcclxuICAgICAgfTtcclxuICAgICAgX3N0ZXBzLnB1c2goc3RlcFN0eWxlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zdGVwcyA9IF9zdGVwcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBwYXRocyB3aGVuIHRoZSB0eXBlIGlzIGNpcmNsZSBvciBkYXNoYm9hcmQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRDaXJjbGVQYXRocygpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5pc0NpcmNsZVN0eWxlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2YWx1ZXMgPSBURFNIZWxwZXJPYmplY3QuaGFzVmFsdWUodGhpcy5zdWNjZXNzUGVyY2VudCkgPyBbdGhpcy5zdWNjZXNzUGVyY2VudCEsIHRoaXMucGVyY2VudF0gOiBbdGhpcy5wZXJjZW50XTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgc2hhcmVkIHN0eWxlcy5cclxuICAgIGNvbnN0IHJhZGl1cyA9IDUwIC0gdGhpcy5fc3Ryb2tlV2lkdGggLyAyO1xyXG4gICAgY29uc3QgZ2FwUG9zaXRpb24gPSB0aGlzLmdhcFBvc2l0aW9uIHx8ICh0aGlzLnR5cGUgPT09ICdjaXJjbGUnID8gJ3RvcCcgOiAnYm90dG9tJyk7XHJcbiAgICBjb25zdCBsZW4gPSBNYXRoLlBJICogMiAqIHJhZGl1cztcclxuICAgIGNvbnN0IGdhcERlZ3JlZSA9IHRoaXMuZ2FwRGVncmVlIHx8ICh0aGlzLnR5cGUgPT09ICdjaXJjbGUnID8gMCA6IDc1KTtcclxuXHJcbiAgICBsZXQgYmVnaW5Qb3NpdGlvblggPSAwO1xyXG4gICAgbGV0IGJlZ2luUG9zaXRpb25ZID0gLXJhZGl1cztcclxuICAgIGxldCBlbmRQb3NpdGlvblggPSAwO1xyXG4gICAgbGV0IGVuZFBvc2l0aW9uWSA9IHJhZGl1cyAqIC0yO1xyXG5cclxuICAgIHN3aXRjaCAoZ2FwUG9zaXRpb24pIHtcclxuICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgYmVnaW5Qb3NpdGlvblggPSAtcmFkaXVzO1xyXG4gICAgICAgIGJlZ2luUG9zaXRpb25ZID0gMDtcclxuICAgICAgICBlbmRQb3NpdGlvblggPSByYWRpdXMgKiAyO1xyXG4gICAgICAgIGVuZFBvc2l0aW9uWSA9IDA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICBiZWdpblBvc2l0aW9uWCA9IHJhZGl1cztcclxuICAgICAgICBiZWdpblBvc2l0aW9uWSA9IDA7XHJcbiAgICAgICAgZW5kUG9zaXRpb25YID0gcmFkaXVzICogLTI7XHJcbiAgICAgICAgZW5kUG9zaXRpb25ZID0gMDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICBiZWdpblBvc2l0aW9uWSA9IHJhZGl1cztcclxuICAgICAgICBlbmRQb3NpdGlvblkgPSByYWRpdXMgKiAyO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGF0aFN0cmluZyA9IGBNIDUwLDUwIG0gJHtiZWdpblBvc2l0aW9uWH0sJHtiZWdpblBvc2l0aW9uWX1cclxuICAgICAgIGEgJHtyYWRpdXN9LCR7cmFkaXVzfSAwIDEgMSAke2VuZFBvc2l0aW9uWH0sJHstZW5kUG9zaXRpb25ZfVxyXG4gICAgICAgYSAke3JhZGl1c30sJHtyYWRpdXN9IDAgMSAxICR7LWVuZFBvc2l0aW9uWH0sJHtlbmRQb3NpdGlvbll9YDtcclxuXHJcbiAgICB0aGlzLnRyYWlsUGF0aFN0eWxlID0ge1xyXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IGAke2xlbiAtIGdhcERlZ3JlZX1weCAke2xlbn1weGAsXHJcbiAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IGAtJHtnYXBEZWdyZWUgLyAyfXB4YCxcclxuICAgICAgdHJhbnNpdGlvbjogJ3N0cm9rZS1kYXNob2Zmc2V0IC4zcyBlYXNlIDBzLCBzdHJva2UtZGFzaGFycmF5IC4zcyBlYXNlIDBzLCBzdHJva2UgLjNzJ1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgc3R5bGVzIGZvciBlYWNoIHBhdGguXHJcbiAgICB0aGlzLnByb2dyZXNzQ2lyY2xlUGF0aCA9IHZhbHVlc1xyXG4gICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBpc1N1Y2Nlc3NQZXJjZW50ID0gdmFsdWVzLmxlbmd0aCA9PT0gMiAmJiBpbmRleCA9PT0gMDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3Ryb2tlOiB0aGlzLmlzR3JhZGllbnQgJiYgIWlzU3VjY2Vzc1BlcmNlbnQgPyBgdXJsKCNncmFkaWVudC0ke3RoaXMuZ3JhZGllbnRJZH0pYCA6IG51bGwsXHJcbiAgICAgICAgICBzdHJva2VQYXRoU3R5bGU6IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiAhdGhpcy5pc0dyYWRpZW50ID8gKGlzU3VjY2Vzc1BlcmNlbnQgPyBzdGF0dXNDb2xvck1hcC5nZXQoJ3N1Y2Nlc3MnKSA6ICh0aGlzLnN0cm9rZUNvbG9yIGFzIHN0cmluZykpIDogbnVsbCxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3N0cm9rZS1kYXNob2Zmc2V0IC4zcyBlYXNlIDBzLCBzdHJva2UtZGFzaGFycmF5IC4zcyBlYXNlIDBzLCBzdHJva2UgLjNzLCBzdHJva2Utd2lkdGggLjA2cyBlYXNlIC4zcycsXHJcbiAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogYCR7KCh2YWx1ZSB8fCAwKSAvIDEwMCkgKiAobGVuIC0gZ2FwRGVncmVlKX1weCAke2xlbn1weGAsXHJcbiAgICAgICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IGAtJHtnYXBEZWdyZWUgLyAyfXB4YFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pXHJcbiAgICAgIC5yZXZlcnNlKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNldFN0cm9rZUNvbG9yKCk6IHZvaWQge1xyXG4gICAgY29uc3QgY29sb3IgPSB0aGlzLnN0cm9rZUNvbG9yO1xyXG4gICAgY29uc3QgaXNHcmFkaWVudCA9ICh0aGlzLmlzR3JhZGllbnQgPSAhIWNvbG9yICYmIHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycpO1xyXG4gICAgaWYgKGlzR3JhZGllbnQgJiYgIXRoaXMuaXNDaXJjbGVTdHlsZSkge1xyXG4gICAgICB0aGlzLmxpbmVHcmFkaWVudCA9IGhhbmRsZUxpbmVhckdyYWRpZW50KGNvbG9yIGFzIFREU1Byb2dyZXNzQ29sb3JHcmFkaWVudCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzR3JhZGllbnQgJiYgdGhpcy5pc0NpcmNsZVN0eWxlKSB7XHJcbiAgICAgIHRoaXMuY2lyY2xlR3JhZGllbnQgPSBoYW5kbGVDaXJjbGVHcmFkaWVudCh0aGlzLnN0cm9rZUNvbG9yIGFzIFREU1Byb2dyZXNzR3JhZGllbnRQcm9ncmVzcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxpbmVHcmFkaWVudCA9IG51bGw7XHJcbiAgICAgIHRoaXMuY2lyY2xlR3JhZGllbnQgPSBbXTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19