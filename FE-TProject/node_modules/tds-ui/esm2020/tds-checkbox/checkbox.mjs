import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Attribute, ChangeDetectionStrategy, Component, EventEmitter, forwardRef, Inject, Input, Optional, Output, ViewChild, ViewEncapsulation, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { mixinDisabled, mixinTabIndex } from 'tds-ui/shared/common';
import { TDS_CHECKBOX_DEFAULT_OPTIONS, TDS_CHECKBOX_DEFAULT_OPTIONS_FACTORY, } from './checkbox-config';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/a11y";
import * as i2 from "@angular/common";
const _c0 = ["input"];
const _c1 = function (a0) { return { "dark:text-d-neutral-3-50": a0 }; };
function TDSCheckbox__svg_svg_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "svg", 10);
    i0.ɵɵelement(1, "path", 11);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵattribute("width", ctx_r2.widthHieghtSvg)("height", ctx_r2.widthHieghtSvg);
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(i0.ɵɵpureFunction1(4, _c1, ctx_r2.disabled));
} }
function TDSCheckbox__svg_svg_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "svg", 12);
    i0.ɵɵelement(1, "path", 13);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵattribute("width", ctx_r3.widthHieghtSvg)("height", ctx_r3.widthHieghtSvg);
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(i0.ɵɵpureFunction1(4, _c1, ctx_r3.disabled));
} }
const _c2 = function (a0, a1, a2, a3, a4, a5) { return { "group-hover:border-primary-1  cursor-pointer": a0, "bg-primary-1 border-primary-1": a1, "bg-white dark:bg-d-neutral-3-50 ": a2, " bg-neutral-3-50 dark:bg-d-neutral-2-200": a3, " bg-neutral-2-200 dark:bg-d-neutral-1-200": a4, "cursor-not-allowed": a5 }; };
const _c3 = function (a0, a1, a2) { return { "h-3 w-3": a0, "h-2.5 w-2.5": a1, "h-3.5 w-3.5": a2 }; };
const _c4 = function (a0, a1, a2) { return { "text-neutral-1-900 dark:text-d-neutral-1-900": a0, "text-neutral-1-300 dark:text-d-neutral-1-300": a1, "ml-2": a2 }; };
const _c5 = function (a0, a1) { return { "cursor-pointer": a0, "opacity-65 cursor-not-allowed": a1 }; };
const _c6 = ["*"];
// Increasing integer for generating unique ids for checkbox components.
let nextUniqueId = 0;
// Default checkbox configuration.
const defaults = TDS_CHECKBOX_DEFAULT_OPTIONS_FACTORY();
/**
 * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.
 * This allows it to support [(ngModel)].
 * @docs-private
 */
export const TDS_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TDSCheckbox),
    multi: true
};
/** Change event object emitted by MatCheckbox. */
export class TDSCheckboxChange {
}
// Boilerplate for applying mixins to MatCheckbox.
/** @docs-private */
class TDSCheckboxBase {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}
const _TACheckboxMixinBase = mixinTabIndex(mixinDisabled(TDSCheckboxBase));
/**
 * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,
 * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or
 * disabled. Note that all additional accessibility attributes are taken care of by the component,
 * so there is no need to provide them yourself. However, if you want to omit a label and still
 * have the checkbox be accessible, you may supply an [aria-label] input.
 * See: https://material.io/design/components/selection-controls.html
 */
export class TDSCheckbox extends _TACheckboxMixinBase {
    constructor(elementRef, _changeDetectorRef, _focusMonitor, tabIndex, _options) {
        super(elementRef);
        this._changeDetectorRef = _changeDetectorRef;
        this._focusMonitor = _focusMonitor;
        this._options = _options;
        this._size = 'md';
        this.widthHieghtSvg = 12;
        /**
         * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will
         * take precedence so this may be omitted.
         */
        this.ariaLabel = '';
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        this._uniqueId = `tds-checkbox-${++nextUniqueId}`;
        /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */
        this.id = this._uniqueId;
        /** Name value will be applied to the input element if present */
        this.name = null;
        /** Event emitted when the checkbox's `checked` value changes. */
        this.tdsChange = new EventEmitter();
        /**
         * @deprecated sẽ không hỗ trợ từ bản 2.1.0, dùng tdsChange để thay thế
         */
        this.change = new EventEmitter();
        /** Event emitted when the checkbox's `indeterminate` value changes. */
        this.indeterminateChange = new EventEmitter();
        /**
         * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.
         * @docs-private
         */
        this._onTouched = () => { };
        this._controlValueAccessorChangeFn = () => { };
        this._checked = false;
        this._disabled = false;
        this._indeterminate = false;
        this._options = this._options || defaults;
        this.tabIndex = parseInt(tabIndex) || 0;
    }
    get size() { return this._size; }
    set size(value) {
        if (value !== this._size) {
            this._size = value;
            this.widthHieghtSvg = this._size == "sm" ? 10 : this._size == "lg" ? 14 : 12;
            this._changeDetectorRef.markForCheck();
        }
    }
    /** Returns the unique id for the visual hidden input. */
    get inputId() { return `${this.id || this._uniqueId}-input`; }
    /** Whether the checkbox is required. */
    get required() { return this._required; }
    set required(value) { this._required = coerceBooleanProperty(value); }
    ngAfterViewInit() {
        this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {
            if (!focusOrigin) {
                // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                // Angular does not expect events to be raised during change detection, so any state change
                // (such as a form control's 'ng-touched') will cause a changed-after-checked error.
                // See https://github.com/angular/angular/issues/17793. To work around this, we defer
                // telling the form control it has been touched until the next tick.
                Promise.resolve().then(() => {
                    this._onTouched();
                    this._changeDetectorRef.markForCheck();
                });
            }
        });
        this._syncIndeterminate(this._indeterminate);
    }
    // TODO: Delete next major revision.
    ngAfterViewChecked() { }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    /**
     * Whether the checkbox is checked.
     */
    get checked() { return this._checked; }
    set checked(value) {
        if (value != this.checked) {
            this._checked = value;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * Whether the checkbox is disabled. This fully overrides the implementation provided by
     * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.
     */
    get disabled() { return this._disabled; }
    set disabled(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.disabled) {
            this._disabled = newValue;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
     * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
     * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately
     * set to false.
     */
    get indeterminate() { return this._indeterminate; }
    set indeterminate(value) {
        const changed = value != this._indeterminate;
        this._indeterminate = coerceBooleanProperty(value);
        if (changed) {
            this.indeterminateChange.emit(this._indeterminate);
        }
        this._syncIndeterminate(this._indeterminate);
    }
    /** Method being called whenever the label text changes. */
    _onLabelTextChange() {
        // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox
        // component will be only marked for check, but no actual change detection runs automatically.
        // Instead of going back into the zone in order to trigger a change detection which causes
        // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger
        // an explicit change detection for the checkbox view and its children.
        this._changeDetectorRef.detectChanges();
    }
    // Implemented as part of ControlValueAccessor.
    writeValue(value) {
        this.checked = !!value;
    }
    // Implemented as part of ControlValueAccessor.
    registerOnChange(fn) {
        this._controlValueAccessorChangeFn = fn;
    }
    // Implemented as part of ControlValueAccessor.
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    // Implemented as part of ControlValueAccessor.
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    _getAriaChecked() {
        if (this.checked) {
            return 'true';
        }
        return this.indeterminate ? 'mixed' : 'false';
    }
    _emitChangeEvent() {
        const event = new TDSCheckboxChange();
        event.source = this;
        event.checked = this.checked;
        this._controlValueAccessorChangeFn(this.checked);
        this.change.emit(event);
        this.tdsChange.emit(event);
        // Assigning the value again here is redundant, but we have to do it in case it was
        // changed inside the `change` listener which will cause the input to be out of sync.
        if (this._inputElement) {
            this._inputElement.nativeElement.checked = this.checked;
        }
    }
    /** Toggles the `checked` state of the checkbox. */
    toggle() {
        this.checked = !this.checked;
    }
    /**
     * Event handler for checkbox input element.
     * Toggles checked state if element is not disabled.
     * Do not toggle on (change) event since IE doesn't fire change event when
     *   indeterminate checkbox is clicked.
     * @param event
     */
    _onInputClick(event) {
        const clickAction = this._options?.clickAction;
        // We have to stop propagation for click events on the visual hidden input element.
        // By default, when a user clicks on a label element, a generated click event will be
        // dispatched on the associated input element. Since we are using a label element as our
        // root container, the click event on the `checkbox` will be executed twice.
        // The real click event will bubble up, and the generated click event also tries to bubble up.
        // This will lead to multiple click events.
        // Preventing bubbling for the second event will solve that issue.
        event.stopPropagation();
        // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click
        if (!this.disabled && clickAction !== 'noop') {
            // When user manually click on the checkbox, `indeterminate` is set to false.
            if (this.indeterminate && clickAction !== 'check') {
                Promise.resolve().then(() => {
                    this._indeterminate = false;
                    this.indeterminateChange.emit(this._indeterminate);
                });
            }
            this.toggle();
            //  this._transitionCheckState(
            //      this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
            // Emit our custom change event if the native input emitted one.
            // It is important to only emit it, if the native input triggered one, because
            // we don't want to trigger a change event, when the `checked` variable changes for example.
            this._emitChangeEvent();
        }
        else if (!this.disabled && clickAction === 'noop') {
            // Reset native input when clicked with noop. The native checkbox becomes checked after
            // click, reset it to be align with `checked` value of `mat-checkbox`.
            this._inputElement.nativeElement.checked = this.checked;
            this._inputElement.nativeElement.indeterminate = this.indeterminate;
        }
    }
    /** Focuses the checkbox. */
    focus(origin, options) {
        if (origin) {
            this._focusMonitor.focusVia(this._inputElement, origin, options);
        }
        else {
            this._inputElement.nativeElement.focus(options);
        }
    }
    _onInteractionEvent(event) {
        // We always have to stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        // emit its event object to the `change` output.
        event.stopPropagation();
    }
    /**
     * Syncs the indeterminate value with the checkbox DOM node.
     *
     * We sync `indeterminate` directly on the DOM node, because in Ivy the check for whether a
     * property is supported on an element boils down to `if (propName in element)`. Domino's
     * HTMLInputElement doesn't have an `indeterminate` property so Ivy will warn during
     * server-side rendering.
     */
    _syncIndeterminate(value) {
        const nativeCheckbox = this._inputElement;
        if (nativeCheckbox) {
            nativeCheckbox.nativeElement.indeterminate = value;
        }
    }
}
TDSCheckbox.ɵfac = function TDSCheckbox_Factory(t) { return new (t || TDSCheckbox)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.FocusMonitor), i0.ɵɵinjectAttribute('tabindex'), i0.ɵɵdirectiveInject(TDS_CHECKBOX_DEFAULT_OPTIONS, 8)); };
TDSCheckbox.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSCheckbox, selectors: [["tds-checkbox"]], viewQuery: function TDSCheckbox_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._inputElement = _t.first);
    } }, hostAttrs: [1, "tds-checkbox"], hostVars: 8, hostBindings: function TDSCheckbox_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵhostProperty("id", ctx.id);
        i0.ɵɵattribute("tabindex", null);
        i0.ɵɵclassProp("tds-checkbox-indeterminate", ctx.indeterminate)("opacity-65", ctx.disabled)("inline-block", true);
    } }, inputs: { color: "color", tabIndex: "tabIndex", size: "size", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"], id: "id", required: "required", name: "name", value: "value", checked: "checked", disabled: "disabled", indeterminate: "indeterminate" }, outputs: { tdsChange: "tdsChange", change: "change", indeterminateChange: "indeterminateChange" }, exportAs: ["taCheckbox"], features: [i0.ɵɵProvidersFeature([TDS_CHECKBOX_CONTROL_VALUE_ACCESSOR]), i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c6, decls: 11, vars: 36, consts: [[1, "flex", "items-center", "group"], ["label", ""], [1, "p-0.5", "border", "rounded", "relative", "flex", "items-center", "justify-center", "box-content", "border-neutral-2-200", "dark:border-d-neutral-2-200", 3, "ngClass"], ["type", "checkbox", 1, "border-0", "overflow-hidden", "padding-0", "absolute", "whitespace-nowrap", "outline", "outline-none", 2, "height", "1px", "margin", "-1px", "clip", "rect(0 0 0 0)", "width", "1px", 3, "id", "required", "checked", "disabled", "tabIndex", "change", "click"], ["input", ""], [3, "ngClass"], ["viewBox", "0 0 12 8", "fill", "none", "xmlns", "http://www.w3.org/2000/svg", 4, "ngIf"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 12 4", "fill", "none", 4, "ngIf"], [1, "ml-2", "text-body-2", "font-regular", "select-none", "empty:hidden", 3, "ngClass", "cdkObserveContent"], ["checkboxLabel", ""], ["viewBox", "0 0 12 8", "fill", "none", "xmlns", "http://www.w3.org/2000/svg"], ["d", "M10.7307 0.90316C10.5348 0.707751 10.2694 0.598045 9.99275 0.598045C9.71605 0.598045 9.45061 0.707751 9.25471 0.90316L4.75471 5.40316L2.78572 3.4352C2.68953 3.33465 2.57426 3.25427 2.44661 3.19888C2.31895 3.14348 2.18152 3.11414 2.04237 3.11257C1.90323 3.111 1.76517 3.13728 1.6363 3.18978C1.50744 3.24229 1.39031 3.31999 1.29188 3.41836C1.19345 3.51672 1.11565 3.63376 1.06306 3.7626C1.01047 3.89143 0.984135 4.02946 0.985609 4.1686C0.987082 4.30775 1.01636 4.44521 1.07167 4.5729C1.12698 4.70059 1.20726 4.81594 1.30775 4.91219L4.01674 7.6202C4.21298 7.81573 4.47872 7.9255 4.75575 7.9255C5.03278 7.9255 5.29846 7.81573 5.4947 7.6202L10.7367 2.38021C10.8346 2.28323 10.9123 2.1678 10.9653 2.04061C11.0184 1.91343 11.0457 1.77698 11.0457 1.63918C11.0457 1.50138 11.0184 1.36494 10.9653 1.23775C10.9123 1.11057 10.8346 0.995193 10.7367 0.898216L10.7307 0.90316Z", 1, "fill-current", "text-white"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 12 4", "fill", "none"], ["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M0.600006 2C0.600006 1.33726 1.13726 0.800003 1.80001 0.800003L10.2 0.800003C10.8627 0.800003 11.4 1.33726 11.4 2C11.4 2.66274 10.8627 3.2 10.2 3.2L1.80001 3.2C1.13726 3.2 0.600006 2.66274 0.600006 2Z", 1, "fill-current", "text-white"]], template: function TDSCheckbox_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵelementStart(0, "label", 0, 1)(2, "span", 2)(3, "input", 3, 4);
        i0.ɵɵlistener("change", function TDSCheckbox_Template_input_change_3_listener($event) { return ctx._onInteractionEvent($event); })("click", function TDSCheckbox_Template_input_click_3_listener($event) { return ctx._onInputClick($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵelementStart(5, "span", 5);
        i0.ɵɵtemplate(6, TDSCheckbox__svg_svg_6_Template, 2, 6, "svg", 6);
        i0.ɵɵtemplate(7, TDSCheckbox__svg_svg_7_Template, 2, 6, "svg", 7);
        i0.ɵɵelementEnd()();
        i0.ɵɵelementStart(8, "span", 8, 9);
        i0.ɵɵlistener("cdkObserveContent", function TDSCheckbox_Template_span_cdkObserveContent_8_listener() { return ctx._onLabelTextChange(); });
        i0.ɵɵprojection(10);
        i0.ɵɵelementEnd()();
    } if (rf & 2) {
        const _r4 = i0.ɵɵreference(9);
        i0.ɵɵattribute("for", ctx.inputId);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction6(18, _c2, !ctx.disabled, !ctx.disabled && (ctx.checked || ctx.indeterminate), !ctx.checked && !ctx.indeterminate, ctx.disabled && !ctx.checked && !ctx.indeterminate, ctx.disabled && (ctx.checked || ctx.indeterminate), ctx.disabled));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("id", ctx.inputId)("required", ctx.required)("checked", ctx.checked)("disabled", ctx.disabled)("tabIndex", ctx.tabIndex);
        i0.ɵɵattribute("value", ctx.value)("name", ctx.name)("aria-label", ctx.ariaLabel || null)("aria-labelledby", ctx.ariaLabelledby)("aria-checked", ctx._getAriaChecked())("aria-describedby", ctx.ariaDescribedby);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(25, _c3, ctx.size == "md", ctx.size == "sm", ctx.size == "lg"));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.checked && !ctx.indeterminate);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.indeterminate);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(29, _c4, !ctx.disabled, ctx.disabled, _r4.children.length))("ngClass", i0.ɵɵpureFunction2(33, _c5, !ctx.disabled, ctx.disabled));
    } }, directives: [i2.NgClass, i2.NgIf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSCheckbox, [{
        type: Component,
        args: [{ selector: 'tds-checkbox', exportAs: 'taCheckbox', host: {
                    'class': 'tds-checkbox',
                    '[id]': 'id',
                    '[attr.tabindex]': 'null',
                    '[class.tds-checkbox-indeterminate]': 'indeterminate',
                    '[class.opacity-65]': 'disabled',
                    '[class.inline-block]': 'true',
                }, providers: [TDS_CHECKBOX_CONTROL_VALUE_ACCESSOR], inputs: ['color', 'tabIndex'], encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: "<label class=\"flex items-center group\" [attr.for]=\"inputId\" #label>\r\n    <span\r\n        class=\"p-0.5 border rounded   relative flex items-center justify-center box-content border-neutral-2-200 dark:border-d-neutral-2-200\"\r\n        [ngClass]=\"{'group-hover:border-primary-1  cursor-pointer':!disabled,\r\n        'bg-primary-1 border-primary-1':!disabled  && (checked || indeterminate),\r\n        'bg-white dark:bg-d-neutral-3-50 ':!checked && !indeterminate,\r\n        ' bg-neutral-3-50 dark:bg-d-neutral-2-200':disabled && !checked && !indeterminate,\r\n        ' bg-neutral-2-200 dark:bg-d-neutral-1-200':disabled && (checked || indeterminate),\r\n        'cursor-not-allowed':disabled\r\n    }\">\r\n        <input #input type=\"checkbox\"\r\n            class=\"border-0 overflow-hidden padding-0 absolute whitespace-nowrap outline outline-none\"\r\n            style=\"height: 1px; margin: -1px;clip: rect(0 0 0 0); width:1px\" [id]=\"inputId\" [required]=\"required\"\r\n            [checked]=\"checked\" [attr.value]=\"value\" [disabled]=\"disabled\" [attr.name]=\"name\" [tabIndex]=\"tabIndex\"\r\n            [attr.aria-label]=\"ariaLabel || null\" [attr.aria-labelledby]=\"ariaLabelledby\"\r\n            [attr.aria-checked]=\"_getAriaChecked()\" [attr.aria-describedby]=\"ariaDescribedby\"\r\n            (change)=\"_onInteractionEvent($event)\" (click)=\"_onInputClick($event)\" />\r\n\r\n        <span [ngClass]=\"{\r\n            'h-3 w-3':size == 'md',\r\n            'h-2.5 w-2.5':size == 'sm',\r\n            'h-3.5 w-3.5':size == 'lg'\r\n        }\">\r\n            <svg *ngIf=\"checked && !indeterminate \" [attr.width]=\"widthHieghtSvg\" [attr.height]=\"widthHieghtSvg\"\r\n                viewBox=\"0 0 12 8\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\r\n                <path class=\"fill-current text-white \" [class]=\"{'dark:text-d-neutral-3-50': disabled}\"\r\n                    d=\"M10.7307 0.90316C10.5348 0.707751 10.2694 0.598045 9.99275 0.598045C9.71605 0.598045 9.45061 0.707751 9.25471 0.90316L4.75471 5.40316L2.78572 3.4352C2.68953 3.33465 2.57426 3.25427 2.44661 3.19888C2.31895 3.14348 2.18152 3.11414 2.04237 3.11257C1.90323 3.111 1.76517 3.13728 1.6363 3.18978C1.50744 3.24229 1.39031 3.31999 1.29188 3.41836C1.19345 3.51672 1.11565 3.63376 1.06306 3.7626C1.01047 3.89143 0.984135 4.02946 0.985609 4.1686C0.987082 4.30775 1.01636 4.44521 1.07167 4.5729C1.12698 4.70059 1.20726 4.81594 1.30775 4.91219L4.01674 7.6202C4.21298 7.81573 4.47872 7.9255 4.75575 7.9255C5.03278 7.9255 5.29846 7.81573 5.4947 7.6202L10.7367 2.38021C10.8346 2.28323 10.9123 2.1678 10.9653 2.04061C11.0184 1.91343 11.0457 1.77698 11.0457 1.63918C11.0457 1.50138 11.0184 1.36494 10.9653 1.23775C10.9123 1.11057 10.8346 0.995193 10.7367 0.898216L10.7307 0.90316Z\" />\r\n            </svg>\r\n            <svg *ngIf=\"indeterminate\" xmlns=\"http://www.w3.org/2000/svg\" [attr.width]=\"widthHieghtSvg\"\r\n                [attr.height]=\"widthHieghtSvg\" viewBox=\"0 0 12 4\" fill=\"none\">\r\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\"\r\n                    d=\"M0.600006 2C0.600006 1.33726 1.13726 0.800003 1.80001 0.800003L10.2 0.800003C10.8627 0.800003 11.4 1.33726 11.4 2C11.4 2.66274 10.8627 3.2 10.2 3.2L1.80001 3.2C1.13726 3.2 0.600006 2.66274 0.600006 2Z\"\r\n                    class=\"fill-current text-white\" [class]=\"{'dark:text-d-neutral-3-50': disabled}\" />\r\n            </svg>\r\n        </span>\r\n    </span>\r\n    <span class=\"ml-2 text-body-2 font-regular  select-none empty:hidden\"\r\n        [ngClass]=\"{'text-neutral-1-900 dark:text-d-neutral-1-900':!disabled,'text-neutral-1-300 dark:text-d-neutral-1-300':disabled,'ml-2':checkboxLabel.children.length}\"\r\n        #checkboxLabel (cdkObserveContent)=\"_onLabelTextChange()\"\r\n        [ngClass]=\"{'cursor-pointer':!disabled,'opacity-65 cursor-not-allowed':disabled}\">        \r\n        <ng-content></ng-content>\r\n    </span>\r\n</label>" }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.FocusMonitor }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['tabindex']
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TDS_CHECKBOX_DEFAULT_OPTIONS]
            }] }]; }, { size: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedby: [{
            type: Input,
            args: ['aria-describedby']
        }], id: [{
            type: Input
        }], required: [{
            type: Input
        }], name: [{
            type: Input
        }], tdsChange: [{
            type: Output
        }], change: [{
            type: Output
        }], indeterminateChange: [{
            type: Output
        }], value: [{
            type: Input
        }], _inputElement: [{
            type: ViewChild,
            args: ['input']
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], indeterminate: [{
            type: Input
        }] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy90ZHMtdWkvdGRzLWNoZWNrYm94L2NoZWNrYm94LnRzIiwiLi4vLi4vLi4vLi4vcHJvamVjdHMvdGRzLXVpL3Rkcy1jaGVja2JveC9jaGVja2JveC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVNBLE9BQU8sRUFBZ0IscUJBQXFCLEVBQWUsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RixPQUFPLEVBRUwsU0FBUyxFQUNULHVCQUF1QixFQUV2QixTQUFTLEVBRVQsWUFBWSxFQUNaLFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUdMLFFBQVEsRUFDUixNQUFNLEVBQ04sU0FBUyxFQUNULGlCQUFpQixHQUVsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFekUsT0FBTyxFQUE0RCxhQUFhLEVBQUUsYUFBYSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDOUgsT0FBTyxFQUNMLDRCQUE0QixFQUU1QixvQ0FBb0MsR0FDckMsTUFBTSxtQkFBbUIsQ0FBQzs7Ozs7OztJQ2JmLG1CQUNzRTtJQUR0RSwrQkFDc0U7SUFDbEUsMkJBQ3cyQjtJQUM1MkIsaUJBQU07OztJQUprQyw4Q0FBNkIsaUNBQUE7SUFFMUIsZUFBZ0Q7SUFBaEQsMERBQWdEOzs7SUFHM0YsbUJBQ2tFO0lBRGxFLCtCQUNrRTtJQUM5RCwyQkFFdUY7SUFDM0YsaUJBQU07OztJQUx3RCw4Q0FBNkIsaUNBQUE7SUFJbkQsZUFBZ0Q7SUFBaEQsMERBQWdEOzs7Ozs7O0FET3BHLHdFQUF3RTtBQUN4RSxJQUFJLFlBQVksR0FBRyxDQUFDLENBQUM7QUFFckIsa0NBQWtDO0FBQ2xDLE1BQU0sUUFBUSxHQUFHLG9DQUFvQyxFQUFFLENBQUM7QUFFeEQ7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLG1DQUFtQyxHQUFRO0lB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L0IsZUFBbUI7UUFBbkIsd0NBQW1CO1FBUzdCLGVBQW1LO1FBQW5LLHVHQUFtSyxxRUFBQTs7dUZEK0U5SixXQUFXO2NBakJ2QixTQUFTOzJCQUNFLGNBQWMsWUFFZCxZQUFZLFFBQ2hCO29CQUNKLE9BQU8sRUFBRSxjQUFjO29CQUN2QixNQUFNLEVBQUUsSUFBSTtvQkFDWixpQkFBaUIsRUFBRSxNQUFNO29CQUN6QixvQ0FBb0MsRUFBRSxlQUFlO29CQUNyRCxvQkFBb0IsRUFBRSxVQUFVO29CQUNoQyxzQkFBc0IsRUFBRSxNQUFNO2lCQUMvQixhQUNVLENBQUMsbUNBQW1DLENBQUMsVUFDeEMsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLGlCQUNkLGlCQUFpQixDQUFDLElBQUksbUJBQ3BCLHVCQUF1QixDQUFDLE1BQU07O3NCQThFNUMsU0FBUzt1QkFBQyxVQUFVOztzQkFFcEIsUUFBUTs7c0JBQUksTUFBTTt1QkFBQyw0QkFBNEI7d0JBdkU5QyxJQUFJO2tCQUZQLEtBQUs7WUFjZSxTQUFTO2tCQUE3QixLQUFLO21CQUFDLFlBQVk7WUFLTyxjQUFjO2tCQUF2QyxLQUFLO21CQUFDLGlCQUFpQjtZQUdHLGVBQWU7a0JBQXpDLEtBQUs7bUJBQUMsa0JBQWtCO1lBS2hCLEVBQUU7a0JBQVYsS0FBSztZQU9GLFFBQVE7a0JBRFgsS0FBSztZQU1HLElBQUk7a0JBQVosS0FBSztZQUdhLFNBQVM7a0JBQTNCLE1BQU07WUFLYyxNQUFNO2tCQUF4QixNQUFNO1lBR1UsbUJBQW1CO2tCQUFyQyxNQUFNO1lBR0UsS0FBSztrQkFBYixLQUFLO1lBR2MsYUFBYTtrQkFBaEMsU0FBUzttQkFBQyxPQUFPO1lBcURkLE9BQU87a0JBRFYsS0FBSztZQWVGLFFBQVE7a0JBRFgsS0FBSztZQW1CRixhQUFhO2tCQURoQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICovXHJcblxyXG5pbXBvcnQgeyBGb2N1c2FibGVPcHRpb24sIEZvY3VzTW9uaXRvciwgRm9jdXNPcmlnaW4gfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XHJcbmltcG9ydCB7IEJvb2xlYW5JbnB1dCwgY29lcmNlQm9vbGVhblByb3BlcnR5LCBOdW1iZXJJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7XHJcbiAgQWZ0ZXJWaWV3Q2hlY2tlZCxcclxuICBBdHRyaWJ1dGUsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgQ29tcG9uZW50LFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIGZvcndhcmRSZWYsXHJcbiAgSW5qZWN0LFxyXG4gIElucHV0LFxyXG4gIE5nWm9uZSxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3B0aW9uYWwsXHJcbiAgT3V0cHV0LFxyXG4gIFZpZXdDaGlsZCxcclxuICBWaWV3RW5jYXBzdWxhdGlvbixcclxuICBBZnRlclZpZXdJbml0LFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IEJ1dHRvblNpemUgfSBmcm9tIFwidGRzLXVpL2NvcmUvY29uZmlnXCI7XHJcbmltcG9ydCB7IENhbkRpc2FibGUsIENhbkRpc2FibGVDdG9yLCBIYXNUYWJJbmRleCwgSGFzVGFiSW5kZXhDdG9yLCBtaXhpbkRpc2FibGVkLCBtaXhpblRhYkluZGV4IH0gZnJvbSAndGRzLXVpL3NoYXJlZC9jb21tb24nO1xyXG5pbXBvcnQge1xyXG4gIFREU19DSEVDS0JPWF9ERUZBVUxUX09QVElPTlMsXHJcbiAgVERTQ2hlY2tib3hEZWZhdWx0T3B0aW9ucyxcclxuICBURFNfQ0hFQ0tCT1hfREVGQVVMVF9PUFRJT05TX0ZBQ1RPUlksXHJcbn0gZnJvbSAnLi9jaGVja2JveC1jb25maWcnO1xyXG5cclxuXHJcbi8vIEluY3JlYXNpbmcgaW50ZWdlciBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgaWRzIGZvciBjaGVja2JveCBjb21wb25lbnRzLlxyXG5sZXQgbmV4dFVuaXF1ZUlkID0gMDtcclxuXHJcbi8vIERlZmF1bHQgY2hlY2tib3ggY29uZmlndXJhdGlvbi5cclxuY29uc3QgZGVmYXVsdHMgPSBURFNfQ0hFQ0tCT1hfREVGQVVMVF9PUFRJT05TX0ZBQ1RPUlkoKTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlciBFeHByZXNzaW9uIHRoYXQgYWxsb3dzIG1hdC1jaGVja2JveCB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxyXG4gKiBUaGlzIGFsbG93cyBpdCB0byBzdXBwb3J0IFsobmdNb2RlbCldLlxyXG4gKiBAZG9jcy1wcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVERTX0NIRUNLQk9YX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcclxuICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcclxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBURFNDaGVja2JveCksXHJcbiAgbXVsdGk6IHRydWVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBkaWZmZXJlbnQgc3RhdGVzIHRoYXQgcmVxdWlyZSBjdXN0b20gdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVtLlxyXG4gKiBAZG9jcy1wcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZW51bSBUcmFuc2l0aW9uQ2hlY2tTdGF0ZSB7XHJcbiAgLyoqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgYmVmb3JlIGFueSB1c2VyIGludGVyYWN0aW9uLiAqL1xyXG4gIEluaXQsXHJcbiAgLyoqIFRoZSBzdGF0ZSByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudCB3aGVuIGl0J3MgYmVjb21pbmcgY2hlY2tlZC4gKi9cclxuICBDaGVja2VkLFxyXG4gIC8qKiBUaGUgc3RhdGUgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQgd2hlbiBpdCdzIGJlY29taW5nIHVuY2hlY2tlZC4gKi9cclxuICBVbmNoZWNrZWQsXHJcbiAgLyoqIFRoZSBzdGF0ZSByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudCB3aGVuIGl0J3MgYmVjb21pbmcgaW5kZXRlcm1pbmF0ZS4gKi9cclxuICBJbmRldGVybWluYXRlXHJcbn1cclxuXHJcbi8qKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWF0Q2hlY2tib3guICovXHJcbmV4cG9ydCBjbGFzcyBURFNDaGVja2JveENoYW5nZSB7XHJcbiAgLyoqIFRoZSBzb3VyY2UgTWF0Q2hlY2tib3ggb2YgdGhlIGV2ZW50LiAqL1xyXG4gIHNvdXJjZSE6IFREU0NoZWNrYm94O1xyXG4gIC8qKiBUaGUgbmV3IGBjaGVja2VkYCB2YWx1ZSBvZiB0aGUgY2hlY2tib3guICovXHJcbiAgY2hlY2tlZCE6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vIEJvaWxlcnBsYXRlIGZvciBhcHBseWluZyBtaXhpbnMgdG8gTWF0Q2hlY2tib3guXHJcbi8qKiBAZG9jcy1wcml2YXRlICovXHJcbmNsYXNzIFREU0NoZWNrYm94QmFzZSB7XHJcbiAgY29uc3RydWN0b3IocHVibGljIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cclxufVxyXG5jb25zdCBfVEFDaGVja2JveE1peGluQmFzZTpcclxuICBIYXNUYWJJbmRleEN0b3IgJlxyXG4gIENhbkRpc2FibGVDdG9yICZcclxuICB0eXBlb2YgVERTQ2hlY2tib3hCYXNlID1cclxuICBtaXhpblRhYkluZGV4KG1peGluRGlzYWJsZWQoVERTQ2hlY2tib3hCYXNlKSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgbWF0ZXJpYWwgZGVzaWduIGNoZWNrYm94IGNvbXBvbmVudC4gU3VwcG9ydHMgYWxsIG9mIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIEhUTUw1IGNoZWNrYm94LFxyXG4gKiBhbmQgZXhwb3NlcyBhIHNpbWlsYXIgQVBJLiBBIE1hdENoZWNrYm94IGNhbiBiZSBlaXRoZXIgY2hlY2tlZCwgdW5jaGVja2VkLCBpbmRldGVybWluYXRlLCBvclxyXG4gKiBkaXNhYmxlZC4gTm90ZSB0aGF0IGFsbCBhZGRpdGlvbmFsIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlcyBhcmUgdGFrZW4gY2FyZSBvZiBieSB0aGUgY29tcG9uZW50LFxyXG4gKiBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIHByb3ZpZGUgdGhlbSB5b3Vyc2VsZi4gSG93ZXZlciwgaWYgeW91IHdhbnQgdG8gb21pdCBhIGxhYmVsIGFuZCBzdGlsbFxyXG4gKiBoYXZlIHRoZSBjaGVja2JveCBiZSBhY2Nlc3NpYmxlLCB5b3UgbWF5IHN1cHBseSBhbiBbYXJpYS1sYWJlbF0gaW5wdXQuXHJcbiAqIFNlZTogaHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vY29tcG9uZW50cy9zZWxlY3Rpb24tY29udHJvbHMuaHRtbFxyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICd0ZHMtY2hlY2tib3gnLFxyXG4gIHRlbXBsYXRlVXJsOiAnY2hlY2tib3guaHRtbCcsXHJcbiAgZXhwb3J0QXM6ICd0YUNoZWNrYm94JyxcclxuICBob3N0OiB7XHJcbiAgICAnY2xhc3MnOiAndGRzLWNoZWNrYm94JyxcclxuICAgICdbaWRdJzogJ2lkJyxcclxuICAgICdbYXR0ci50YWJpbmRleF0nOiAnbnVsbCcsXHJcbiAgICAnW2NsYXNzLnRkcy1jaGVja2JveC1pbmRldGVybWluYXRlXSc6ICdpbmRldGVybWluYXRlJyxcclxuICAgICdbY2xhc3Mub3BhY2l0eS02NV0nOiAnZGlzYWJsZWQnLFxyXG4gICAgJ1tjbGFzcy5pbmxpbmUtYmxvY2tdJzogJ3RydWUnLFxyXG4gIH0sXHJcbiAgcHJvdmlkZXJzOiBbVERTX0NIRUNLQk9YX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdLFxyXG4gIGlucHV0czogWydjb2xvcicsICd0YWJJbmRleCddLFxyXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxufSlcclxuZXhwb3J0IGNsYXNzIFREU0NoZWNrYm94IGV4dGVuZHMgX1RBQ2hlY2tib3hNaXhpbkJhc2UgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvcixcclxuICBBZnRlclZpZXdJbml0LCBBZnRlclZpZXdDaGVja2VkLCBPbkRlc3Ryb3ksIENhbkRpc2FibGUsIEhhc1RhYkluZGV4LFxyXG4gIEZvY3VzYWJsZU9wdGlvbiB7XHJcbiAgcHJpdmF0ZSBfc2l6ZTogQnV0dG9uU2l6ZSA9ICdtZCc7XHJcbiAgd2lkdGhIaWVnaHRTdmcgPSAxMjtcclxuICBASW5wdXQoKVxyXG5cclxuICBnZXQgc2l6ZSgpOiBCdXR0b25TaXplIHsgcmV0dXJuIHRoaXMuX3NpemU7IH1cclxuICBzZXQgc2l6ZSh2YWx1ZTogQnV0dG9uU2l6ZSkge1xyXG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9zaXplKSB7XHJcbiAgICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcclxuICAgICAgdGhpcy53aWR0aEhpZWdodFN2ZyA9IHRoaXMuX3NpemUgPT0gXCJzbVwiID8gMTAgOiB0aGlzLl9zaXplID09IFwibGdcIiA/IDE0IDogMTI7XHJcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBBdHRhY2hlZCB0byB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgZWxlbWVudC4gSW4gbW9zdCBjYXNlcywgYXJpYS1sYWJlbGxlZGJ5IHdpbGxcclxuICAgKiB0YWtlIHByZWNlZGVuY2Ugc28gdGhpcyBtYXkgYmUgb21pdHRlZC5cclxuICAgKi9cclxuICBASW5wdXQoJ2FyaWEtbGFiZWwnKSBhcmlhTGFiZWw6IHN0cmluZyA9ICcnO1xyXG5cclxuICAvKipcclxuICAgKiBVc2VycyBjYW4gc3BlY2lmeSB0aGUgYGFyaWEtbGFiZWxsZWRieWAgYXR0cmlidXRlIHdoaWNoIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZSBpbnB1dCBlbGVtZW50XHJcbiAgICovXHJcbiAgQElucHV0KCdhcmlhLWxhYmVsbGVkYnknKSBhcmlhTGFiZWxsZWRieTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIC8qKiBUaGUgJ2FyaWEtZGVzY3JpYmVkYnknIGF0dHJpYnV0ZSBpcyByZWFkIGFmdGVyIHRoZSBlbGVtZW50J3MgbGFiZWwgYW5kIGZpZWxkIHR5cGUuICovXHJcbiAgQElucHV0KCdhcmlhLWRlc2NyaWJlZGJ5JykgYXJpYURlc2NyaWJlZGJ5ITogc3RyaW5nO1xyXG5cclxuICBwcml2YXRlIF91bmlxdWVJZDogc3RyaW5nID0gYHRkcy1jaGVja2JveC0keysrbmV4dFVuaXF1ZUlkfWA7XHJcblxyXG4gIC8qKiBBIHVuaXF1ZSBpZCBmb3IgdGhlIGNoZWNrYm94IGlucHV0LiBJZiBub25lIGlzIHN1cHBsaWVkLCBpdCB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkLiAqL1xyXG4gIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSB0aGlzLl91bmlxdWVJZDtcclxuXHJcbiAgLyoqIFJldHVybnMgdGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQuICovXHJcbiAgZ2V0IGlucHV0SWQoKTogc3RyaW5nIHsgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fdW5pcXVlSWR9LWlucHV0YDsgfVxyXG5cclxuICAvKiogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgcmVxdWlyZWQuICovXHJcbiAgQElucHV0KClcclxuICBnZXQgcmVxdWlyZWQoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9yZXF1aXJlZDsgfVxyXG4gIHNldCByZXF1aXJlZCh2YWx1ZTogYm9vbGVhbikgeyB0aGlzLl9yZXF1aXJlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cclxuICBwcml2YXRlIF9yZXF1aXJlZCE6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBOYW1lIHZhbHVlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBwcmVzZW50ICovXHJcbiAgQElucHV0KCkgbmFtZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNoZWNrYm94J3MgYGNoZWNrZWRgIHZhbHVlIGNoYW5nZXMuICovXHJcbiAgQE91dHB1dCgpIHJlYWRvbmx5IHRkc0NoYW5nZTogRXZlbnRFbWl0dGVyPFREU0NoZWNrYm94Q2hhbmdlPiA9XHJcbiAgICBuZXcgRXZlbnRFbWl0dGVyPFREU0NoZWNrYm94Q2hhbmdlPigpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBz4bq9IGtow7RuZyBo4buXIHRy4bujIHThu6sgYuG6o24gMi4xLjAsIGTDuW5nIHRkc0NoYW5nZSDEkeG7gyB0aGF5IHRo4bq/XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSByZWFkb25seSBjaGFuZ2U6IEV2ZW50RW1pdHRlcjxURFNDaGVja2JveENoYW5nZT4gPVxyXG4gICAgbmV3IEV2ZW50RW1pdHRlcjxURFNDaGVja2JveENoYW5nZT4oKTtcclxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjaGVja2JveCdzIGBpbmRldGVybWluYXRlYCB2YWx1ZSBjaGFuZ2VzLiAqL1xyXG4gIEBPdXRwdXQoKSByZWFkb25seSBpbmRldGVybWluYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gIC8qKiBUaGUgdmFsdWUgYXR0cmlidXRlIG9mIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCAqL1xyXG4gIEBJbnB1dCgpIHZhbHVlITogc3RyaW5nO1xyXG5cclxuICAvKiogVGhlIG5hdGl2ZSBgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiPmAgZWxlbWVudCAqL1xyXG4gIEBWaWV3Q2hpbGQoJ2lucHV0JykgX2lucHV0RWxlbWVudCE6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD47XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjaGVja2JveCBpcyBibHVycmVkLiBOZWVkZWQgdG8gcHJvcGVybHkgaW1wbGVtZW50IENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxyXG4gICAqIEBkb2NzLXByaXZhdGVcclxuICAgKi9cclxuICBfb25Ub3VjaGVkOiAoKSA9PiBhbnkgPSAoKSA9PiB7IH07XHJcblxyXG5cclxuXHJcbiAgcHJpdmF0ZSBfY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbjogKHZhbHVlOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XHJcblxyXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxyXG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgcHJpdmF0ZSBfZm9jdXNNb25pdG9yOiBGb2N1c01vbml0b3IsXHJcbiAgICBAQXR0cmlidXRlKCd0YWJpbmRleCcpIHRhYkluZGV4OiBzdHJpbmcsXHJcblxyXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChURFNfQ0hFQ0tCT1hfREVGQVVMVF9PUFRJT05TKVxyXG4gICAgcHJpdmF0ZSBfb3B0aW9ucz86IFREU0NoZWNrYm94RGVmYXVsdE9wdGlvbnMpIHtcclxuICAgIHN1cGVyKGVsZW1lbnRSZWYpO1xyXG4gICAgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgfHwgZGVmYXVsdHM7XHJcbiAgICB0aGlzLnRhYkluZGV4ID0gcGFyc2VJbnQodGFiSW5kZXgpIHx8IDA7XHJcbiAgfVxyXG5cclxuICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICB0aGlzLl9mb2N1c01vbml0b3IubW9uaXRvcih0aGlzLl9lbGVtZW50UmVmLCB0cnVlKS5zdWJzY3JpYmUoZm9jdXNPcmlnaW4gPT4ge1xyXG4gICAgICBpZiAoIWZvY3VzT3JpZ2luKSB7XHJcbiAgICAgICAgLy8gV2hlbiBhIGZvY3VzZWQgZWxlbWVudCBiZWNvbWVzIGRpc2FibGVkLCB0aGUgYnJvd3NlciAqaW1tZWRpYXRlbHkqIGZpcmVzIGEgYmx1ciBldmVudC5cclxuICAgICAgICAvLyBBbmd1bGFyIGRvZXMgbm90IGV4cGVjdCBldmVudHMgdG8gYmUgcmFpc2VkIGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uLCBzbyBhbnkgc3RhdGUgY2hhbmdlXHJcbiAgICAgICAgLy8gKHN1Y2ggYXMgYSBmb3JtIGNvbnRyb2wncyAnbmctdG91Y2hlZCcpIHdpbGwgY2F1c2UgYSBjaGFuZ2VkLWFmdGVyLWNoZWNrZWQgZXJyb3IuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE3NzkzLiBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSBkZWZlclxyXG4gICAgICAgIC8vIHRlbGxpbmcgdGhlIGZvcm0gY29udHJvbCBpdCBoYXMgYmVlbiB0b3VjaGVkIHVudGlsIHRoZSBuZXh0IHRpY2suXHJcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9vblRvdWNoZWQoKTtcclxuICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9zeW5jSW5kZXRlcm1pbmF0ZSh0aGlzLl9pbmRldGVybWluYXRlKTtcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IERlbGV0ZSBuZXh0IG1ham9yIHJldmlzaW9uLlxyXG4gIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHsgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpIHtcclxuICAgIHRoaXMuX2ZvY3VzTW9uaXRvci5zdG9wTW9uaXRvcmluZyh0aGlzLl9lbGVtZW50UmVmKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGNoZWNrZWQuXHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICBnZXQgY2hlY2tlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7IH1cclxuICBzZXQgY2hlY2tlZCh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgaWYgKHZhbHVlICE9IHRoaXMuY2hlY2tlZCkge1xyXG4gICAgICB0aGlzLl9jaGVja2VkID0gdmFsdWU7XHJcbiAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgfVxyXG4gIH1cclxuICBwcml2YXRlIF9jaGVja2VkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGRpc2FibGVkLiBUaGlzIGZ1bGx5IG92ZXJyaWRlcyB0aGUgaW1wbGVtZW50YXRpb24gcHJvdmlkZWQgYnlcclxuICAgKiBtaXhpbkRpc2FibGVkLCBidXQgdGhlIG1peGluIGlzIHN0aWxsIHJlcXVpcmVkIGJlY2F1c2UgbWl4aW5UYWJJbmRleCByZXF1aXJlcyBpdC5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBkaXNhYmxlZCgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9XHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBhbnkpIHtcclxuICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcclxuXHJcbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuZGlzYWJsZWQpIHtcclxuICAgICAgdGhpcy5fZGlzYWJsZWQgPSBuZXdWYWx1ZTtcclxuICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGluZGV0ZXJtaW5hdGUuIFRoaXMgaXMgYWxzbyBrbm93biBhcyBcIm1peGVkXCIgbW9kZSBhbmQgY2FuIGJlIHVzZWQgdG9cclxuICAgKiByZXByZXNlbnQgYSBjaGVja2JveCB3aXRoIHRocmVlIHN0YXRlcywgZS5nLiBhIGNoZWNrYm94IHRoYXQgcmVwcmVzZW50cyBhIG5lc3RlZCBsaXN0IG9mXHJcbiAgICogY2hlY2thYmxlIGl0ZW1zLiBOb3RlIHRoYXQgd2hlbmV2ZXIgY2hlY2tib3ggaXMgbWFudWFsbHkgY2xpY2tlZCwgaW5kZXRlcm1pbmF0ZSBpcyBpbW1lZGlhdGVseVxyXG4gICAqIHNldCB0byBmYWxzZS5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBpbmRldGVybWluYXRlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faW5kZXRlcm1pbmF0ZTsgfVxyXG4gIHNldCBpbmRldGVybWluYXRlKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICBjb25zdCBjaGFuZ2VkID0gdmFsdWUgIT0gdGhpcy5faW5kZXRlcm1pbmF0ZTtcclxuICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xyXG5cclxuICAgIGlmIChjaGFuZ2VkKSB7XHJcblxyXG4gICAgICB0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UuZW1pdCh0aGlzLl9pbmRldGVybWluYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zeW5jSW5kZXRlcm1pbmF0ZSh0aGlzLl9pbmRldGVybWluYXRlKTtcclxuICB9XHJcbiAgcHJpdmF0ZSBfaW5kZXRlcm1pbmF0ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHJcblxyXG4gIC8qKiBNZXRob2QgYmVpbmcgY2FsbGVkIHdoZW5ldmVyIHRoZSBsYWJlbCB0ZXh0IGNoYW5nZXMuICovXHJcbiAgX29uTGFiZWxUZXh0Q2hhbmdlKCkge1xyXG4gICAgLy8gU2luY2UgdGhlIGV2ZW50IG9mIHRoZSBgY2RrT2JzZXJ2ZUNvbnRlbnRgIGRpcmVjdGl2ZSBydW5zIG91dHNpZGUgb2YgdGhlIHpvbmUsIHRoZSBjaGVja2JveFxyXG4gICAgLy8gY29tcG9uZW50IHdpbGwgYmUgb25seSBtYXJrZWQgZm9yIGNoZWNrLCBidXQgbm8gYWN0dWFsIGNoYW5nZSBkZXRlY3Rpb24gcnVucyBhdXRvbWF0aWNhbGx5LlxyXG4gICAgLy8gSW5zdGVhZCBvZiBnb2luZyBiYWNrIGludG8gdGhlIHpvbmUgaW4gb3JkZXIgdG8gdHJpZ2dlciBhIGNoYW5nZSBkZXRlY3Rpb24gd2hpY2ggY2F1c2VzXHJcbiAgICAvLyAqYWxsKiBjb21wb25lbnRzIHRvIGJlIGNoZWNrZWQgKGlmIGV4cGxpY2l0bHkgbWFya2VkIG9yIG5vdCB1c2luZyBPblB1c2gpLCB3ZSBvbmx5IHRyaWdnZXJcclxuICAgIC8vIGFuIGV4cGxpY2l0IGNoYW5nZSBkZXRlY3Rpb24gZm9yIHRoZSBjaGVja2JveCB2aWV3IGFuZCBpdHMgY2hpbGRyZW4uXHJcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XHJcbiAgfVxyXG5cclxuICAvLyBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxyXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xyXG4gICAgdGhpcy5jaGVja2VkID0gISF2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXHJcbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBhbnkpID0+IHZvaWQpIHtcclxuICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcclxuICB9XHJcblxyXG4gIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXHJcbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSkge1xyXG4gICAgdGhpcy5fb25Ub3VjaGVkID0gZm47XHJcbiAgfVxyXG5cclxuICAvLyBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxyXG4gIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbikge1xyXG4gICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XHJcbiAgfVxyXG5cclxuICBfZ2V0QXJpYUNoZWNrZWQoKTogJ3RydWUnIHwgJ2ZhbHNlJyB8ICdtaXhlZCcge1xyXG4gICAgaWYgKHRoaXMuY2hlY2tlZCkge1xyXG4gICAgICByZXR1cm4gJ3RydWUnO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGUgPyAnbWl4ZWQnIDogJ2ZhbHNlJztcclxuICB9XHJcblxyXG5cclxuXHJcbiAgcHJpdmF0ZSBfZW1pdENoYW5nZUV2ZW50KCkge1xyXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgVERTQ2hlY2tib3hDaGFuZ2UoKTtcclxuICAgIGV2ZW50LnNvdXJjZSA9IHRoaXM7XHJcbiAgICBldmVudC5jaGVja2VkID0gdGhpcy5jaGVja2VkO1xyXG5cclxuICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4odGhpcy5jaGVja2VkKTtcclxuICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xyXG4gICAgdGhpcy50ZHNDaGFuZ2UuZW1pdChldmVudCk7ICAgIFxyXG4gICAgLy8gQXNzaWduaW5nIHRoZSB2YWx1ZSBhZ2FpbiBoZXJlIGlzIHJlZHVuZGFudCwgYnV0IHdlIGhhdmUgdG8gZG8gaXQgaW4gY2FzZSBpdCB3YXNcclxuICAgIC8vIGNoYW5nZWQgaW5zaWRlIHRoZSBgY2hhbmdlYCBsaXN0ZW5lciB3aGljaCB3aWxsIGNhdXNlIHRoZSBpbnB1dCB0byBiZSBvdXQgb2Ygc3luYy5cclxuICAgIGlmICh0aGlzLl9pbnB1dEVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBUb2dnbGVzIHRoZSBgY2hlY2tlZGAgc3RhdGUgb2YgdGhlIGNoZWNrYm94LiAqL1xyXG4gIHRvZ2dsZSgpOiB2b2lkIHtcclxuICAgIFxyXG4gICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNoZWNrYm94IGlucHV0IGVsZW1lbnQuXHJcbiAgICogVG9nZ2xlcyBjaGVja2VkIHN0YXRlIGlmIGVsZW1lbnQgaXMgbm90IGRpc2FibGVkLlxyXG4gICAqIERvIG5vdCB0b2dnbGUgb24gKGNoYW5nZSkgZXZlbnQgc2luY2UgSUUgZG9lc24ndCBmaXJlIGNoYW5nZSBldmVudCB3aGVuXHJcbiAgICogICBpbmRldGVybWluYXRlIGNoZWNrYm94IGlzIGNsaWNrZWQuXHJcbiAgICogQHBhcmFtIGV2ZW50XHJcbiAgICovXHJcbiAgX29uSW5wdXRDbGljayhldmVudDogRXZlbnQpIHtcclxuICAgIGNvbnN0IGNsaWNrQWN0aW9uID0gdGhpcy5fb3B0aW9ucz8uY2xpY2tBY3Rpb247XHJcblxyXG4gICAgLy8gV2UgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBjbGljayBldmVudHMgb24gdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQgZWxlbWVudC5cclxuICAgIC8vIEJ5IGRlZmF1bHQsIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIGxhYmVsIGVsZW1lbnQsIGEgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IHdpbGwgYmVcclxuICAgIC8vIGRpc3BhdGNoZWQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gU2luY2Ugd2UgYXJlIHVzaW5nIGEgbGFiZWwgZWxlbWVudCBhcyBvdXJcclxuICAgIC8vIHJvb3QgY29udGFpbmVyLCB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIGBjaGVja2JveGAgd2lsbCBiZSBleGVjdXRlZCB0d2ljZS5cclxuICAgIC8vIFRoZSByZWFsIGNsaWNrIGV2ZW50IHdpbGwgYnViYmxlIHVwLCBhbmQgdGhlIGdlbmVyYXRlZCBjbGljayBldmVudCBhbHNvIHRyaWVzIHRvIGJ1YmJsZSB1cC5cclxuICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cclxuICAgIC8vIFByZXZlbnRpbmcgYnViYmxpbmcgZm9yIHRoZSBzZWNvbmQgZXZlbnQgd2lsbCBzb2x2ZSB0aGF0IGlzc3VlLlxyXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgLy8gSWYgcmVzZXRJbmRldGVybWluYXRlIGlzIGZhbHNlLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgaXMgaW5kZXRlcm1pbmF0ZSwgZG8gbm90aGluZyBvbiBjbGlja1xyXG4gICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIGNsaWNrQWN0aW9uICE9PSAnbm9vcCcpIHtcclxuICAgICAgLy8gV2hlbiB1c2VyIG1hbnVhbGx5IGNsaWNrIG9uIHRoZSBjaGVja2JveCwgYGluZGV0ZXJtaW5hdGVgIGlzIHNldCB0byBmYWxzZS5cclxuICAgICAgaWYgKHRoaXMuaW5kZXRlcm1pbmF0ZSAmJiBjbGlja0FjdGlvbiAhPT0gJ2NoZWNrJykge1xyXG5cclxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZS5lbWl0KHRoaXMuX2luZGV0ZXJtaW5hdGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnRvZ2dsZSgpO1xyXG4gICAgICAvLyAgdGhpcy5fdHJhbnNpdGlvbkNoZWNrU3RhdGUoXHJcbiAgICAgIC8vICAgICAgdGhpcy5fY2hlY2tlZCA/IFRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgOiBUcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQpO1xyXG5cclxuICAgICAgLy8gRW1pdCBvdXIgY3VzdG9tIGNoYW5nZSBldmVudCBpZiB0aGUgbmF0aXZlIGlucHV0IGVtaXR0ZWQgb25lLlxyXG4gICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gb25seSBlbWl0IGl0LCBpZiB0aGUgbmF0aXZlIGlucHV0IHRyaWdnZXJlZCBvbmUsIGJlY2F1c2VcclxuICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCB3aGVuIHRoZSBgY2hlY2tlZGAgdmFyaWFibGUgY2hhbmdlcyBmb3IgZXhhbXBsZS5cclxuICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XHJcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmRpc2FibGVkICYmIGNsaWNrQWN0aW9uID09PSAnbm9vcCcpIHtcclxuICAgICAgLy8gUmVzZXQgbmF0aXZlIGlucHV0IHdoZW4gY2xpY2tlZCB3aXRoIG5vb3AuIFRoZSBuYXRpdmUgY2hlY2tib3ggYmVjb21lcyBjaGVja2VkIGFmdGVyXHJcbiAgICAgIC8vIGNsaWNrLCByZXNldCBpdCB0byBiZSBhbGlnbiB3aXRoIGBjaGVja2VkYCB2YWx1ZSBvZiBgbWF0LWNoZWNrYm94YC5cclxuICAgICAgdGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcclxuICAgICAgdGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9IHRoaXMuaW5kZXRlcm1pbmF0ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBGb2N1c2VzIHRoZSBjaGVja2JveC4gKi9cclxuICBmb2N1cyhvcmlnaW4/OiBGb2N1c09yaWdpbiwgb3B0aW9ucz86IEZvY3VzT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgaWYgKG9yaWdpbikge1xyXG4gICAgICB0aGlzLl9mb2N1c01vbml0b3IuZm9jdXNWaWEodGhpcy5faW5wdXRFbGVtZW50LCBvcmlnaW4sIG9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMob3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfb25JbnRlcmFjdGlvbkV2ZW50KGV2ZW50OiBFdmVudCkge1xyXG4gICAgLy8gV2UgYWx3YXlzIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBvbiB0aGUgY2hhbmdlIGV2ZW50LlxyXG4gICAgLy8gT3RoZXJ3aXNlIHRoZSBjaGFuZ2UgZXZlbnQsIGZyb20gdGhlIGlucHV0IGVsZW1lbnQsIHdpbGwgYnViYmxlIHVwIGFuZFxyXG4gICAgLy8gZW1pdCBpdHMgZXZlbnQgb2JqZWN0IHRvIHRoZSBgY2hhbmdlYCBvdXRwdXQuXHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBTeW5jcyB0aGUgaW5kZXRlcm1pbmF0ZSB2YWx1ZSB3aXRoIHRoZSBjaGVja2JveCBET00gbm9kZS5cclxuICAgKlxyXG4gICAqIFdlIHN5bmMgYGluZGV0ZXJtaW5hdGVgIGRpcmVjdGx5IG9uIHRoZSBET00gbm9kZSwgYmVjYXVzZSBpbiBJdnkgdGhlIGNoZWNrIGZvciB3aGV0aGVyIGFcclxuICAgKiBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQgb24gYW4gZWxlbWVudCBib2lscyBkb3duIHRvIGBpZiAocHJvcE5hbWUgaW4gZWxlbWVudClgLiBEb21pbm8nc1xyXG4gICAqIEhUTUxJbnB1dEVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGBpbmRldGVybWluYXRlYCBwcm9wZXJ0eSBzbyBJdnkgd2lsbCB3YXJuIGR1cmluZ1xyXG4gICAqIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cclxuICAgKi9cclxuICBwcml2YXRlIF9zeW5jSW5kZXRlcm1pbmF0ZSh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgY29uc3QgbmF0aXZlQ2hlY2tib3ggPSB0aGlzLl9pbnB1dEVsZW1lbnQ7XHJcblxyXG4gICAgaWYgKG5hdGl2ZUNoZWNrYm94KSB7XHJcbiAgICAgIG5hdGl2ZUNoZWNrYm94Lm5hdGl2ZUVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2Rpc2FibGVkOiBCb29sZWFuSW5wdXQ7XHJcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3JlcXVpcmVkOiBCb29sZWFuSW5wdXQ7XHJcbiAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2Rpc2FibGVSaXBwbGU6IEJvb2xlYW5JbnB1dDtcclxuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfaW5kZXRlcm1pbmF0ZTogQm9vbGVhbklucHV0O1xyXG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV90YWJJbmRleDogTnVtYmVySW5wdXQ7XHJcbn1cclxuIiwiPGxhYmVsIGNsYXNzPVwiZmxleCBpdGVtcy1jZW50ZXIgZ3JvdXBcIiBbYXR0ci5mb3JdPVwiaW5wdXRJZFwiICNsYWJlbD5cclxuICAgIDxzcGFuXHJcbiAgICAgICAgY2xhc3M9XCJwLTAuNSBib3JkZXIgcm91bmRlZCAgIHJlbGF0aXZlIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJveC1jb250ZW50IGJvcmRlci1uZXV0cmFsLTItMjAwIGRhcms6Ym9yZGVyLWQtbmV1dHJhbC0yLTIwMFwiXHJcbiAgICAgICAgW25nQ2xhc3NdPVwieydncm91cC1ob3Zlcjpib3JkZXItcHJpbWFyeS0xICBjdXJzb3ItcG9pbnRlcic6IWRpc2FibGVkLFxyXG4gICAgICAgICdiZy1wcmltYXJ5LTEgYm9yZGVyLXByaW1hcnktMSc6IWRpc2FibGVkICAmJiAoY2hlY2tlZCB8fCBpbmRldGVybWluYXRlKSxcclxuICAgICAgICAnYmctd2hpdGUgZGFyazpiZy1kLW5ldXRyYWwtMy01MCAnOiFjaGVja2VkICYmICFpbmRldGVybWluYXRlLFxyXG4gICAgICAgICcgYmctbmV1dHJhbC0zLTUwIGRhcms6YmctZC1uZXV0cmFsLTItMjAwJzpkaXNhYmxlZCAmJiAhY2hlY2tlZCAmJiAhaW5kZXRlcm1pbmF0ZSxcclxuICAgICAgICAnIGJnLW5ldXRyYWwtMi0yMDAgZGFyazpiZy1kLW5ldXRyYWwtMS0yMDAnOmRpc2FibGVkICYmIChjaGVja2VkIHx8IGluZGV0ZXJtaW5hdGUpLFxyXG4gICAgICAgICdjdXJzb3Itbm90LWFsbG93ZWQnOmRpc2FibGVkXHJcbiAgICB9XCI+XHJcbiAgICAgICAgPGlucHV0ICNpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxyXG4gICAgICAgICAgICBjbGFzcz1cImJvcmRlci0wIG92ZXJmbG93LWhpZGRlbiBwYWRkaW5nLTAgYWJzb2x1dGUgd2hpdGVzcGFjZS1ub3dyYXAgb3V0bGluZSBvdXRsaW5lLW5vbmVcIlxyXG4gICAgICAgICAgICBzdHlsZT1cImhlaWdodDogMXB4OyBtYXJnaW46IC0xcHg7Y2xpcDogcmVjdCgwIDAgMCAwKTsgd2lkdGg6MXB4XCIgW2lkXT1cImlucHV0SWRcIiBbcmVxdWlyZWRdPVwicmVxdWlyZWRcIlxyXG4gICAgICAgICAgICBbY2hlY2tlZF09XCJjaGVja2VkXCIgW2F0dHIudmFsdWVdPVwidmFsdWVcIiBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIiBbYXR0ci5uYW1lXT1cIm5hbWVcIiBbdGFiSW5kZXhdPVwidGFiSW5kZXhcIlxyXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbCB8fCBudWxsXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcclxuICAgICAgICAgICAgW2F0dHIuYXJpYS1jaGVja2VkXT1cIl9nZXRBcmlhQ2hlY2tlZCgpXCIgW2F0dHIuYXJpYS1kZXNjcmliZWRieV09XCJhcmlhRGVzY3JpYmVkYnlcIlxyXG4gICAgICAgICAgICAoY2hhbmdlKT1cIl9vbkludGVyYWN0aW9uRXZlbnQoJGV2ZW50KVwiIChjbGljayk9XCJfb25JbnB1dENsaWNrKCRldmVudClcIiAvPlxyXG5cclxuICAgICAgICA8c3BhbiBbbmdDbGFzc109XCJ7XHJcbiAgICAgICAgICAgICdoLTMgdy0zJzpzaXplID09ICdtZCcsXHJcbiAgICAgICAgICAgICdoLTIuNSB3LTIuNSc6c2l6ZSA9PSAnc20nLFxyXG4gICAgICAgICAgICAnaC0zLjUgdy0zLjUnOnNpemUgPT0gJ2xnJ1xyXG4gICAgICAgIH1cIj5cclxuICAgICAgICAgICAgPHN2ZyAqbmdJZj1cImNoZWNrZWQgJiYgIWluZGV0ZXJtaW5hdGUgXCIgW2F0dHIud2lkdGhdPVwid2lkdGhIaWVnaHRTdmdcIiBbYXR0ci5oZWlnaHRdPVwid2lkdGhIaWVnaHRTdmdcIlxyXG4gICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAxMiA4XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XHJcbiAgICAgICAgICAgICAgICA8cGF0aCBjbGFzcz1cImZpbGwtY3VycmVudCB0ZXh0LXdoaXRlIFwiIFtjbGFzc109XCJ7J2Rhcms6dGV4dC1kLW5ldXRyYWwtMy01MCc6IGRpc2FibGVkfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgZD1cIk0xMC43MzA3IDAuOTAzMTZDMTAuNTM0OCAwLjcwNzc1MSAxMC4yNjk0IDAuNTk4MDQ1IDkuOTkyNzUgMC41OTgwNDVDOS43MTYwNSAwLjU5ODA0NSA5LjQ1MDYxIDAuNzA3NzUxIDkuMjU0NzEgMC45MDMxNkw0Ljc1NDcxIDUuNDAzMTZMMi43ODU3MiAzLjQzNTJDMi42ODk1MyAzLjMzNDY1IDIuNTc0MjYgMy4yNTQyNyAyLjQ0NjYxIDMuMTk4ODhDMi4zMTg5NSAzLjE0MzQ4IDIuMTgxNTIgMy4xMTQxNCAyLjA0MjM3IDMuMTEyNTdDMS45MDMyMyAzLjExMSAxLjc2NTE3IDMuMTM3MjggMS42MzYzIDMuMTg5NzhDMS41MDc0NCAzLjI0MjI5IDEuMzkwMzEgMy4zMTk5OSAxLjI5MTg4IDMuNDE4MzZDMS4xOTM0NSAzLjUxNjcyIDEuMTE1NjUgMy42MzM3NiAxLjA2MzA2IDMuNzYyNkMxLjAxMDQ3IDMuODkxNDMgMC45ODQxMzUgNC4wMjk0NiAwLjk4NTYwOSA0LjE2ODZDMC45ODcwODIgNC4zMDc3NSAxLjAxNjM2IDQuNDQ1MjEgMS4wNzE2NyA0LjU3MjlDMS4xMjY5OCA0LjcwMDU5IDEuMjA3MjYgNC44MTU5NCAxLjMwNzc1IDQuOTEyMTlMNC4wMTY3NCA3LjYyMDJDNC4yMTI5OCA3LjgxNTczIDQuNDc4NzIgNy45MjU1IDQuNzU1NzUgNy45MjU1QzUuMDMyNzggNy45MjU1IDUuMjk4NDYgNy44MTU3MyA1LjQ5NDcgNy42MjAyTDEwLjczNjcgMi4zODAyMUMxMC44MzQ2IDIuMjgzMjMgMTAuOTEyMyAyLjE2NzggMTAuOTY1MyAyLjA0MDYxQzExLjAxODQgMS45MTM0MyAxMS4wNDU3IDEuNzc2OTggMTEuMDQ1NyAxLjYzOTE4QzExLjA0NTcgMS41MDEzOCAxMS4wMTg0IDEuMzY0OTQgMTAuOTY1MyAxLjIzNzc1QzEwLjkxMjMgMS4xMTA1NyAxMC44MzQ2IDAuOTk1MTkzIDEwLjczNjcgMC44OTgyMTZMMTAuNzMwNyAwLjkwMzE2WlwiIC8+XHJcbiAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICA8c3ZnICpuZ0lmPVwiaW5kZXRlcm1pbmF0ZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBbYXR0ci53aWR0aF09XCJ3aWR0aEhpZWdodFN2Z1wiXHJcbiAgICAgICAgICAgICAgICBbYXR0ci5oZWlnaHRdPVwid2lkdGhIaWVnaHRTdmdcIiB2aWV3Qm94PVwiMCAwIDEyIDRcIiBmaWxsPVwibm9uZVwiPlxyXG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIlxyXG4gICAgICAgICAgICAgICAgICAgIGQ9XCJNMC42MDAwMDYgMkMwLjYwMDAwNiAxLjMzNzI2IDEuMTM3MjYgMC44MDAwMDMgMS44MDAwMSAwLjgwMDAwM0wxMC4yIDAuODAwMDAzQzEwLjg2MjcgMC44MDAwMDMgMTEuNCAxLjMzNzI2IDExLjQgMkMxMS40IDIuNjYyNzQgMTAuODYyNyAzLjIgMTAuMiAzLjJMMS44MDAwMSAzLjJDMS4xMzcyNiAzLjIgMC42MDAwMDYgMi42NjI3NCAwLjYwMDAwNiAyWlwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmaWxsLWN1cnJlbnQgdGV4dC13aGl0ZVwiIFtjbGFzc109XCJ7J2Rhcms6dGV4dC1kLW5ldXRyYWwtMy01MCc6IGRpc2FibGVkfVwiIC8+XHJcbiAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgIDwvc3Bhbj5cclxuICAgIDxzcGFuIGNsYXNzPVwibWwtMiB0ZXh0LWJvZHktMiBmb250LXJlZ3VsYXIgIHNlbGVjdC1ub25lIGVtcHR5OmhpZGRlblwiXHJcbiAgICAgICAgW25nQ2xhc3NdPVwieyd0ZXh0LW5ldXRyYWwtMS05MDAgZGFyazp0ZXh0LWQtbmV1dHJhbC0xLTkwMCc6IWRpc2FibGVkLCd0ZXh0LW5ldXRyYWwtMS0zMDAgZGFyazp0ZXh0LWQtbmV1dHJhbC0xLTMwMCc6ZGlzYWJsZWQsJ21sLTInOmNoZWNrYm94TGFiZWwuY2hpbGRyZW4ubGVuZ3RofVwiXHJcbiAgICAgICAgI2NoZWNrYm94TGFiZWwgKGNka09ic2VydmVDb250ZW50KT1cIl9vbkxhYmVsVGV4dENoYW5nZSgpXCJcclxuICAgICAgICBbbmdDbGFzc109XCJ7J2N1cnNvci1wb2ludGVyJzohZGlzYWJsZWQsJ29wYWNpdHktNjUgY3Vyc29yLW5vdC1hbGxvd2VkJzpkaXNhYmxlZH1cIj4gICAgICAgIFxyXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuICAgIDwvc3Bhbj5cclxuPC9sYWJlbD4iXX0=