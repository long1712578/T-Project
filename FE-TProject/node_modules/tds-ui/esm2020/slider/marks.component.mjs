import { __decorate } from "tslib";
import { ChangeDetectionStrategy, Component, Input, ViewEncapsulation } from '@angular/core';
import { InputBoolean } from 'tds-ui/shared/utility';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
const _c0 = function (a0, a1) { return { "top-3.5": a0, "left-3.5": a1 }; };
function TDSSliderMarksComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 2);
} if (rf & 2) {
    const attr_r1 = ctx.$implicit;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("tds-slider-mark-active", attr_r1.active);
    i0.ɵɵproperty("ngStyle", attr_r1.style)("innerHTML", attr_r1.label, i0.ɵɵsanitizeHtml)("ngClass", i0.ɵɵpureFunction2(5, _c0, !ctx_r0.vertical, ctx_r0.vertical));
} }
const _c1 = function (a0, a1) { return { "top-3.5 left-0 w-full": a0, "top-0 left-3.5 w-4.5 h-full": a1 }; };
export class TDSSliderMarksComponent {
    constructor() {
        this.lowerBound = null;
        this.upperBound = null;
        this.marksArray = [];
        this.vertical = false;
        this.included = false;
        this.marks = [];
    }
    ngOnChanges(changes) {
        const { marksArray, lowerBound, upperBound, reverse } = changes;
        if (marksArray || reverse) {
            this.buildMarks();
        }
        if (marksArray || lowerBound || upperBound || reverse) {
            this.togglePointActive();
        }
    }
    trackById(_index, mark) {
        return mark.value;
    }
    buildMarks() {
        const range = this.max - this.min;
        this.marks = this.marksArray.map(mark => {
            const { value, offset, config } = mark;
            const style = this.getMarkStyles(value, range, config);
            const label = isConfigObject(config) ? config.label : config;
            return {
                label,
                offset,
                style,
                value,
                config,
                active: false
            };
        });
    }
    getMarkStyles(value, range, config) {
        let style;
        const markValue = this.reverse ? this.max + this.min - value : value;
        if (this.vertical) {
            style = {
                marginBottom: '-50%',
                bottom: `${((markValue - this.min) / range) * 100}%`
            };
        }
        else {
            style = {
                transform: `translate3d(-50%, 0, 0)`,
                left: `${((markValue - this.min) / range) * 100}%`
            };
        }
        if (isConfigObject(config) && config.style) {
            style = { ...style, ...config.style };
        }
        return style;
    }
    togglePointActive() {
        if (this.marks && this.lowerBound !== null && this.upperBound !== null) {
            this.marks.forEach(mark => {
                const value = mark.value;
                const isActive = (!this.included && value === this.upperBound) ||
                    (this.included && value <= this.upperBound && value >= this.lowerBound);
                mark.active = isActive;
            });
        }
    }
}
TDSSliderMarksComponent.ɵfac = function TDSSliderMarksComponent_Factory(t) { return new (t || TDSSliderMarksComponent)(); };
TDSSliderMarksComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSSliderMarksComponent, selectors: [["tds-slider-marks"]], inputs: { lowerBound: "lowerBound", upperBound: "upperBound", marksArray: "marksArray", min: "min", max: "max", vertical: "vertical", included: "included", reverse: "reverse" }, exportAs: ["tdsSliderMarks"], features: [i0.ɵɵNgOnChangesFeature], decls: 2, vars: 6, consts: [[1, "tds-slider-mark", "absolute", "text-neutral-1-600", "dark:text-d-neutral-1-600", "text-caption-2", 3, "ngClass"], ["class", "tds-slider-mark-text absolute inline-block text-center cursor-pointer select-none ", 3, "tds-slider-mark-active", "ngStyle", "innerHTML", "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "tds-slider-mark-text", "absolute", "inline-block", "text-center", "cursor-pointer", "select-none", 3, "ngStyle", "innerHTML", "ngClass"]], template: function TDSSliderMarksComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtemplate(1, TDSSliderMarksComponent_span_1_Template, 1, 8, "span", 1);
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(3, _c1, !ctx.vertical, ctx.vertical));
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngForOf", ctx.marks)("ngForTrackBy", ctx.trackById);
    } }, directives: [i1.NgClass, i1.NgForOf, i1.NgStyle], encapsulation: 2, changeDetection: 0 });
__decorate([
    InputBoolean()
], TDSSliderMarksComponent.prototype, "vertical", void 0);
__decorate([
    InputBoolean()
], TDSSliderMarksComponent.prototype, "included", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSSliderMarksComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false,
                selector: 'tds-slider-marks',
                exportAs: 'tdsSliderMarks',
                template: `
    <div class="tds-slider-mark absolute  text-neutral-1-600 dark:text-d-neutral-1-600 text-caption-2"
    [ngClass]="{'top-3.5 left-0 w-full':!vertical,'top-0 left-3.5 w-4.5 h-full':vertical}"
    >
      <span
        class="tds-slider-mark-text absolute inline-block text-center cursor-pointer select-none "
        *ngFor="let attr of marks; trackBy: trackById"
        [class.tds-slider-mark-active]="attr.active"       
        [ngStyle]="attr.style!"
        [innerHTML]="attr.label"
        [ngClass]="{'top-3.5':!vertical,'left-3.5':vertical}"
      ></span>
    </div>
  `
            }]
    }], null, { lowerBound: [{
            type: Input
        }], upperBound: [{
            type: Input
        }], marksArray: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], vertical: [{
            type: Input
        }], included: [{
            type: Input
        }], reverse: [{
            type: Input
        }] }); })();
function isConfigObject(config) {
    return typeof config !== 'string';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvdGRzLXVpL3NsaWRlci9tYXJrcy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUdBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUE0QixpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV2SCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7O0lBYS9DLDBCQU9ROzs7O0lBSk4sd0RBQTRDO0lBQzVDLHVDQUF1QiwrQ0FBQSwwRUFBQTs7O0FBTy9CLE1BQU0sT0FBTyx1QkFBdUI7SUFyQnBDO1FBeUJXLGVBQVUsR0FBa0IsSUFBSSxDQUFDO1FBQ2pDLGVBQVUsR0FBa0IsSUFBSSxDQUFDO1FBQ2pDLGVBQVUsR0FBc0IsRUFBRSxDQUFDO1FBR25CLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUcxQyxVQUFLLEdBQXVCLEVBQUUsQ0FBQztLQXdFaEM7SUF0RUMsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLE1BQU0sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFFaEUsSUFBSSxVQUFVLElBQUksT0FBTyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUNuQjtRQUVELElBQUksVUFBVSxJQUFJLFVBQVUsSUFBSSxVQUFVLElBQUksT0FBTyxFQUFFO1lBQ3JELElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1NBQzFCO0lBQ0gsQ0FBQztJQUVELFNBQVMsQ0FBQyxNQUFjLEVBQUUsSUFBc0I7UUFDOUMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFFTyxVQUFVO1FBQ2hCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFH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QyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtnQkFDckMsbUJBQW1CLEVBQUUsS0FBSztnQkFDMUIsUUFBUSxFQUFFLGtCQUFrQjtnQkFDNUIsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7O0dBYVQ7YUFDRjtnQkFLVSxVQUFVO2tCQUFsQixLQUFLO1lBQ0csVUFBVTtrQkFBbEIsS0FBSztZQUNHLFVBQVU7a0JBQWxCLEtBQUs7WUFDRyxHQUFHO2tCQUFYLEtBQUs7WUFDRyxHQUFHO2tCQUFYLEtBQUs7WUFDbUIsUUFBUTtrQkFBaEMsS0FBSztZQUNtQixRQUFRO2tCQUFoQyxLQUFLO1lBQ0csT0FBTztrQkFBZixLQUFLOztBQTRFUixTQUFTLGNBQWMsQ0FBQyxNQUFlO0lBQ3JDLE9BQU8sT0FBTyxNQUFNLEtBQUssUUFBUSxDQUFDO0FBQ3BDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcbmltcG9ydCB7IEJvb2xlYW5JbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5nU3R5bGVJbnRlcmZhY2UgfSBmcm9tICd0ZHMtdWkvY29yZS9jb25maWcnO1xyXG5pbXBvcnQgeyBJbnB1dEJvb2xlYW4gfSBmcm9tICd0ZHMtdWkvc2hhcmVkL3V0aWxpdHknO1xyXG5pbXBvcnQgeyBURFNEaXNwbGF5ZWRNYXJrLCBURFNFeHRlbmRlZE1hcmssIFREU01hcmssIFREU01hcmtPYmogfSBmcm9tICcuL3R5cGluZ3MnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcclxuICBzZWxlY3RvcjogJ3Rkcy1zbGlkZXItbWFya3MnLFxyXG4gIGV4cG9ydEFzOiAndGRzU2xpZGVyTWFya3MnLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8ZGl2IGNsYXNzPVwidGRzLXNsaWRlci1tYXJrIGFic29sdXRlICB0ZXh0LW5ldXRyYWwtMS02MDAgZGFyazp0ZXh0LWQtbmV1dHJhbC0xLTYwMCB0ZXh0LWNhcHRpb24tMlwiXHJcbiAgICBbbmdDbGFzc109XCJ7J3RvcC0zLjUgbGVmdC0wIHctZnVsbCc6IXZlcnRpY2FsLCd0b3AtMCBsZWZ0LTMuNSB3LTQuNSBoLWZ1bGwnOnZlcnRpY2FsfVwiXHJcbiAgICA+XHJcbiAgICAgIDxzcGFuXHJcbiAgICAgICAgY2xhc3M9XCJ0ZHMtc2xpZGVyLW1hcmstdGV4dCBhYnNvbHV0ZSBpbmxpbmUtYmxvY2sgdGV4dC1jZW50ZXIgY3Vyc29yLXBvaW50ZXIgc2VsZWN0LW5vbmUgXCJcclxuICAgICAgICAqbmdGb3I9XCJsZXQgYXR0ciBvZiBtYXJrczsgdHJhY2tCeTogdHJhY2tCeUlkXCJcclxuICAgICAgICBbY2xhc3MudGRzLXNsaWRlci1tYXJrLWFjdGl2ZV09XCJhdHRyLmFjdGl2ZVwiICAgICAgIFxyXG4gICAgICAgIFtuZ1N0eWxlXT1cImF0dHIuc3R5bGUhXCJcclxuICAgICAgICBbaW5uZXJIVE1MXT1cImF0dHIubGFiZWxcIlxyXG4gICAgICAgIFtuZ0NsYXNzXT1cInsndG9wLTMuNSc6IXZlcnRpY2FsLCdsZWZ0LTMuNSc6dmVydGljYWx9XCJcclxuICAgICAgPjwvc3Bhbj5cclxuICAgIDwvZGl2PlxyXG4gIGBcclxufSlcclxuZXhwb3J0IGNsYXNzIFREU1NsaWRlck1hcmtzQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfdmVydGljYWw6IEJvb2xlYW5JbnB1dDtcclxuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfaW5jbHVkZWQ6IEJvb2xlYW5JbnB1dDtcclxuXHJcbiAgQElucHV0KCkgbG93ZXJCb3VuZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgQElucHV0KCkgdXBwZXJCb3VuZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgQElucHV0KCkgbWFya3NBcnJheTogVERTRXh0ZW5kZWRNYXJrW10gPSBbXTtcclxuICBASW5wdXQoKSBtaW4hOiBudW1iZXI7XHJcbiAgQElucHV0KCkgbWF4ITogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSB2ZXJ0aWNhbCA9IGZhbHNlO1xyXG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSBpbmNsdWRlZCA9IGZhbHNlO1xyXG4gIEBJbnB1dCgpIHJldmVyc2UhOiBib29sZWFuO1xyXG5cclxuICBtYXJrczogVERTRGlzcGxheWVkTWFya1tdID0gW107XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGNvbnN0IHsgbWFya3NBcnJheSwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCwgcmV2ZXJzZSB9ID0gY2hhbmdlcztcclxuXHJcbiAgICBpZiAobWFya3NBcnJheSB8fCByZXZlcnNlKSB7XHJcbiAgICAgIHRoaXMuYnVpbGRNYXJrcygpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtYXJrc0FycmF5IHx8IGxvd2VyQm91bmQgfHwgdXBwZXJCb3VuZCB8fCByZXZlcnNlKSB7XHJcbiAgICAgIHRoaXMudG9nZ2xlUG9pbnRBY3RpdmUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRyYWNrQnlJZChfaW5kZXg6IG51bWJlciwgbWFyazogVERTRGlzcGxheWVkTWFyayk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gbWFyay52YWx1ZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYnVpbGRNYXJrcygpOiB2b2lkIHtcclxuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5tYXggLSB0aGlzLm1pbjtcclxuXHJcbiAgICB0aGlzLm1hcmtzID0gdGhpcy5tYXJrc0FycmF5Lm1hcChtYXJrID0+IHtcclxuICAgICAgY29uc3QgeyB2YWx1ZSwgb2Zmc2V0LCBjb25maWcgfSA9IG1hcms7XHJcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5nZXRNYXJrU3R5bGVzKHZhbHVlLCByYW5nZSwgY29uZmlnKTtcclxuICAgICAgY29uc3QgbGFiZWwgPSBpc0NvbmZpZ09iamVjdChjb25maWcpID8gY29uZmlnLmxhYmVsIDogY29uZmlnO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBsYWJlbCxcclxuICAgICAgICBvZmZzZXQsXHJcbiAgICAgICAgc3R5bGUsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgY29uZmlnLFxyXG4gICAgICAgIGFjdGl2ZTogZmFsc2VcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRNYXJrU3R5bGVzKHZhbHVlOiBudW1iZXIsIHJhbmdlOiBudW1iZXIsIGNvbmZpZzogVERTTWFyayk6IE5nU3R5bGVJbnRlcmZhY2Uge1xyXG4gICAgbGV0IHN0eWxlO1xyXG4gICAgY29uc3QgbWFya1ZhbHVlID0gdGhpcy5yZXZlcnNlID8gdGhpcy5tYXggKyB0aGlzLm1pbiAtIHZhbHVlIDogdmFsdWU7XHJcblxyXG4gICAgaWYgKHRoaXMudmVydGljYWwpIHtcclxuICAgICAgc3R5bGUgPSB7XHJcbiAgICAgICAgbWFyZ2luQm90dG9tOiAnLTUwJScsXHJcbiAgICAgICAgYm90dG9tOiBgJHsoKG1hcmtWYWx1ZSAtIHRoaXMubWluKSAvIHJhbmdlKSAqIDEwMH0lYFxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3R5bGUgPSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLTUwJSwgMCwgMClgLFxyXG4gICAgICAgIGxlZnQ6IGAkeygobWFya1ZhbHVlIC0gdGhpcy5taW4pIC8gcmFuZ2UpICogMTAwfSVgXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzQ29uZmlnT2JqZWN0KGNvbmZpZykgJiYgY29uZmlnLnN0eWxlKSB7XHJcbiAgICAgIHN0eWxlID0geyAuLi5zdHlsZSwgLi4uY29uZmlnLnN0eWxlIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0eWxlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB0b2dnbGVQb2ludEFjdGl2ZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLm1hcmtzICYmIHRoaXMubG93ZXJCb3VuZCAhPT0gbnVsbCAmJiB0aGlzLnVwcGVyQm91bmQgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWFyay52YWx1ZTtcclxuICAgICAgICBjb25zdCBpc0FjdGl2ZSA9XHJcbiAgICAgICAgICAoIXRoaXMuaW5jbHVkZWQgJiYgdmFsdWUgPT09IHRoaXMudXBwZXJCb3VuZCkgfHxcclxuICAgICAgICAgICh0aGlzLmluY2x1ZGVkICYmIHZhbHVlIDw9IHRoaXMudXBwZXJCb3VuZCEgJiYgdmFsdWUgPj0gdGhpcy5sb3dlckJvdW5kISk7XHJcblxyXG4gICAgICAgIG1hcmsuYWN0aXZlID0gaXNBY3RpdmU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNDb25maWdPYmplY3QoY29uZmlnOiBURFNNYXJrKTogY29uZmlnIGlzIFREU01hcmtPYmoge1xyXG4gIHJldHVybiB0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJztcclxufVxyXG4iXX0=