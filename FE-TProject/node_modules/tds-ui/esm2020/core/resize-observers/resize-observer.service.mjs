import { coerceElement } from '@angular/cdk/coercion';
import { Injectable } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import * as i0 from "@angular/core";
/**
 * Factory that creates a new ResizeObserver and allows us to stub it out in unit tests.
 */
export class TDSResizeObserverFactory {
    create(callback) {
        return typeof ResizeObserver === 'undefined' ? null : new ResizeObserver(callback);
    }
}
TDSResizeObserverFactory.ɵfac = function TDSResizeObserverFactory_Factory(t) { return new (t || TDSResizeObserverFactory)(); };
TDSResizeObserverFactory.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TDSResizeObserverFactory, factory: TDSResizeObserverFactory.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSResizeObserverFactory, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], null, null); })();
/** An injectable service that allows watching elements for changes to their content. */
export class TDSResizeObserver {
    constructor(tdsResizeObserverFactory) {
        this.tdsResizeObserverFactory = tdsResizeObserverFactory;
        /** Keeps track of the existing ResizeObservers so they can be reused. */
        this.observedElements = new Map();
    }
    ngOnDestroy() {
        this.observedElements.forEach((_, element) => this.cleanupObserver(element));
    }
    observe(elementOrRef) {
        const element = coerceElement(elementOrRef);
        return new Observable((observer) => {
            const stream = this.observeElement(element);
            const subscription = stream.subscribe(observer);
            return () => {
                subscription.unsubscribe();
                this.unobserveElement(element);
            };
        });
    }
    /**
     * Observes the given element by using the existing ResizeObserver if available, or creating a
     * new one if not.
     */
    observeElement(element) {
        if (!this.observedElements.has(element)) {
            const stream = new Subject();
            const observer = this.tdsResizeObserverFactory.create((mutations) => stream.next(mutations));
            if (observer) {
                observer.observe(element);
            }
            this.observedElements.set(element, { observer, stream, count: 1 });
        }
        else {
            this.observedElements.get(element).count++;
        }
        return this.observedElements.get(element).stream;
    }
    /**
     * Un-observes the given element and cleans up the underlying ResizeObserver if nobody else is
     * observing this element.
     */
    unobserveElement(element) {
        if (this.observedElements.has(element)) {
            this.observedElements.get(element).count--;
            if (!this.observedElements.get(element).count) {
                this.cleanupObserver(element);
            }
        }
    }
    /** Clean up the underlying ResizeObserver for the specified element. */
    cleanupObserver(element) {
        if (this.observedElements.has(element)) {
            const { observer, stream } = this.observedElements.get(element);
            if (observer) {
                observer.disconnect();
            }
            stream.complete();
            this.observedElements.delete(element);
        }
    }
}
TDSResizeObserver.ɵfac = function TDSResizeObserver_Factory(t) { return new (t || TDSResizeObserver)(i0.ɵɵinject(TDSResizeObserverFactory)); };
TDSResizeObserver.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TDSResizeObserver, factory: TDSResizeObserver.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSResizeObserver, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: TDSResizeObserverFactory }]; }, null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplLW9ic2VydmVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy90ZHMtdWkvY29yZS9yZXNpemUtb2JzZXJ2ZXJzL3Jlc2l6ZS1vYnNlcnZlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN0RCxPQUFPLEVBQWMsVUFBVSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxVQUFVLEVBQVksT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDOztBQUVyRDs7R0FFRztBQUVILE1BQU0sT0FBTyx3QkFBd0I7SUFDbkMsTUFBTSxDQUFDLFFBQWdDO1FBQ3JDLE9BQU8sT0FBTyxjQUFjLEtBQUssV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JGLENBQUM7O2dHQUhVLHdCQUF3Qjs4RUFBeEIsd0JBQXdCLFdBQXhCLHdCQUF3QixtQkFEWCxNQUFNO3VGQUNuQix3QkFBd0I7Y0FEcEMsVUFBVTtlQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7QUFPbEMsd0ZBQXdGO0FBRXhGLE1BQU0sT0FBTyxpQkFBaUI7SUFXNUIsWUFBb0Isd0JBQWtEO1FBQWxELDZCQUF3QixHQUF4Qix3QkFBd0IsQ0FBMEI7UUFWdEUseUVBQXlFO1FBQ2pFLHFCQUFnQixHQUFHLElBQUksR0FBRyxFQU8vQixDQUFDO0lBRXNFLENBQUM7SUFFM0UsV0FBVztRQUNULElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVELE9BQU8sQ0FBQyxZQUEyQztRQUNqRCxNQUFNLE9BQU8sR0FBRyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDNUMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLFFBQXlDLEVBQUUsRUFBRTtZQUNsRSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzVDLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFaEQsT0FBTyxHQUFHLEVBQUU7Z0JBQ1YsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO2dCQUMzQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDakMsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssY0FBYyxDQUFDLE9BQWdCO1FBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3ZDLE1BQU0sTUFBTSxHQUFHLElBQUksT0FBTyxFQUF5QixDQUFDO1lBQ3BELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFnQyxFQUFFLEVBQUUsQ0FDekYsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FDdkIsQ0FBQztZQUNGLElBQUksUUFBUSxFQUFFO2dCQUNaLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDM0I7WUFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDcEU7YUFBTTtZQUNMLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDN0M7UUFDRCxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFFLENBQUMsTUFBTSxDQUFDO0lBQ3BELENBQUM7SUFFRDs7O09BR0c7SUFDSyxnQkFBZ0IsQ0FBQyxPQUFnQjtRQUN2QyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDdEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUUsQ0FBQyxLQUFLLEVBQUU7Z0JBQzlDLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDL0I7U0FDRjtJQUNILENBQUM7SUFFRCx3RUFBd0U7SUFDaEUsZUFBZSxDQUFDLE9BQWdCO1FBQ3RDLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN0QyxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFFLENBQUM7WUFDakUsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO2FBQ3ZCO1lBQ0QsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2xCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDdkM7SUFDSCxDQUFDOztrRkF6RVUsaUJBQWlCLGNBV2tCLHdCQUF3Qjt1RUFYM0QsaUJBQWlCLFdBQWpCLGlCQUFpQixtQkFESixNQUFNO3VGQUNuQixpQkFBaUI7Y0FEN0IsVUFBVTtlQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTtzQ0FZYyx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcbmltcG9ydCB7IGNvZXJjZUVsZW1lbnQgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xyXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuXHJcbi8qKlxyXG4gKiBGYWN0b3J5IHRoYXQgY3JlYXRlcyBhIG5ldyBSZXNpemVPYnNlcnZlciBhbmQgYWxsb3dzIHVzIHRvIHN0dWIgaXQgb3V0IGluIHVuaXQgdGVzdHMuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxyXG5leHBvcnQgY2xhc3MgVERTUmVzaXplT2JzZXJ2ZXJGYWN0b3J5IHtcclxuICBjcmVhdGUoY2FsbGJhY2s6IFJlc2l6ZU9ic2VydmVyQ2FsbGJhY2spOiBSZXNpemVPYnNlcnZlciB8IG51bGwge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKiBBbiBpbmplY3RhYmxlIHNlcnZpY2UgdGhhdCBhbGxvd3Mgd2F0Y2hpbmcgZWxlbWVudHMgZm9yIGNoYW5nZXMgdG8gdGhlaXIgY29udGVudC4gKi9cclxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcclxuZXhwb3J0IGNsYXNzIFREU1Jlc2l6ZU9ic2VydmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuICAvKiogS2VlcHMgdHJhY2sgb2YgdGhlIGV4aXN0aW5nIFJlc2l6ZU9ic2VydmVycyBzbyB0aGV5IGNhbiBiZSByZXVzZWQuICovXHJcbiAgcHJpdmF0ZSBvYnNlcnZlZEVsZW1lbnRzID0gbmV3IE1hcDxcclxuICAgIEVsZW1lbnQsXHJcbiAgICB7XHJcbiAgICAgIG9ic2VydmVyOiBSZXNpemVPYnNlcnZlciB8IG51bGw7XHJcbiAgICAgIHN0cmVhbTogU3ViamVjdDxSZXNpemVPYnNlcnZlckVudHJ5W10+O1xyXG4gICAgICBjb3VudDogbnVtYmVyO1xyXG4gICAgfVxyXG4gID4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZHNSZXNpemVPYnNlcnZlckZhY3Rvcnk6IFREU1Jlc2l6ZU9ic2VydmVyRmFjdG9yeSkgeyB9XHJcblxyXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5vYnNlcnZlZEVsZW1lbnRzLmZvckVhY2goKF8sIGVsZW1lbnQpID0+IHRoaXMuY2xlYW51cE9ic2VydmVyKGVsZW1lbnQpKTtcclxuICB9XHJcblxyXG4gIG9ic2VydmUoZWxlbWVudE9yUmVmOiBFbGVtZW50IHwgRWxlbWVudFJlZjxFbGVtZW50Pik6IE9ic2VydmFibGU8UmVzaXplT2JzZXJ2ZXJFbnRyeVtdPiB7XHJcbiAgICBjb25zdCBlbGVtZW50ID0gY29lcmNlRWxlbWVudChlbGVtZW50T3JSZWYpO1xyXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcjogT2JzZXJ2ZXI8UmVzaXplT2JzZXJ2ZXJFbnRyeVtdPikgPT4ge1xyXG4gICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLm9ic2VydmVFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdHJlYW0uc3Vic2NyaWJlKG9ic2VydmVyKTtcclxuXHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgdGhpcy51bm9ic2VydmVFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPYnNlcnZlcyB0aGUgZ2l2ZW4gZWxlbWVudCBieSB1c2luZyB0aGUgZXhpc3RpbmcgUmVzaXplT2JzZXJ2ZXIgaWYgYXZhaWxhYmxlLCBvciBjcmVhdGluZyBhXHJcbiAgICogbmV3IG9uZSBpZiBub3QuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvYnNlcnZlRWxlbWVudChlbGVtZW50OiBFbGVtZW50KTogU3ViamVjdDxSZXNpemVPYnNlcnZlckVudHJ5W10+IHtcclxuICAgIGlmICghdGhpcy5vYnNlcnZlZEVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3ViamVjdDxSZXNpemVPYnNlcnZlckVudHJ5W10+KCk7XHJcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy50ZHNSZXNpemVPYnNlcnZlckZhY3RvcnkuY3JlYXRlKChtdXRhdGlvbnM6IFJlc2l6ZU9ic2VydmVyRW50cnlbXSkgPT5cclxuICAgICAgICBzdHJlYW0ubmV4dChtdXRhdGlvbnMpXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChvYnNlcnZlcikge1xyXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5vYnNlcnZlZEVsZW1lbnRzLnNldChlbGVtZW50LCB7IG9ic2VydmVyLCBzdHJlYW0sIGNvdW50OiAxIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5vYnNlcnZlZEVsZW1lbnRzLmdldChlbGVtZW50KSEuY291bnQrKztcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLm9ic2VydmVkRWxlbWVudHMuZ2V0KGVsZW1lbnQpIS5zdHJlYW07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbi1vYnNlcnZlcyB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgY2xlYW5zIHVwIHRoZSB1bmRlcmx5aW5nIFJlc2l6ZU9ic2VydmVyIGlmIG5vYm9keSBlbHNlIGlzXHJcbiAgICogb2JzZXJ2aW5nIHRoaXMgZWxlbWVudC5cclxuICAgKi9cclxuICBwcml2YXRlIHVub2JzZXJ2ZUVsZW1lbnQoZWxlbWVudDogRWxlbWVudCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMub2JzZXJ2ZWRFbGVtZW50cy5oYXMoZWxlbWVudCkpIHtcclxuICAgICAgdGhpcy5vYnNlcnZlZEVsZW1lbnRzLmdldChlbGVtZW50KSEuY291bnQtLTtcclxuICAgICAgaWYgKCF0aGlzLm9ic2VydmVkRWxlbWVudHMuZ2V0KGVsZW1lbnQpIS5jb3VudCkge1xyXG4gICAgICAgIHRoaXMuY2xlYW51cE9ic2VydmVyKGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQ2xlYW4gdXAgdGhlIHVuZGVybHlpbmcgUmVzaXplT2JzZXJ2ZXIgZm9yIHRoZSBzcGVjaWZpZWQgZWxlbWVudC4gKi9cclxuICBwcml2YXRlIGNsZWFudXBPYnNlcnZlcihlbGVtZW50OiBFbGVtZW50KTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5vYnNlcnZlZEVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICBjb25zdCB7IG9ic2VydmVyLCBzdHJlYW0gfSA9IHRoaXMub2JzZXJ2ZWRFbGVtZW50cy5nZXQoZWxlbWVudCkhO1xyXG4gICAgICBpZiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgIH1cclxuICAgICAgc3RyZWFtLmNvbXBsZXRlKCk7XHJcbiAgICAgIHRoaXMub2JzZXJ2ZWRFbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==