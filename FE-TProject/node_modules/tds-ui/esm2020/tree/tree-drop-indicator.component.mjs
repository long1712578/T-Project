import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import * as i0 from "@angular/core";
export class TDSTreeDropIndicatorComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.level = 1;
        this.direction = 'ltr';
        this.style = {};
    }
    ngOnChanges(_changes) {
        this.renderIndicator(this.dropPosition, this.direction);
    }
    renderIndicator(dropPosition, direction = 'ltr') {
        const offset = 4;
        const startPosition = direction === 'ltr' ? 'left' : 'right';
        const endPosition = direction === 'ltr' ? 'right' : 'left';
        const style = {
            [startPosition]: `${offset}px`,
            [endPosition]: '0px'
        };
        switch (dropPosition) {
            case -1:
                style.top = `${-3}px`;
                break;
            case 1:
                style.bottom = `${-3}px`;
                break;
            case 0:
                // dropPosition === 0
                style.bottom = `${-3}px`;
                style[startPosition] = `${offset + 24}px`;
                break;
            default:
                style.display = 'none';
                break;
        }
        this.style = style;
        this.cdr.markForCheck();
    }
}
TDSTreeDropIndicatorComponent.ɵfac = function TDSTreeDropIndicatorComponent_Factory(t) { return new (t || TDSTreeDropIndicatorComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
TDSTreeDropIndicatorComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TDSTreeDropIndicatorComponent, selectors: [["tds-tree-drop-indicator"]], hostVars: 4, hostBindings: function TDSTreeDropIndicatorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵstyleMap(ctx.style);
        i0.ɵɵclassProp("tds-tree-drop-indicator", true);
    } }, inputs: { dropPosition: "dropPosition", level: "level", direction: "direction" }, exportAs: ["TDSTreeDropIndicator"], features: [i0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function TDSTreeDropIndicatorComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TDSTreeDropIndicatorComponent, [{
        type: Component,
        args: [{
                selector: 'tds-tree-drop-indicator',
                exportAs: 'TDSTreeDropIndicator',
                template: ``,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                host: {
                    '[class.tds-tree-drop-indicator]': 'true',
                    '[style]': 'style'
                }
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }]; }, { dropPosition: [{
            type: Input
        }], level: [{
            type: Input
        }], direction: [{
            type: Input
        }] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1kcm9wLWluZGljYXRvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy90ZHMtdWkvdHJlZS90cmVlLWRyb3AtaW5kaWNhdG9yLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsdUJBQXVCLEVBQXFCLFNBQVMsRUFBRSxLQUFLLEVBQTRCLE1BQU0sZUFBZSxDQUFDOztBQWdCdkgsTUFBTSxPQUFPLDZCQUE2QjtJQU14QyxZQUFvQixHQUFzQjtRQUF0QixRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQUpqQyxVQUFLLEdBQVcsQ0FBQyxDQUFDO1FBQ2xCLGNBQVMsR0FBVyxLQUFLLENBQUM7UUFDbkMsVUFBSyxHQUFxQixFQUFFLENBQUM7SUFFZ0IsQ0FBQztJQUU5QyxXQUFXLENBQUMsUUFBdUI7UUFDakMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsWUFBYSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQsZUFBZSxDQUFDLFlBQW9CLEVBQUUsWUFBb0IsS0FBSztRQUM3RCxNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDakIsTUFBTSxhQUFhLEdBQUcsU0FBUyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFDN0QsTUFBTSxXQUFXLEdBQUcsU0FBUyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDM0QsTUFBTSxLQUFLLEdBQXFCO1lBQzlCLENBQUMsYUFBYSxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUk7WUFDOUIsQ0FBQyxXQUFXLENBQUMsRUFBRSxLQUFLO1NBQ3JCLENBQUM7UUFDRixRQUFRLFlBQVksRUFBRTtZQUNwQixLQUFLLENBQUMsQ0FBQztnQkFDTCxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztnQkFDdEIsTUFBTTtZQUNSLEtBQUssQ0FBQztnQkFDSixLQUFLLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztnQkFDekIsTUFBTTtZQUNSLEtBQUssQ0FBQztnQkFDSixxQkFBcUI7Z0JBQ3JCLEtBQUssQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO2dCQUN6QixLQUFLLENBQUMsYUFBYSxDQUFDLEdBQUcsR0FBRyxNQUFNLEdBQUcsRUFBRSxJQUFJLENBQUM7Z0JBQzFDLE1BQU07WUFDUjtnQkFDRSxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztnQkFDdkIsTUFBTTtTQUNUO1FBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUMxQixDQUFDOzswR0F0Q1UsNkJBQTZCO2dGQUE3Qiw2QkFBNkI7Ozs7dUZBQTdCLDZCQUE2QjtjQVh6QyxTQUFTO2VBQUM7Z0JBQ1QsUUFBUSxFQUFFLHlCQUF5QjtnQkFDbkMsUUFBUSxFQUFFLHNCQUFzQjtnQkFDaEMsUUFBUSxFQUFFLEVBQUU7Z0JBQ1osZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07Z0JBQy9DLG1CQUFtQixFQUFFLEtBQUs7Z0JBQzFCLElBQUksRUFBRTtvQkFDSixpQ0FBaUMsRUFBRSxNQUFNO29CQUN6QyxTQUFTLEVBQUUsT0FBTztpQkFDbkI7YUFDRjtvRUFFVSxZQUFZO2tCQUFwQixLQUFLO1lBQ0csS0FBSztrQkFBYixLQUFLO1lBQ0csU0FBUztrQkFBakIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG5cclxuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmdTdHlsZUludGVyZmFjZSB9IGZyb20gJ3Rkcy11aS9jb3JlL2NvbmZpZyc7XHJcblxyXG5cclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAndGRzLXRyZWUtZHJvcC1pbmRpY2F0b3InLFxyXG4gIGV4cG9ydEFzOiAnVERTVHJlZURyb3BJbmRpY2F0b3InLFxyXG4gIHRlbXBsYXRlOiBgYCxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcclxuICBob3N0OiB7XHJcbiAgICAnW2NsYXNzLnRkcy10cmVlLWRyb3AtaW5kaWNhdG9yXSc6ICd0cnVlJyxcclxuICAgICdbc3R5bGVdJzogJ3N0eWxlJ1xyXG4gIH1cclxufSlcclxuZXhwb3J0IGNsYXNzIFREU1RyZWVEcm9wSW5kaWNhdG9yQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICBASW5wdXQoKSBkcm9wUG9zaXRpb24/OiBudW1iZXI7XHJcbiAgQElucHV0KCkgbGV2ZWw6IG51bWJlciA9IDE7XHJcbiAgQElucHV0KCkgZGlyZWN0aW9uOiBzdHJpbmcgPSAnbHRyJztcclxuICBzdHlsZTogTmdTdHlsZUludGVyZmFjZSA9IHt9O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHt9XHJcblxyXG4gIG5nT25DaGFuZ2VzKF9jaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICB0aGlzLnJlbmRlckluZGljYXRvcih0aGlzLmRyb3BQb3NpdGlvbiEsIHRoaXMuZGlyZWN0aW9uKTtcclxuICB9XHJcblxyXG4gIHJlbmRlckluZGljYXRvcihkcm9wUG9zaXRpb246IG51bWJlciwgZGlyZWN0aW9uOiBzdHJpbmcgPSAnbHRyJyk6IHZvaWQge1xyXG4gICAgY29uc3Qgb2Zmc2V0ID0gNDtcclxuICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBkaXJlY3Rpb24gPT09ICdsdHInID8gJ2xlZnQnIDogJ3JpZ2h0JztcclxuICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gZGlyZWN0aW9uID09PSAnbHRyJyA/ICdyaWdodCcgOiAnbGVmdCc7XHJcbiAgICBjb25zdCBzdHlsZTogTmdTdHlsZUludGVyZmFjZSA9IHtcclxuICAgICAgW3N0YXJ0UG9zaXRpb25dOiBgJHtvZmZzZXR9cHhgLFxyXG4gICAgICBbZW5kUG9zaXRpb25dOiAnMHB4J1xyXG4gICAgfTtcclxuICAgIHN3aXRjaCAoZHJvcFBvc2l0aW9uKSB7XHJcbiAgICAgIGNhc2UgLTE6XHJcbiAgICAgICAgc3R5bGUudG9wID0gYCR7LTN9cHhgO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgc3R5bGUuYm90dG9tID0gYCR7LTN9cHhgO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgLy8gZHJvcFBvc2l0aW9uID09PSAwXHJcbiAgICAgICAgc3R5bGUuYm90dG9tID0gYCR7LTN9cHhgO1xyXG4gICAgICAgIHN0eWxlW3N0YXJ0UG9zaXRpb25dID0gYCR7b2Zmc2V0ICsgMjR9cHhgO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XHJcbiAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcclxuICB9XHJcbn1cclxuIl19